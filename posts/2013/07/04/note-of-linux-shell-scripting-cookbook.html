<!DOCTYPE html>
<html lang="en-us">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">
<meta itemprop="name" content="Linux Shell脚本攻略笔记[速查]">
<meta itemprop="description" content="Linux Shell脚本攻略的笔记，markdown编写，可以速查(ctrl&#43;f) 2013-09-08 从历史网摘中补充 2014-02-16 增加&laquo;shell脚本指南&raqu"><meta itemprop="datePublished" content="2013-07-04T08:00:00+08:00" />
<meta itemprop="dateModified" content="2013-07-04T08:00:00+08:00" />
<meta itemprop="wordCount" content="14471">
<meta itemprop="keywords" content="linux,shell," /><meta property="og:title" content="Linux Shell脚本攻略笔记[速查]" />
<meta property="og:description" content="Linux Shell脚本攻略的笔记，markdown编写，可以速查(ctrl&#43;f) 2013-09-08 从历史网摘中补充 2014-02-16 增加&laquo;shell脚本指南&raqu" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wklken.me/posts/2013/07/04/note-of-linux-shell-scripting-cookbook.html" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-07-04T08:00:00+08:00" />
<meta property="article:modified_time" content="2013-07-04T08:00:00+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Linux Shell脚本攻略笔记[速查]"/>
<meta name="twitter:description" content="Linux Shell脚本攻略的笔记，markdown编写，可以速查(ctrl&#43;f) 2013-09-08 从历史网摘中补充 2014-02-16 增加&laquo;shell脚本指南&raqu"/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>Linux Shell脚本攻略笔记[速查]</title>
	<link rel="stylesheet" href="https://wklken.me/css/style.min.037b6ee8f8c1baab6a3d0a9da11c3ff18a7552471f16c59fd98538d5ce99208b.css" integrity="sha256-A3tu6PjBuqtqPQqdoRw/8Yp1UkcfFsWf2YU41c6ZIIs=" crossorigin="anonymous">
	
	<link rel="stylesheet" href="https://wklken.me/css/custom.css">
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://wklken.me">WKLKEN THINKING</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://wklken.me/posts.html">Posts</a>
				<a href="https://wklken.me/about.html">About</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<button id="toc-btn" class="hdr-btn desktop-only-ib" title="Table of Contents"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-list"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3" y2="6"></line><line x1="3" y1="12" x2="3" y2="12"></line><line x1="3" y1="18" x2="3" y2="18"></line></svg></button><span class="hdr-social hide-in-mobile"><a href="https://github.com/wklken" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a><a href="https://twitter.com/wklken" target="_blank" rel="noopener me" title="Twitter"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://wklken.me/posts.html">Posts</a></li>
			<li><a href="https://wklken.me/about.html">About</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Jul 4, 2013</span></div>
				<h1>Linux Shell脚本攻略笔记[速查]</h1>
			</header>
			<div class="content">
				<p>Linux Shell脚本攻略的笔记，markdown编写，可以速查(ctrl+f)</p>
<p>2013-09-08 从历史网摘中补充
2014-02-16 增加&laquo;shell脚本指南&raquo;笔记补充</p>
<hr>
<h3 id="资源">资源<a href="#资源" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p><a href="http://coolshell.cn/articles/9104.html">sed简明教程</a></p>
<p><a href="http://coolshell.cn/articles/9070.html">awk简明教程</a></p>
<hr>
<h3 id="shell-script">shell script<a href="#shell-script" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<pre><code>#!/bin/bash
# do something
</code></pre>
<h3 id="run-shell-script">run shell script<a href="#run-shell-script" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<pre><code>sh script.sh

or

chmod a+x script.sh
./script.sh
# 会读取首行的解释器, 执行
</code></pre>
<p>cmd</p>
<pre><code>cmd1; cmd2

or

cmd1
cmd2
</code></pre>
<h3 id="echo">echo<a href="#echo" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>echo  的功能正如其名，就是基于标准输出打印一段文本</p>
<pre><code>echo &quot;welcome to bash&quot;
echo welcome to bash
</code></pre>
<p>使用不带引号的echo时，无法显示分号</p>
<p>使用单引号echo时，bash不会对单引号中变量求值  &lsquo;$var&rsquo;</p>
<p>echo 中转义换行符</p>
<p>默认情况，echo将换行标志追加到文本尾部，可以忽略结尾换行符</p>
<pre><code>echo -n 'test\n'
</code></pre>
<p>对字符串进行转义</p>
<pre><code>echo -e '1\t2\t3'
</code></pre>
<p>打印彩色输出</p>
<pre><code>文字颜色码
    重置0
    黑色30
    红色31
    绿色32
    黄色33
    蓝色34
    洋红35
    青色36
    白色37

echo -e &quot;\e[1;31m This is red test \e[0m&quot;

背景颜色码
    重置0
    黑色40
    红色41
    绿色42
    黄色43
    蓝色44
    洋红45
    青色46
    白色47

echo -e &quot;\e[1;42m Green Background \e[0m&quot;
</code></pre>
<h3 id="printf">printf<a href="#printf" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>可以格式化字符串, 使用参数同c中printf一样</p>
<pre><code>printf &quot;hello world&quot;
</code></pre>
<p>默认不会加换行符, 需要手动添加</p>
<pre><code>printf &quot;%-5s %-10s %-4.2f\n&quot; 3 Jeff 77.564

3    Jeff      77.56
</code></pre>
<h3 id="环境变量和变量">环境变量和变量<a href="#环境变量和变量" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>bash中，每个变量的值都是字符串，无论你给变量赋值时是否使用引号，值都会以字符串的形式存储</p>
<p>环境变量</p>
<p>查看所有与此终端进程相关的环境变量</p>
<pre><code>env
</code></pre>
<p>查看某个进程的环境变量</p>
<pre><code>cat /proc/$PID/environ
</code></pre>
<p>变量赋值</p>
<pre><code>var=value
var='the value'
var=&quot;the $PARAM&quot;

echo $var
echo ${var}

var = value非变量赋值是相等操作
</code></pre>
<p>环境变量</p>
<pre><code>未在当前进程中定义，而是从父进程中继承而来的变量
export 设置环境变量,之后,从当前shell 执行的任何程序都会继承这个变量

export PYTHONPATH=$PYTHONPATH:/home/ken/workspace
</code></pre>
<p>常用的环境变量</p>
<pre><code>PATH 查找可执行文件路径, 通常定义在/etc/environment or /ect/profile or ~/.bashrc
修改:        export PATH=$PATH:/new/path/
HOME
PWD
USER
UID
SHELL
</code></pre>
<p>获取字符串长度</p>
<pre><code>length=${#var}
</code></pre>
<p>识别当前shell版本</p>
<pre><code>echo $SHELL
    /bin/bash
echo $0
    bash
</code></pre>
<p>检查是否为超级用户 or 普通用户</p>
<pre><code>root的UID=0

if [ $UID -ne 0 ]
then
    echo &quot;not root user&quot;
else
    echo &quot;root&quot;
fi
</code></pre>
<p>修改bash的提示字符</p>
<pre><code>设置PS1变量
\u用户名
\h主机名
\w当前工作目录
</code></pre>
<h3 id="pgrep">pgrep<a href="#pgrep" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>获取某个进程名对应进程id</p>
<pre><code>pgrep gedit
</code></pre>
<h3 id="shell数学运算">shell数学运算<a href="#shell数学运算" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>整数运算</p>
<p>let</p>
<pre><code>no1=4
no2=5
let result=no1+no2

let no1++
let no2--
let no1+=7
let no2-=7
</code></pre>
<p>expr(少用)</p>
<pre><code>result=`expr 3 + 4`
result=$(expr $no1 + 5)
</code></pre>
<p>其他方法</p>
<pre><code>result=$[ no1 + no2 ]
result=$[ $no + 5 ]

result=$(( no1 + 5 ))
</code></pre>
<p>浮点数</p>
<pre><code>echo &quot;4 * 0.56&quot; | bc
设定精度
echo &quot;scale=2;3/8&quot; | bc
进制转换
echo &quot;obase=2;100&quot; | bc
平方
echo &quot;10^10&quot; | bc
平方根
echo &quot;sqrt(100)&quot; | bc
</code></pre>
<h3 id="命令状态">命令状态<a href="#命令状态" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>当命令成功完成, 返回0</p>
<p>发生错误并退回, 返回非0</p>
<p>可以从$?中获取  cmd; echo $?</p>
<h3 id="文件描述符和重定向">文件描述符和重定向<a href="#文件描述符和重定向" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>文件描述符: 与文件输入/输出相关联的整数, 用来跟踪已打开的文件</p>
<pre><code>0 stdin  标砖输入
1 stdout 标准输出
2 stderr 标准错误
</code></pre>
<p>重定向到文件</p>
<pre><code>清空文件写入新内容
echo &quot;test&quot; &gt; temp.txt
追加
echo &quot;test&quot; &gt;&gt; temp.txt

&gt;等价于1&gt;
&gt;&gt;等价于 1&gt;&gt;
</code></pre>
<p>输出分离或合并</p>
<pre><code>分离
cmd 2&gt;stderr.txt  1&gt;stdout.txt

合并
cmd &gt; output.txt 2&gt;&amp;1
or
cmd &amp;&gt; output.txt
</code></pre>
<p>扔到垃圾桶</p>
<pre><code>/dev/null 特殊设备文件, 接收到的任何数据都会被丢弃(位桶/黑洞)

只有标准错误
cmd 2 &gt; /dev/null

标准输出和标准错误
cmd &gt;/dev/null 2&gt;&amp;1
</code></pre>
<p>同时输出到终端和文件</p>
<pre><code>cmd | tee file1

tee默认覆盖，可以-a选项追加
cmd | tee -a file1
</code></pre>
<p>将stdin作为命令参数</p>
<pre><code>cmd1 | cmd2 | cmd3 -
</code></pre>
<p>将文件重定向到命令</p>
<pre><code>cmd &lt; file
</code></pre>
<p>自定义文件描述符</p>
<pre><code>使用文件描述符3打开并读取文件
exec 3&lt;input.txt
cat &lt;&amp;3

使用文件描述符4进行写入
exec 4&gt;output.txt
echo newline &gt;&amp;4
</code></pre>
<h3 id="cat">cat<a href="#cat" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>cat, concatenate(拼接)</p>
<p>“cat”代表了连结（Concatenation），连接两个或者更多文本文件或者以标准输出形式打印文件的内容</p>
<p>一般格式</p>
<pre><code>cat file1 file2 file3

从管道中读取
OUTPUT_FROM_SOME_CMDS | cat

echo &quot;test&quot; | cat - file1
</code></pre>
<p>压缩空白行, 多个连续空行变成单个</p>
<pre><code>cat -s  file
</code></pre>
<p>配合tr移除空白行</p>
<pre><code>cat file | tr -s '\n' #连续多个\n -&gt; \n
</code></pre>
<p>加行号</p>
<pre><code>cat -n file
</code></pre>
<p>显示制表符等</p>
<pre><code>cat -T file

cat f &gt; t
注意：“&gt;&gt;”和“&gt;”调用了追加符号。它们用来追加到文件里，而不是显示在标准输出上。
“&gt;”符号会删除已存在的文件，然后创建一个新的文件。
所以因为安全的原因，建议使用“&gt;&gt;”，它会写入到文件中，而不是覆盖或者删除。
</code></pre>
<p>输入多行文字(CTRL + d 退出)</p>
<pre><code>cat &gt; test.txt
</code></pre>
<h3 id="数组和关联数组">数组和关联数组<a href="#数组和关联数组" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>普通数组，整数作为数组索引, 借助索引将多个独立的数据存储为一个集合(list)</p>
<p>关联数组，可以使用字符串作为索引(map)</p>
<p>数组</p>
<p>定义</p>
<pre><code>array_var=(1 2 3 4 5)

or
array_var[0]=&quot;test1&quot;
array_var[3]=&quot;test3&quot;
</code></pre>
<p>读取</p>
<pre><code>echo ${array_var[0]}
</code></pre>
<p>以清单形式打印</p>
<pre><code>echo ${array_var[*]}
echo ${array_var[@]}
</code></pre>
<p>长度</p>
<pre><code>echo ${#array_var[*]}
</code></pre>
<p>获取索引列表</p>
<pre><code>echo ${!array_var[*]}
</code></pre>
<p>关联数组</p>
<pre><code>declare -A ass_array

内嵌索引-值
ass_array=([index1]=value1 [index2]=value2)

独立
ass_array[index3]=value3

echo ${ass_array[index1]}
</code></pre>
<h3 id="alias">alias<a href="#alias" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>alias是一个系统自建的shell命令，允许你为名字比较长的或者经常使用的命令指定别名。</p>
<pre><code>alias new_command='command seq'
unalias new_command

使用原生命令
\new_command
</code></pre>
<h3 id="date">date<a href="#date" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>“date”命令使用标准的输出打印当前的日期和时间，也可以深入设置</p>
<p>读取日期</p>
<pre><code>date
</code></pre>
<p>时间戳</p>
<pre><code>date +%s
</code></pre>
<p>日期转换为时间戳</p>
<pre><code>date --date &quot;Thu Nov 18 08:07:21 IST 2010&quot; +%s
</code></pre>
<p>日期格式化</p>
<pre><code>星期  %a  Sat
      %A  Saturday
月    %b  Nov
      %B  November
日    %d  31
固定日期格式mm/dd/yy     %D
年    %y  10
      %Y  2010
小时  %I/%H    08
分钟  %M  33
秒    %S  10
纳秒  %N  696308515
Unix纪元时  %s
</code></pre>
<p>格式化</p>
<pre><code>date &quot;+%Y %B %d&quot;

date +%Y-%m-%d
输出： 2011-07-28
date +&quot;%Y-%m-%d %H:%M:%S&quot;
</code></pre>
<p>设置日期和时间</p>
<pre><code>date -s &quot;格式化日期字符串&quot;

date -s &quot;21 June 2009 11:01:22&quot;
</code></pre>
<p>延时</p>
<pre><code>sleep number_of_seconds
</code></pre>
<p>两天后及两天前</p>
<pre><code>date -d '2 days' +%Y%m%d
date -d '2 days ago' +%Y%m%d
</code></pre>
<p>某一天的几天前</p>
<pre><code>TODAY=`date +%Y%m%d`
DAY_1_AGO=`date -d &quot;$TODAY 1 days ago&quot; +%Y%m%d`
</code></pre>
<p>时间戳日期转换</p>
<pre><code>date -d @1193144433
date -d @1193144433 &quot;+%Y-%m-%d %T&quot;

反向:
date -d &quot;2007-10-23 15:00:23&quot; &quot;+%s&quot;
</code></pre>
<p>赋值给变量</p>
<pre><code>DATE=$(date +%Y%m%d)
DATE=`date +%Y%m%d`
</code></pre>
<h3 id="调试脚本">调试脚本<a href="#调试脚本" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>打印出所执行的每一行命令</p>
<pre><code>bash -x script.sh
sh -x script.sh
</code></pre>
<p>在脚本中设置开关</p>
<pre><code>set -x 在执行时显示参数和命令
set +x 关闭调试
set -v 当命令进行读取时显示输入
set +v 禁止打印输入
</code></pre>
<p>直接修改脚本</p>
<pre><code>#!/bin/bash -xv
</code></pre>
<h3 id="函数和参数">函数和参数<a href="#函数和参数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>定义函数</p>
<pre><code>function fname()
{
    statements;
}
or
fname()
{
    statements;
}
</code></pre>
<p>调用</p>
<pre><code>fname;
传参
fname arg1 arg2;
</code></pre>
<p>接收参数</p>
<pre><code>$1第一个参数
$2第二个参数
$n第n个参数

&quot;$@&quot;被扩展成 &quot;$1&quot; &quot;$2&quot; &quot;$3&quot;
&quot;$*&quot;扩展成&quot;$1c$2c$3&quot;, 其中c是IFS第一个字符

&quot;$@&quot;使用最多, $*将所有的参数当做单个字符串
</code></pre>
<p>bash支持递归</p>
<p>导出函数,可以作用到子进程中</p>
<pre><code>export -f fname
</code></pre>
<p>函数及命令返回值</p>
<pre><code>cmd;
echo $?

退出状态，成功退出，状态为0，否则，非0

cmd
if [ $? -eq 0 ]
then
    echo &quot;success&quot;
else
    echo &quot;fail&quot;
fi
</code></pre>
<h3 id="管道">管道<a href="#管道" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>前一个命令的输出作为后一个命令的输入</p>
<pre><code>$cmd1 | cmd2 | cmd3
</code></pre>
<h3 id="读取命令输出">读取命令输出<a href="#读取命令输出" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<pre><code>子shell  subshell
cmd_output=$(COMMANDS)
or
反引用
cmd_output=`COMMANDS`
</code></pre>
<p>子shell本身是独立进程, 不会对当前shell有任何影响</p>
<pre><code>pwd;
(cd /bin; ls)
pwd #同上一个pwd
</code></pre>
<p>保留空格和换行符</p>
<pre><code>out=$(cat text.txt)
echo $out  #丢失所有换行符

out=&quot;$(cat text.txt)&quot;
echo $out  #保留

cat a
1
2
3
echo $(cat a)
1 2 3
echo &quot;$(cat a)&quot;
1
2
3
</code></pre>
<h3 id="read">read<a href="#read" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>read, 用于从键盘或标准输入中读取文本</p>
<p>读取n个字符存入变量</p>
<pre><code>read -n number_of_chars variable_name
</code></pre>
<p>不回显的方式读取密码</p>
<pre><code>read -s var
</code></pre>
<p>显示提示信息</p>
<pre><code>read -p &quot;Enter input:&quot; var
</code></pre>
<p>限时输入</p>
<pre><code>read -t  timeout var
</code></pre>
<p>设置界定符</p>
<pre><code>read -d delim_char var
read -d &quot;:&quot; var
hello:
</code></pre>
<h3 id="字段分隔符和迭代器">字段分隔符和迭代器<a href="#字段分隔符和迭代器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>内部字段分隔符，Internal Field Separator, IFS</p>
<p>IFS默认为空白字符（换行符，制表符，空格）</p>
<pre><code>data=&quot;name,sex,rollno&quot;
oldIFS=$IFS
IFS=,
for item in $data
do
        echo $item
done

IFS=$oldIFS
</code></pre>
<h3 id="循环">循环<a href="#循环" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>for循环</p>
<pre><code>echo {1..50}

for i in {a..z}; do actions; done;

or

for((i=0;i&lt;10;i++))
{
    commands;
}
</code></pre>
<p>while循环</p>
<pre><code>while condition
do
    commands;
done
</code></pre>
<p>until循环</p>
<pre><code>until condition
do
    commands;
done
</code></pre>
<h3 id="比较和测试">比较和测试<a href="#比较和测试" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>if条件</p>
<pre><code>if condition;
then
    commands;
elif condition;
then
    commands;
else
    commands;
fi
</code></pre>
<p>逻辑运算符进行简化, 短路运算更简洁</p>
<pre><code>[ condition ] &amp;&amp; action;
[ condition ] || action;
</code></pre>
<p>算术比较</p>
<pre><code>-gt 大于
-lt 小于
-ge 大于等于
-le 小于等于
-ne 不等于
-eq 等于

注意[]和操作数之间的空格
[ $var -eq 0 ]

and
[ $var -ne 0 -a $var2 -ge 2 ]
or
[ $var -ne 0 -o $var2 -ge 2 ]
</code></pre>
<p>文件测试</p>
<pre><code>[ -f $file_var ] 正常文件路径或文件名
[ -x $var ] 可执行
-d 目录
-e 存在
-c 字符设备文件
-b 块设备文件
-w 可写
-r 可读
-L 符号链接
</code></pre>
<p>字符串比较</p>
<pre><code>[[ $str1 = $str2 ]]
[[ $str1 == $str2 ]]

[[ $str1 != $str2 ]] 不等

[[ $str1 &gt; $str2 ]]
[[ $str1 &lt; $str2 ]]

[[ -z $str1 ]]  空
[[ -n $str1 ]]  非空

if [[ -n $str1 ]] &amp;&amp; [[ -z $str2 ]]
then
    commands;
fi
</code></pre>
<h3 id="find">find<a href="#find" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>搜索指定目录下的文件，从开始于父目录，然后搜索子目录</p>
<p>基本</p>
<pre><code>find base_path

# 打印文件和目录列表
find . -print  #默认\n分割文件名
</code></pre>
<p>文件名</p>
<pre><code>find path -name &quot;*.txt&quot; -print
          -iname  忽略大小写

多个条件 or
find . \( -name &quot;*.txt&quot; -o -name &quot;*.py&quot; \)
</code></pre>
<p>文件路径</p>
<pre><code>通配符
find /home/users -path &quot;*slynux*&quot; -print

正则
find . -regex &quot;.*\(\.py\|\.sh\)$&quot;
       -iregex 忽略大小写
</code></pre>
<p>否定参数</p>
<pre><code>find . ! -name &quot;*.txt&quot; -print
</code></pre>
<p>根据文件类型</p>
<pre><code>find . -type d -print
f 普通文件
l 符号链接
d 目录
c 字符设备
b 块设备
s 套接字
p Fifo
</code></pre>
<p>设定目录深度</p>
<pre><code>find . -maxdepth 1 -type f -print
find . -mindepth 2 -type f -print
</code></pre>
<p>根据文件时间搜索</p>
<pre><code>计量单位 天
-atime 最近一次访问时间
-mtime 最后一次被修改时间
-ctime 文件元数据，最近一次修改时间

find . -type f -atime -7 -print #最近七天内被访问的
find . -type f -atime 7 -print  #恰好在七天前
                      +7 -print #超过七天

计量单位 分钟
-amin 访问时间
-mmin 修改时间
-cmin 变化时间

find . -type f -amin +7 -print #访问时间超过7分钟的

find . -type f -newer file.txt -print  #用于比较时间戳的参考文件，比参考文件更新的文件
</code></pre>
<p>基于文件大小的搜索</p>
<pre><code>find . -type f -size +2k
+ 大于  -小于   无符号，恰好等于

b 块
c 字节
w 字（2字节）
k 千字节
M 兆字节
G 吉字节
</code></pre>
<p>删除匹配的文件</p>
<pre><code>find . -type f -name &quot;*.swp&quot; -delete
#注意：-delete位置一定是最后
</code></pre>
<p>文件权限及所有权</p>
<pre><code>find . -type f -perm 644 -print

find . -type f -user slynux -print
</code></pre>
<p>执行命令或动作(最强大的命令)</p>
<pre><code>find . -type f -user root -exec chown slynux {} \;
find . -type f -exec cp {} OLD \;
find . -iname &quot;abc.txt&quot; -exec md5sum {} \;

{} 江北替换成对应文件名
exec无法结合多个命令，可以将多个命令放入脚本，调用之
</code></pre>
<p>跳过指定目录</p>
<pre><code>find . \( -name &quot;.git&quot; -prune \) -name '*.txt'
</code></pre>
<h3 id="xargs">xargs<a href="#xargs" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>将标准输入数据转化成命令行参数</p>
<p>将stdin接收到的数据重新格式化，再将其作为参数传给其他命令</p>
<p>多行输入转化成单行输出</p>
<pre><code>cat  example.txt | xargs  #空格替换掉\n
</code></pre>
<p>切成多行，每行n个参数</p>
<pre><code>cat examplet.txt | xargs -n 3
</code></pre>
<p>可以指定分隔符</p>
<pre><code>echo &quot;aaaXbbbXccc&quot; | xargs -d 'X'
</code></pre>
<p>将参数传递给脚本(类似循环)</p>
<pre><code>cat args.txt | xargs -n 1 ./cecho.sh

./cecho.sh -p arg1 1
需要变更
cat args.txt | xargs -I {} ./cecho.sh -p {} 1
</code></pre>
<p>find与xargs组合</p>
<pre><code>find . -type f -name &quot;*.txt&quot; -print | xargs rm -rf
</code></pre>
<p>其他</p>
<pre><code>cat file | ( while read arg; do cat $arg; done )
cat file | xargs -I {} cat {}
</code></pre>
<h3 id="tr">tr<a href="#tr" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>tr可以对来自标准输入的字符进行替换，删除以及压缩(translate, 可以将一组字符变成另一组字符)</p>
<p>tr只能通过stdin，无法通过其他命令行进行接收参数</p>
<p>格式</p>
<pre><code>tr [options] source-char-set replace-char-set
</code></pre>
<p>选项</p>
<pre><code>-c 取source-char-set补集，通常与-d/-s配合
-d 删除字source-char-set中的所列的字符
-s 浓缩重复字符，连续多个变成一个
</code></pre>
<p>字符替换</p>
<pre><code>cat /proc/12501/environ | tr '\0' '\n'
</code></pre>
<p>大小写替换</p>
<pre><code>echo  &quot;HELLO&quot; | tr 'A-Z' 'a-z'
cat text | tr '\t' ' '
</code></pre>
<p>删除字符</p>
<pre><code>echo &quot;hello 123 world 456&quot;| tr -d '0-9'
hello  world
</code></pre>
<p>字符集补集</p>
<pre><code>echo &quot;hello 1 char 2&quot; | tr -d -c '0-9'  #删除非0-9
12
</code></pre>
<p>压缩字符</p>
<p>连续的重复字符</p>
<pre><code>echo &quot;GNU is    not UNix&quot; | tr -s ' '
</code></pre>
<p>字符类</p>
<pre><code>alnum 字母和数字
alpha 字母
cntrl 控制字符
digit 数字
graph 图形字符
lower 小写字母
print 可打印字符
punct 标点符号
space 空白字符
upper 大写字母
xdigit 十六进制字符

tr '[:lower:]' '[:upper:]'
</code></pre>
<h3 id="md5sum">md5sum<a href="#md5sum" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>32个字符的十六进制串</p>
<pre><code>md5sum filename
md5sum filename1 filename2
</code></pre>
<h3 id="sha1sum">sha1sum<a href="#sha1sum" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>40个字符十六进制串</p>
<pre><code>sha1sum file
</code></pre>
<h3 id="对目录进行校验">对目录进行校验<a href="#对目录进行校验" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>需安装md5deep软件包</p>
<pre><code>md5deep/sha1deep
md5deep -rl dirname
         r递归，l相对路径
</code></pre>
<h3 id="sort">sort<a href="#sort" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>语法</p>
<pre><code>sort [options] [file(s)]

-c 检查是否已排序
-u 丢弃所有具有相同键值的记录

-b 忽略开头空白
-d 字典序
-g 一般数值，以浮点数类型比较字段，仅支持gnu
-i 忽略无法打印的字符

-k 定义排序键值字段
-n 以整数类型比较字段
-r 倒转
-o 输出到指定文件
</code></pre>
<p>排序</p>
<pre><code>sort file1 &gt; file1.sorted
sort -o file1.sored file1
</code></pre>
<p>按数字, 要明确</p>
<pre><code>sort -n file1
</code></pre>
<p>逆序</p>
<pre><code>sort -r file
</code></pre>
<p>测试一个文件是否已经被排过序</p>
<pre><code>sort -C file
if [ $? -eq 0 ]; then
    echo ssss
fi
</code></pre>
<p>合并两个排过序的文件，并不需要对合并后的文件进行再排序</p>
<pre><code>sort -m sorted1 sorted2
</code></pre>
<p>根据键或者列排序(按照哪一个列)</p>
<pre><code>sort -k 1 data
</code></pre>
<p>限定特定范围内一组字符</p>
<pre><code>key=char4-char8
sort -k 2,3 data

sort -k2.4,5.6 file
第二个字段的第四个字符开始比较，直到第五个字段的第六个字符
</code></pre>
<p>忽略前导空白及字典序排序</p>
<pre><code>sort -bd unsorted.txt
</code></pre>
<p>去重</p>
<pre><code>sort a.txt | uniq
sort -u a.txt
</code></pre>
<h3 id="uniq">uniq<a href="#uniq" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>用法</p>
<pre><code>uniq file
</code></pre>
<p>只显示未重复的记录</p>
<pre><code>uniq -u file
</code></pre>
<p>找出重复的行</p>
<pre><code>uniq -d file
-s 可指定跳过前N个字符
-w 指定用于比较的最大字符数
</code></pre>
<p>统计各行出现的次数</p>
<pre><code>uniq -c file
</code></pre>
<p>p57</p>
<h3 id="tempfile">tempfile<a href="#tempfile" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>只有在基于Debian的发布版才有(Ubuntu/Debian)</p>
<pre><code>temp_file=$(tempfile)
等同
temp_file=&quot;/tmp/file-$RANDOM&quot;

#$$为进程id
temp_file=&quot;/tmp/var.$$&quot;
</code></pre>
<h3 id="split">split<a href="#split" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>按大小分割文件, 单位k(KB), M, G, c(byte), w(word)</p>
<pre><code>split -b 10k data.file
</code></pre>
<p>-d数字后缀，-a后缀长度</p>
<pre><code>split -b 10k data.file -d -a 4
</code></pre>
<p>分割后指定文件名前缀</p>
<pre><code>split -b 10k data.file file_prefix

设置后缀格式
split -b 10k data.file -d -a 4 file_prefix
</code></pre>
<p>根据行数分割</p>
<pre><code>spilt -l 10 data
</code></pre>
<p>其扩展是csplit，可根据文件特性切分，关注</p>
<h3 id="bash变量匹配切分">bash变量匹配切分<a href="#bash变量匹配切分" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>sample.jpg</p>
<pre><code>file_jpg=&quot;sample.jpg&quot;

从右向左匹配
${file_jpg%.*}
#sample

从左向右匹配
${file_jpg#.*}
#jpg

% # 属于非贪婪
%% ## 属于贪婪
</code></pre>
<p>贪婪非贪婪</p>
<pre><code>var=hack.fun.book.txt
${var%.*} #hack.fun.book
${var%%.*} #hack

${var#.*} #fun.book.txt
${var##.*} #txt
</code></pre>
<h3 id="expect">expect<a href="#expect" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>实现自动化</p>
<pre><code>spawn ./ineractive.sh
expect &quot;Enter the number&quot;
send &quot;1\n&quot;
expect &quot;Enter name:&quot;
send &quot;hello\n&quot;
expect eof

spawn指定需要自动化的命令
expect提供需要等待的消息
send发送消息
expect eof指明命令交互结束
</code></pre>
<h3 id="dd">dd<a href="#dd" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>生成任意大小的文件</p>
<pre><code># 创建一个1M大小的文件junk.data
bs=2M count=2 则文件大小4M

dd if=/dev/zero of=junk.data bs=1M count=1
   输入文件     输出文件     块大小   复制块数

块大小单位
字节(1B) c
字(2B)   w
块(512B)   b
千字节(1024B) k
兆字节(1024KB) M
吉字节(1024MB) G
</code></pre>
<h3 id="comm">comm<a href="#comm" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>两个文件之间比较，输出三列</p>
<pre><code>onleA \t onlyB \t bothAB

comm A B -1 -2 #删除第一第二列
-3 删除第三列

可以得到A^B  A-B B-A
</code></pre>
<h3 id="mkdir">mkdir<a href="#mkdir" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>“mkdir”(Make directory)命令在命名路径下创建新的目录。然而如果目录已经存在了，那么它就会返回一个错误信息”不能创建文件夹，文件夹已经存在了”(“cannot create folder, folder already exists”)</p>
<pre><code>mkdir dirpath

mkdir -p dirpath1/dirpath2

#一次多个目录
mkdir -p /home/user/{test,test1,test2}
</code></pre>
<p>注意：目录只能在用户拥有写权限的目录下才能创建</p>
<h3 id="ls">ls<a href="#ls" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>ls命令是列出目录内容(List Directory Contents)的意思。运行它就是列出文件夹里的内容，可能是文件也可能是文件夹</p>
<p>ls文件的内容关系</p>
<pre><code>- 普通文件
d 目录
c 字符设备
b 块设备
l 符号链接
s 套接字
p 管道

文件权限序列
rwx
rwS  setuid(S)，特殊权限, 出现在x的位置, 允许用户以其拥有者的权限来执行文件, 即使这个可执行文件是由其他用户运行的

目录
r,允许读取目录中文件和子目录列表
w,允许在目录中创建或删除文件或目录
x,指明是否可以访问目录中的文件和子目录
rwt/rwT 粘滞位，只有创建该目录的用户才能删除目录中的文件，即使用户组和其他用户也有写权限，典型例子/tmp, 写保护
</code></pre>
<p>查看目录</p>
<pre><code>ls -d */
ls -F | grep &quot;/$&quot;
ls -l | grep &quot;^d&quot;
find . -type d -maxdepth 1 -print
</code></pre>
<p>其他</p>
<pre><code>ls -l    命令已详情模式(long listing fashion)列出文件夹的内容
ls -a    命令会列出文件夹里的所有内容，包括以”.”开头的隐藏文件
</code></pre>
<h3 id="chmod">chmod<a href="#chmod" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>设置文件权限</p>
<p>“chmod”命令就是改变文件的模式位。chmod会根据要求的模式来改变每个所给的文件，文件夹，脚本等等的文件模式（权限）。</p>
<p>设置权限</p>
<pre><code>user group others all
u    g     o      a

chmod u=rwx g=rw o=r filename

chmod u+x filename
chomd a+x filename #所有

chmod a-x filename

chmod 764 filename

#设置粘滞位
chmod a+t dirname

#递归改变

chmod 777 . -R
</code></pre>
<p>注意：对于系统管理员和用户来说，这个命令是最有用的命令之一了。在多用户环境或者服务器上，对于某个用户，如果设置了文件不可访问，那么这个命令就可以解决，如果设置了错误的权限，那么也就提供了为授权的访问。</p>
<h3 id="chown">chown<a href="#chown" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>每个文件都属于一个用户组和一个用户“chown”命令用来改变文件的所有权，所以仅仅用来管理和提供文件的用户和用户组授权。</p>
<p>改变所有权</p>
<pre><code>chown user.group filename
</code></pre>
<p>递归</p>
<pre><code>chown -R user.group .
</code></pre>
<p>每次都以其他用户身份执行(允许其他用户以文件所有者的身份来执行)</p>
<pre><code>chomod +s executable_file

chown root.root executable_file
chmod +s executable_file
./executable_file
</code></pre>
<h3 id="chattr">chattr<a href="#chattr" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>创建不可修改文件</p>
<pre><code>chattr +i file
</code></pre>
<p>一旦被设置为不可修改, 任何用户包括超级用户都不能删除该文件, 除非其不可修改的属性被移除</p>
<pre><code>chattr -i file
</code></pre>
<h3 id="touch">touch<a href="#touch" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>“touch”命令代表了将文件的访问和修改时间更新为当前时间。</p>
<p>touch命令只会在文件不存在的时候才会创建它(空白文件)。如果文件已经存在了，它会更新时间戳，但是并不会改变文件的内容。</p>
<p>空白文件</p>
<pre><code>touch filename

for name {1..100}.txt
do
    touch $name
done
</code></pre>
<p>修改文件访问时间</p>
<pre><code>touch -a &quot;Fri Jun 25 20:50:14 IST 1999&quot; filename
touch -m #修改文件内容的修改时间
</code></pre>
<p>修改文件或目录的时间戳(YYMMDDhhmm)</p>
<pre><code>touch -t 0712250000 file
</code></pre>
<p>注意：touch 可以用来在用户拥有写权限的目录下创建不存在的文件。</p>
<h3 id="ln">ln<a href="#ln" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>建立软连接</p>
<pre><code>ln -s target symbolic_link_name
</code></pre>
<p>如果目的路径已经存在，而没有指定 -f 标志，ln 命令不会创建新的链接，而是向标准错误写一条诊断消息并继续链接剩下的 SourceFiles。</p>
<p>-f 促使 ln 命令替换掉任何已经存在的目的路径</p>
<h3 id="readlink">readlink<a href="#readlink" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>读取链接对应真是路径</p>
<pre><code>readlink web

 readlink ~/.vim
 /Users/ken/github/k-vim
</code></pre>
<h3 id="file">file<a href="#file" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>通过查看文件内容来找出特定类型的文件</p>
<p>打印文件类型信息</p>
<pre><code>file filename
</code></pre>
<p>打印不包含文件名在内</p>
<pre><code>file -b filename
</code></pre>
<p>e.g.</p>
<pre><code>file /etc/passwd
/etc/passwd: ASCII English text

file -b /etc/passwd
ASCII English text
</code></pre>
<h3 id="读文件">读文件<a href="#读文件" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<pre><code>while read line;
do
    something
done &lt; filename
</code></pre>
<h3 id="diff">diff<a href="#diff" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>生成文件差异</p>
<p>非一体化</p>
<pre><code>diff version1.txt version2.txt
</code></pre>
<p>一体化, 可读性更好</p>
<pre><code>diff -u version.txt
</code></pre>
<p>使用patch将命令应用于任意一个文件</p>
<pre><code>diff -u version1.txt version2.txt &gt; version.patch
patch -p1 version1.txt &lt; version.patch
</code></pre>
<p>递归作用于目录</p>
<pre><code>diff -Naur directory1 directory2

-N 所有缺失的文件作为空文件
-a 所有文件视为文本文件
-u 一体化输出
-r 递归遍历
</code></pre>
<h3 id="head">head<a href="#head" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>前10行打印</p>
<pre><code>head file
</code></pre>
<p>前n行</p>
<pre><code>head -n 4 file
</code></pre>
<p>扣除最后N行之外的所有行</p>
<pre><code>head -n -5 file
</code></pre>
<h3 id="tail">tail<a href="#tail" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>最后10行</p>
<pre><code>tail file
</code></pre>
<p>打印最后五行</p>
<pre><code>tail -n 5 file
tail -5 file
</code></pre>
<p>扣除前n行</p>
<pre><code>tail -n +(N+1)
</code></pre>
<p>实时动态打印</p>
<pre><code>tail -f growing_file
</code></pre>
<p>当某个给定进程结束后,  tail随之终结</p>
<pre><code>tail -f file --PID $PID
</code></pre>
<h3 id="pushdpopd">pushd/popd<a href="#pushdpopd" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>将当前路径压入栈</p>
<pre><code>pushd
</code></pre>
<p>压入某个路径</p>
<pre><code>pushd /home/ken
</code></pre>
<p>查看当前路径列表</p>
<pre><code>dirs
</code></pre>
<p>切换到某一个</p>
<pre><code>#dirs从左到右编号 0 -
pushd +3
</code></pre>
<p>移除最近压入栈的路径并切换到下一个目录</p>
<pre><code>popd
</code></pre>
<h3 id="cd">cd<a href="#cd" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>经常使用的“cd”命令代表了改变目录。它在终端中改变工作目录来执行，复制，移动，读，写等等操作</p>
<p>切换到上一目录</p>
<pre><code>cd -
</code></pre>
<p>会到HOME目录</p>
<pre><code>cd
cd ~
</code></pre>
<p>会到上一级目录</p>
<pre><code>cd ..
</code></pre>
<h3 id="wc">wc<a href="#wc" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>Word Count</p>
<p>统计行数</p>
<pre><code>wc -l file
</code></pre>
<p>统计单词数</p>
<pre><code>wc -w file
</code></pre>
<p>统计字符数</p>
<pre><code>wc -c file
</code></pre>
<p>统计所有</p>
<pre><code>wc file
</code></pre>
<p>统计最长行的长度</p>
<pre><code>wc file -L
</code></pre>
<h3 id="tree">tree<a href="#tree" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>以图形化的树状结构打印文件和目录的结构，需要自行安装</p>
<pre><code>tree ~/unixfile
</code></pre>
<p>重点标记出匹配某种样式的文件</p>
<pre><code>tree PATH -P &quot;*.sh&quot;
</code></pre>
<p>只标记符合样式之外的文件</p>
<pre><code>tree path -I PATTERN
</code></pre>
<p>同时打印文件和目录大小</p>
<pre><code>tree -h
</code></pre>
<h3 id="grep">grep<a href="#grep" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>文本搜索工具, 支持正则表达式和通配符</p>
<p>‘grep‘命令搜索指定文件中包含给定字符串或者单词的行</p>
<p>基本用法</p>
<pre><code>grep &quot;match_pattern&quot; file1 file2
</code></pre>
<p>使用颜色重点标记</p>
<pre><code>grep word filename --color=auto
</code></pre>
<p>扩展型使用正则</p>
<pre><code>grep -E &quot;[a-z]+&quot;
egrep &quot;[a-z]+&quot;
</code></pre>
<p>只输出匹配到的文本部分</p>
<pre><code>grep -o word filename
</code></pre>
<p>除匹配行外的所有行</p>
<pre><code>grep -v word filename
</code></pre>
<p>统计匹配行数</p>
<pre><code>grep -c 'text' filename
</code></pre>
<p>打印出包含匹配字符串的行数</p>
<pre><code>grep linux -n filename
</code></pre>
<p>打印样式匹配所位于的字符或字节的偏移</p>
<pre><code>echo &quot;gnu is not unix&quot; | grep -b -o &quot;not&quot;
</code></pre>
<p>搜索多个文件，找出匹配文本位于哪个文件中</p>
<pre><code>grep -l linux file1 file2
取反
grep -L
</code></pre>
<p>递归搜索目录</p>
<pre><code>grep -R &quot;text&quot; dir
</code></pre>
<p>忽略大小写</p>
<pre><code>grep -i &quot;hello&quot; filename
</code></pre>
<p>匹配多个样式</p>
<pre><code>grep -e &quot;pattern1&quot; -e &quot;pattern2&quot; file
</code></pre>
<p>运行匹配脚本</p>
<pre><code>grep -f pattern_file source_file

pattern_file:
hello
cool
</code></pre>
<p>在搜索中包含、排除文件</p>
<pre><code>grep --include *.{c,cpp} word file
</code></pre>
<p>排除</p>
<pre><code>grep --exclude &quot;Readme&quot; filename
--exclude-dir
</code></pre>
<p>静默输出，用于判断(不会产生任何输出)</p>
<pre><code>grep -q word file
if [ $? -eq 0 ]
</code></pre>
<p>打印匹配行之前，之后的行</p>
<pre><code>grep -A 3 之后3行
grep -B 3 之前
grep -C 3 前后
</code></pre>
<p>使用行缓冲</p>
<pre><code>在使用tail -f命令时是可以及时看到文件的变化的，但是如果再加上一个grep命令，可能看到的就不那么及时了，
因为grep命令在buffer写不满时就不输出，可以通过选项  --line-buffered 来搞定，如：

tail -f file.txt | grep something  --line-buffered
</code></pre>
<h3 id="cut">cut<a href="#cut" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>语法</p>
<pre><code>cut -c list [ file ... ]
cut -f list [ -d delim ] [ file ...]

-c list 以字符为主，作剪切操作
-f list 以字段为主，作剪切操作
</code></pre>
<p>提取字段或列</p>
<pre><code>#第一列
cut -f1 filenam

#第二三列
cut -f2,3 filename
</code></pre>
<p>提取补集</p>
<pre><code>cut -f1 --complement filename
</code></pre>
<p>指定字段分隔符</p>
<pre><code>cut -d &quot;;&quot; -f2 filename
cut -d : -f 1,5 /etc/passwd
</code></pre>
<p>指定字符</p>
<pre><code>-b 字节
-c 字符
-f 字段

cut -c1-5 filename
N-
N-M
-M

ls -l | cut -c 1-10
</code></pre>
<p>指定输出分隔符</p>
<pre><code>cut -c1-3,6-9 --output-delimiter &quot;,&quot;
</code></pre>
<h3 id="join">join<a href="#join" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>语法</p>
<pre><code>join [options] file1 file2

选项
-1 field1
-2 field2
-o file.field
-t separator
</code></pre>
<p>例子</p>
<pre><code>join file1 file2
</code></pre>
<h3 id="sed">sed<a href="#sed" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>sed(Stream editor)流编辑器, 可以配合正则使用, 进行替换等</p>
<p>sed替换语法</p>
<pre><code>sed 's/pattern/replace_string/' file
</code></pre>
<p>将结果直接运用于源文件</p>
<pre><code>-i 用于, 直接修改源文件

替换第一个
sed -i 's/pattern/replace_string/' file

替换第二个
sed -i 's/pattern/replace_string/2' file

替换所有
sed -i 's/pattern/replace_string/g' file

从第N处开始替换
sed -i 's/pattern/replcae_string/2g' file
</code></pre>
<p>移除空白行</p>
<pre><code>sed '/^$/d' file
</code></pre>
<p>已匹配字符串标记</p>
<pre><code>引用匹配到的
sed 's/\w\+/[&amp;]/g' filename
</code></pre>
<p>组合多个表达式</p>
<pre><code>sed 'exp1' | sed 'exp2'
等价
sed 'exp1;exp2'
</code></pre>
<p>使用引用</p>
<pre><code>sed &quot;s/$text/HELLO/&quot;
</code></pre>
<p>子串匹配标记(后向引用，最多9个)</p>
<pre><code>sed 's/\([a-z]\+\)' \([A-Z\]\+\)/\2 \1/' filename
</code></pre>
<p>保存到文件</p>
<pre><code>sed 's/pattern/replacement/' -i outfile
</code></pre>
<p>使用其他分隔符</p>
<pre><code>sed 's#/home/#/tmp/#'
</code></pre>
<h3 id="awk">awk<a href="#awk" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>基本结构</p>
<pre><code>awk -F '-' 'BEGIN{statements} {statements} END{statements}' file
表达式中单引号可以换成双引号
BEGIN -&gt; 每一行，执行statements, 执行END
</code></pre>
<p>打印某一列</p>
<pre><code>awk -F '-' '{print $0}' file #全部
awk -F '-' '{print $2}' file #第二列
</code></pre>
<p>print拼接字符</p>
<pre><code>awk '{var=&quot;v1&quot;; var1=&quot;v2&quot;; print var1&quot;-&quot;var2;}'
</code></pre>
<p>特殊变量</p>
<pre><code>NR nuber of records, 记录数
NF number of fields, 字段数
$0 当前行文本
$1 第一字段
$2 第二字段
$NF 最后一个字段

FILENAME 当前输入文件的名称
FNR 当前输入文件记录数
FS 字段分隔字符
OFS 输出字段分隔符，默认&quot; &quot;
ORS 输出记录分隔符，默认&quot;\n&quot;
</code></pre>
<p>统计行数</p>
<pre><code>awk 'END{print NF}'
</code></pre>
<p>将外部变量值传递给awk</p>
<pre><code>awk -v VARIABLE=$VAR '{ print VARIABLE }'
awk '{print v1, v2}' v1=$var1 v2=$var2
</code></pre>
<p>读取行</p>
<pre><code>seq 5 | awk '{ getline var; print var}'
</code></pre>
<p>进行行过滤</p>
<pre><code>awk 'NR&lt;5' #行号小于5
awk 'NR==1,NR==4' #行号在1到5之间
awk '/linux/' #包含样式linux
awk '!/linux/' #不包含
awk '$1 ~/jones/' #第一个字段包含jones

tail file
awk 'NR &lt;= 10' file
</code></pre>
<p>设定分隔符</p>
<pre><code>awk -F: '{ print $NF }' file
</code></pre>
<p>设定输出分隔符</p>
<pre><code>awk -F: -v &quot;OFS=-&quot; '{print $1,$2}' /etc/passwd
</code></pre>
<p>打印空行</p>
<pre><code>awk 'NF&gt;0 {print $0}'
or
awk 'NF&gt;0' #未指定action默认打印
</code></pre>
<p>print和printf</p>
<pre><code>awk -F: '{print &quot;User&quot;, $1, &quot;is really&quot;, $5}' /etc/passwd
awk -F: '{printf &quot;User %s is really %s\n&quot;, $1, $5}' /etc/passwd
</code></pre>
<p>awk中使用循环</p>
<pre><code>for(i=0;i&lt;10;i++) { print $i; }

for(i in array) { print array[i] }
</code></pre>
<p>内建函数</p>
<pre><code>length(str)
index(str,search_str)
split(str,array,delimiter) 用界定符生成一个字符串列表
substr(string, start, end) #子串
sub(regex, replacement_str, str) #正则替换首个匹配位置
gsub(regex, replacement_str, string) #最后一个匹配位置
match(string, regex) #检查是否能够匹配字符串
tolower(string) #转小写
toupper(string) #转大写
</code></pre>
<p>写成脚本文件</p>
<pre><code>BEGIN {}
pattern1 {action1}
pattern2 {action2}
END {}
</code></pre>
<h3 id="文件迭代">文件迭代<a href="#文件迭代" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>读文件行</p>
<pre><code>while read line;
do
    echo $line;
done &lt; file.txt
</code></pre>
<p>迭代每个单词</p>
<pre><code>for word in $line;
do
    echo $word;
done
</code></pre>
<p>迭代每一个字符</p>
<pre><code>for((i=0;i&lt;${#word};i++))
do
    echo ${word:i:1} ;
done
</code></pre>
<h3 id="paste">paste<a href="#paste" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>按列合并文件</p>
<pre><code>paste file1 file2 file3
</code></pre>
<p>指定分隔符</p>
<pre><code>paste file1 file2 -d ','
</code></pre>
<h3 id="tac">tac<a href="#tac" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>逆序打印</p>
<pre><code>tac file1 file2
</code></pre>
<h3 id="rev">rev<a href="#rev" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>接收一个文件或stdin作为输入, 逆序打印每一行内容</p>
<pre><code>echo &quot;abc&quot; | rev
</code></pre>
<h3 id="wget">wget<a href="#wget" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>Wget是用于非交互式（例如后台）下载文件的免费工具.支持HTTP, HTTPS, FTP协议和 HTTP 代理(选项多, 用法灵活)</p>
<p>一个用于文件下载的命令行工具</p>
<pre><code>wget URL1 URL2
</code></pre>
<p>指定保存文件名</p>
<pre><code>wget URL -O local.txt
</code></pre>
<p>指定日志，默认达到stdout</p>
<pre><code>wget URL -O local.txt -o log.txt
</code></pre>
<p>指定重复尝试次数</p>
<pre><code>wget -t 5 URL
</code></pre>
<p>下载限速</p>
<pre><code>wget --limit-rate 20k url
</code></pre>
<p>指定限额</p>
<pre><code>wget -Q 100m url
</code></pre>
<p>断点续传</p>
<pre><code>wget -c URL

$ wget -c -t 100 -T 120 http://www.linux.com/xxxx.data

当文件特别大或者网络特别慢的时候，往往一个文件还没有下载完，连接就已经被切断，此时就需要断点续传。
wget的断点续传是自动的。
-c 选项的作用为断点续传。
-t 参数表示重试次数(例如重试100次，-t 100，如果设成-t 0，表示无穷次重试，直到连接成功)
-T 参数表示超时等待时间，例如-T 120，表示等待120秒连接不上就算超时
</code></pre>
<p>复制或镜像整个网站</p>
<pre><code>wget --mirror exampledomain.com
wget -r -N -l DEPTH URL
     递归，允许对文件使用时间戳，层级
$ wget -r -np -nd http://www.linux.com/packs/

-np 的作用是不遍历父目录
-nd 表示不在本机重新创建目录结构
</code></pre>
<p>访问需要认证的HTTP/FTP</p>
<pre><code>wget --user username --password pass URL
</code></pre>
<p>post请求</p>
<pre><code>wget url -post-data &quot;name=value&quot; -O output.html
</code></pre>
<p>批量下载</p>
<pre><code>wget -i downloads.txt #将文件地址写入一个文件
</code></pre>
<p>用wget命令执行ftp下载</p>
<pre><code>wget -m ftp://username:password@hostname
</code></pre>
<h3 id="curl">curl<a href="#curl" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>基本用法</p>
<pre><code>curl url &gt; index.html
</code></pre>
<p>不显示进度信息</p>
<pre><code>curl URL --slient
</code></pre>
<p>将内容写入文件，而非标准输出</p>
<pre><code>curl URL --slient -O
</code></pre>
<p>写入指定文件</p>
<pre><code>curl URL --slient -o filename
</code></pre>
<p>显示进度条</p>
<pre><code>curl url -o index.html --progress
</code></pre>
<p>断点续传</p>
<pre><code>curl -C - URL
</code></pre>
<p>设置参照页字符串</p>
<pre><code>curl --referer Referer_URL target_URL
跳转到target_URL,其头部referer为Referer_URL
</code></pre>
<p>设置cookie</p>
<pre><code>curl url --cookie &quot;user=slynux;pass=hack&quot;
另存为一个文件

curl URL --cookie-jar cookie_file
</code></pre>
<p>设置用户代理</p>
<pre><code>curl URL --user-agent &quot;Mozilla/5.0&quot;
头部信息
curl -H &quot;Host: www.slynux.org&quot; -H &quot;Accept-language: en&quot; url
</code></pre>
<p>限定下载带宽</p>
<pre><code>curl url --limit-rate 20k
</code></pre>
<p>指定最大下载量(可下载的最大文件大小)</p>
<pre><code>curl url --max-filesize bytes
超出限制的话，返回非0
</code></pre>
<p>进行认证</p>
<pre><code>curl -u user:pass url
</code></pre>
<p>只打印头部信息,不下载远程文件</p>
<pre><code>curl -I url
curl -head url
</code></pre>
<p>发送post请求</p>
<pre><code>curl URL -d &quot;va1=1&amp;va2=2&quot;
         --data
</code></pre>
<h3 id="lynx">lynx<a href="#lynx" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>将网页以ascii字符形式下载</p>
<pre><code>lynx -dump URL &gt; webpage_as_text.txt
</code></pre>
<p>打印出网站的文本板块而非html</p>
<pre><code>lynx -dump url
</code></pre>
<p>生成信息文件</p>
<pre><code>lynx -traversal url
</code></pre>
<h3 id="tar">tar<a href="#tar" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>“tar”命令是磁带归档(Tape Archive)，对创建一些文件的的归档和它们的解压很有用。</p>
<p>将多个文件和文件夹保存成单个文件, 同时还能保留所有的文件属性</p>
<p>对文件进行归档</p>
<pre><code>-c create file,创建文件
-f specify filename,指定文件名

tar -cf output.tar file1 file2 file3
tar -cf output.tar *.txt

tar -cvf output.tar *.txt
</code></pre>
<p>向归档中追加文件</p>
<pre><code>tar -rvf original.tar new_file
-r,追加
</code></pre>
<p>查看过程中更多信息</p>
<pre><code>tar -tvvf archive.tar
-v/-vv, verbose
</code></pre>
<p>提取文件或文件夹</p>
<pre><code>-x, exact
tar -xf archive.tar

-C,指定文件
tar -xf archive.tar -C /path/to/extraction_directory


tar -xvf archive.tar
</code></pre>
<p>提取指定文件</p>
<pre><code>tar -xvf file.tar file1 file4
</code></pre>
<p>拼接两个归档文件</p>
<pre><code>tar -Af file1.tar file2.tar
#file2合并到file1中
</code></pre>
<p>只有在文件内容修改时间更新(newer),才进行添加</p>
<pre><code>tar -uvvf archive.tar filea
</code></pre>
<p>比较归档文件与文件系统中的内容</p>
<pre><code>tar -df archive.tar filename1 filename2
</code></pre>
<p>从归档文件中删除文件</p>
<pre><code>tar -f archive.tar --delete file1 file2
</code></pre>
<p>提取到某个目录</p>
<pre><code> tar zxvf package.tar.gz -C new_dir
</code></pre>
<p>压缩归档文件</p>
<pre><code>gzip/gunzip -&gt; .gz
f.tar.gz   -z
tar -czvf 
tar -xzvf 

bzip/bunzip -&gt; .bz2
f.tar.bz2  -j

f.tar.lzma --lzma
f.tar.lzo
</code></pre>
<p>从归档中排除部分文件</p>
<pre><code>tar -cf arch.tar * --exclude &quot;*.txt&quot;
cat list
   filea
   fileb
tar -cf arch.tar * -X list
</code></pre>
<p>排除版本控制文件</p>
<pre><code>tar --exclude-vcs -czvvf source.tar.gz files
</code></pre>
<p>打印总字节数</p>
<pre><code>tar -cf arc.tar * --exclude &quot;*.txt&quot; --totals
</code></pre>
<h3 id="cpio">cpio<a href="#cpio" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>使用频率不高</p>
<p>归档，保留文件属性（权限、所有权等）</p>
<pre><code>echo file1 file2 | cpio -ov &gt; archive.cpio
-o 指定输出
-v 打印归档文件列表
</code></pre>
<p>列出cpio中的文件内容</p>
<pre><code>cpio -it &lt; archive.cpio
-i指定输入
-t列出归档文件中的内容
</code></pre>
<h3 id="gzip">gzip<a href="#gzip" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>压缩，会删除源文件</p>
<pre><code>gzip filename
#got filename.gz
</code></pre>
<p>解压</p>
<pre><code>gunzip filename.gz
</code></pre>
<p>列出文件属性信息</p>
<pre><code>gzip -l text.gz
</code></pre>
<p>stdin读入文件并写出到stdout</p>
<pre><code>cat file | gzip -c &gt; file.gz
</code></pre>
<p>压缩归档文件</p>
<pre><code>tar -czvvf archive.tar.gz [files]
or
tar -cvvf archive.tar.gz [files]
gzip archive.tar
</code></pre>
<p>指定压缩率</p>
<pre><code>1-9,1最低，但速度最快
gzip -9 test.img
</code></pre>
<h3 id="zcat">zcat<a href="#zcat" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>无需解压缩，直接从.gz中提取内容</p>
<pre><code>zcat test.gz
</code></pre>
<h3 id="bzip">bzip<a href="#bzip" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>更大的压缩率</p>
<pre><code>bzip2 filename
</code></pre>
<p>解压缩</p>
<pre><code>bunzip2 filename.bz2
</code></pre>
<p>stdin到stdout</p>
<pre><code>cat file &gt; bzip2 -c &gt; file.tar.bz2
</code></pre>
<p>压缩归档</p>
<pre><code>tar -cjvvf archive.tar.bz2 [files]
or
tar -cvvf archive.tar [files]
bzip2 archive.tar
</code></pre>
<p>保留输入文件</p>
<pre><code>bunzip2 test.bz2 -k
</code></pre>
<p>压缩率</p>
<pre><code>bzip2 -9 test.img
</code></pre>
<h3 id="lzma">lzma<a href="#lzma" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>比gzip/bzip2更好的压缩率</p>
<p>压缩</p>
<pre><code>lzma filename
</code></pre>
<p>解压</p>
<pre><code>unlzma filename.lzma
</code></pre>
<p>stdin到stdout</p>
<pre><code>cat file | lzma -c &gt; file.lzma
</code></pre>
<p>创建归档</p>
<pre><code>tar -cavvf archive.tar.lzma [files]
    -xavf
</code></pre>
<p>保留输入文件</p>
<pre><code>lzma test.bz2 -k
</code></pre>
<p>压缩率</p>
<pre><code>lzma -9 test.img
</code></pre>
<h3 id="zip">zip<a href="#zip" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>压缩</p>
<pre><code>zip archive_name.zip [source files/dirs]
</code></pre>
<p>对目录和文件进行递归操作</p>
<pre><code>zip -r archive.zip folder1 file2
</code></pre>
<h3 id="base64">base64<a href="#base64" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>编码</p>
<pre><code>base64 filename &gt; outfile
cat file | base64 &gt; outfile
</code></pre>
<p>解码</p>
<pre><code>base64 -d file &gt; outfile
</code></pre>
<h3 id="md5sum-1">md5sum<a href="#md5sum-1" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>“md5sum”就是计算和检验MD5信息签名。
md5 checksum(通常叫做哈希)使用匹配或者验证文件的文件的完整性，因为文件可能因为传输错误，磁盘错误或者无恶意的干扰等原因而发生改变。</p>
<p>单向散列</p>
<pre><code>md5sum file
sha1sum file
</code></pre>
<h3 id="rsync">rsync<a href="#rsync" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>可以对位于不同位置的文件和目录进行备份, 借助差异计算和压缩技术实现最小化数据传输量</p>
<p>要确保远端安装了 openssh</p>
<p>从一个目录复制到另一个目录</p>
<pre><code>rsync -av source_path dest_path
-a 进行归档  -v打印细节
路径可以使本地，也可以是远端路径

e.g.
rsync -av /home/test /home/backups/ #复制到backups目录下
rsync -av /home/test /home/backups  #创建backups目录, 复制
</code></pre>
<p>备份到远程服务器</p>
<pre><code>rsync -av source_path user@host:PATH
可以反向
</code></pre>
<p>改善传输速度</p>
<pre><code>rsync -avz source destination
</code></pre>
<p>排除文件</p>
<pre><code>rsync -avz source dest --exclude &quot;*.txt&quot;
                       --exclude-from FILEPATH
FILEPATH:
*.bak
</code></pre>
<p>更新备份时，删除不存在的文件</p>
<pre><code>rsync -avz source dest --delete
</code></pre>
<h3 id="git">git<a href="#git" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>初始化目录</p>
<pre><code>git init
</code></pre>
<p>配置用户信息</p>
<pre><code>git config --global user.name &quot;wklken&quot;
git config --global user.email &quot;wklken@yeah.net&quot;
</code></pre>
<p>加到远端</p>
<pre><code>git remote add origin user@remotehost:/home/backup/backup.git
git push origin master
</code></pre>
<p>添加</p>
<pre><code>git add *
</code></pre>
<p>删除</p>
<pre><code>git rm *.py
</code></pre>
<p>标记一个检查点</p>
<pre><code>git commit -m &quot;Commit message&quot;
</code></pre>
<p>查看日志</p>
<pre><code>git log
</code></pre>
<p>回滚到某个版本</p>
<pre><code>git checkout hashid [ filename ]
</code></pre>
<p>克隆</p>
<pre><code>git clone url
</code></pre>
<h3 id="dd-1">dd<a href="#dd-1" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>Dtat Definiton, 要注意参数顺序, 错误的参数会损毁所有数据</p>
<p>可以用来转换和复制文件，大多数时间是用来复制iso文件(或任何其它文件)到一个usb设备(或任何其它地方)中去，所以可以用来制作USB启动器</p>
<p>语法说明</p>
<pre><code>dd if=SOURCE of=TARGET bs=BLOCK_SIZE count=COUNT
if/of  输入/输出文件或设备路径
bs块大小
count 限制复制到目标的字节数

dd if=/dev/zero of=/dev/sda1

#制作iso 从cdrom设备读取所有数据, 创建iso文件
dd if=/dev/cdrom of=cdrom.iso
</code></pre>
<p>备份恢复</p>
<pre><code>dd if=/dev/sda1 of=x.img

dd if=x.img of=/dev/sda1
</code></pre>
<h3 id="mount">mount<a href="#mount" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>mount 是一个很重要的命令，用来挂载不能自动挂载的文件系统。你需要root权限挂载设备。
在插入你的文件系统后，</p>
<pre><code>mount --bind /source /destination

首先运行”lsblk”命令，识别出你的设备，然后把分配的设备名记下来。
root@tecmint:~# lsblk
创建一个任何名字的目录，但是最好和引用相关。

root@tecmint:~# su
Password:
root@tecmint:~# cd /dev
root@tecmint:~# mkdir usb
现在将“sdb1”文件系统挂载到“usb”目录.
root@tecmint:~# mount /dev/sdb1 /dev/usb
</code></pre>
<p>挂载镜像</p>
<pre><code>mount -o loop file.img /mnt/mount_point
</code></pre>
<p>##网络相关</p>
<h3 id="ifconfig">ifconfig<a href="#ifconfig" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>显示网络接口、子网掩码等详细信息</p>
<pre><code>ifconfig
/sbin/ifconfig
</code></pre>
<p>打印某个特定网络接口</p>
<pre><code>ifconfig iface_name

e.g.
ifconfig en1

HWaddr     MAC地址
inet addr  ip地址
Bcast      广播地址
Mask       子网掩码
</code></pre>
<p>设置网络接口ip</p>
<pre><code>ifconfig wlan0 192.168.0.80
</code></pre>
<p>dns</p>
<pre><code>cat /etc/resolv.conf

host google.com #Dns查找

nslookup google.com #更详细信息
</code></pre>
<p>修改dns/host</p>
<pre><code>echo nameserver IP_ADDRESS &gt;&gt; /etc/resolv.conf

echo ip domain &gt;&gt; /etc/hosts
</code></pre>
<p>ping</p>
<pre><code>ping www.baidu.com
</code></pre>
<p>路由信息</p>
<pre><code>显示路由表
route

以数字形式显示地址
route -n
</code></pre>
<p>设置默认网关</p>
<pre><code>route add default gw 192.168.0.1 wlan0
</code></pre>
<p>trace_route, 显示分组途径的所有网关的地址</p>
<pre><code>traceroute google.com
</code></pre>
<h3 id="ping">ping<a href="#ping" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>基本</p>
<pre><code>ping ADDRESS  #主机名，域名或ip
</code></pre>
<p>PING命令可以得到RTT(Round Trip Time), 分组从源到目的主机的往返时间, 单位ms</p>
<p>限制发送分组数</p>
<pre><code>ping ADDRESS -c COUNT

ping 
</code></pre>
<h3 id="fping">fping<a href="#fping" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>同时ping一组ip, 而且响应非常快</p>
<pre><code>fping -a ip1 ip2 -g
fping -a 192.160.1/24 -g
fping -a &lt; ip.list

-a, 所有活动主机的ip
-g, 从IP/mask生成的ip地址范围
</code></pre>
<p>进行dns查询</p>
<pre><code>fping -a -d 2 &gt; /dev/null  &lt; ip.list
</code></pre>
<h3 id="lftp">lftp<a href="#lftp" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>基本用法</p>
<pre><code>lftp username@ftphost
cd dir
lcd改变本地主机目录
mkdir 创建目录
get/put 下载上传
quit退出
</code></pre>
<h3 id="scp">scp<a href="#scp" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。</p>
<p>linux的scp命令可以在linux服务器之间复制文件和目录.</p>
<p>拷贝文件</p>
<pre><code>scp filename user@remotehost:/home/pat
ip或主机名均可

scp SOURCE DESTINATION
</code></pre>
<p>递归复制</p>
<pre><code>scp -r dir1 user@remotehost:/home/backup
</code></pre>
<p>提高拷贝速度</p>
<pre><code>scp  -c arcfour -r -P20755 dir/ 192.168.2.*:/**/**/data/
-c arcfour 这个算法没有加校验不保证完整性，注意慎用，内网1000M带宽，默认算法速度只能达到30M/s，用arcfour这个算法速度可以达到50-80M/s
</code></pre>
<h3 id="ssh">SSH<a href="#ssh" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>连接远程</p>
<pre><code>ssh username@remote_host

ssh -p port username@remote_host
</code></pre>
<p>执行命令</p>
<pre><code>ssh username@remote_host 'cmd1; cmd2' &gt; stdout.txt 2&gt;errors.txt
</code></pre>
<p>压缩功能</p>
<pre><code>ssh -C user@hostname 'cmds'
</code></pre>
<p>打通ssh</p>
<pre><code>1.创建SSH密钥
  ssh-keygen -t rsa
  公钥, ~/.ssh/id_rsa.pub
2.登陆远端服务器, 将公钥写入 ~/.ssh/authorized_keys
</code></pre>
<h3 id="lsof">lsof<a href="#lsof" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>列出系统中开放端口及运行在端口上的服务</p>
<pre><code>lsof -i
</code></pre>
<p>配合grep, 获取需要的信息</p>
<h3 id="netstat">netstat<a href="#netstat" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>查看开放端口和服务</p>
<pre><code>netstat -tnp
</code></pre>
<p>##磁盘和系统</p>
<h3 id="du">du<a href="#du" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>du = disk usage</p>
<p>估计文件的空间占用。 逐层统计文件（例如以递归方式）并输出摘要。</p>
<p>查看占用磁盘空间</p>
<pre><code>du FILENAME1 FILENAME2
</code></pre>
<p>查看目录</p>
<pre><code>du -a dir
</code></pre>
<p>以KB,MB或块为单位展示</p>
<pre><code>du -h FILENAME1
</code></pre>
<p>显示总计情况</p>
<pre><code>du -c FILENAME1
</code></pre>
<p>只显示合计</p>
<pre><code>du -s FILENAME1
</code></pre>
<p>以特定单位打印</p>
<pre><code>du -b/-k/-m/-B FILES
</code></pre>
<p>排除部分文件</p>
<pre><code>du --exclude &quot;*.txt&quot; DIR
   --exclude-from EXCLUDE.txt DIR
</code></pre>
<p>指定最深层级</p>
<pre><code>du --max-depth 2 DIR
</code></pre>
<p>指定目录最大的10个文件</p>
<pre><code>du -ak S_DIR | sort -nrk 1 | head
</code></pre>
<h3 id="df">df<a href="#df" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>df = disk free</p>
<p>报告系统的磁盘使用情况。在跟踪磁盘使用情况方面对于普通用户和系统管理员都很有用。 ‘df‘ 通过检查目录大小工作，但这一数值仅当文件关闭时才得到更新。</p>
<p>查看磁盘可用空间</p>
<pre><code>df
df -h
</code></pre>
<h3 id="time">time<a href="#time" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>计算命令执行时间</p>
<pre><code>time COMMAND

real 挂钟时间, 从开始执行到结束的时间
user 进程花费在用户模式中的cpu时间, 真正用于执行进程所花得时间
sys  进程花费在内核模式中的cpu时间
</code></pre>
<p>写入文件</p>
<pre><code>time -o output.txt COMMAND
time -a output.txt COMMAND #追加
</code></pre>
<p>格式化输出</p>
<pre><code>time -f &quot;Time: %U&quot;  -a -o timing.log uname
real %e
user %U
sys %S
</code></pre>
<h3 id="who">who<a href="#who" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>获取当前用户登陆信息</p>
<pre><code>who / w
</code></pre>
<p>当前登陆主机的用户列表</p>
<pre><code>users
</code></pre>
<h3 id="uptime">uptime<a href="#uptime" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>查看系统已经通电运行多长时间了</p>
<pre><code>uptime
#也可以看到负载
</code></pre>
<h3 id="last">last<a href="#last" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>显示上次用户登录信息- 前一次启动会话信息</p>
<pre><code>last
</code></pre>
<p>获取单个用户</p>
<pre><code>last USER
</code></pre>
<h3 id="watch">watch<a href="#watch" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>在终端中以固定间隔监视命令输出</p>
<pre><code>#default 2s
watch ls

# 5s
watch -n 5 ls
</code></pre>
<p>颜色标示</p>
<pre><code>watch -d 'COMMAND'
</code></pre>
<h2 id="进程和线程">进程和线程<a href="#进程和线程" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<h3 id="ps">ps<a href="#ps" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>ps命令给出正在运行的某个进程的状态，每个进程有特定的id成为PID。</p>
<p>ps命令主要查看系统中进程的状态</p>
<pre><code>USER              PID  %CPU %MEM      VSZ    RSS   TT  STAT STARTED      TIME COMMAND
USER表示启动进程用户
PID表示进程标志号

%CPU表示运行该进程占用CPU的时间与该进程总的运行时间的比例
%MEM表示该进程占用内存和总内存的比例。

VSZ表示占用的虚拟内存大小，以KB为单位。
RSS为进程占用的物理内存值，以KB为单位。

TTY表示该进程建立时所对应的终端，&quot;?&quot;表示该进程不占用终端。
STAT表示进程的运行状态，包括以下几种代码：
    D，不可中断的睡眠；
    R，就绪（在可运行队列中）；
    S，睡眠；
    T，被跟踪或停止；
    Z，终止（僵死）的进程，Z不存在，但暂时无法消除；
    W，没有足够的内存分页可分配；&lt;高优先序的进程；
    N，低优先序的进程；
    L，有内存分页分配并锁在内存体内（实时系统或I/O）。

START为进程开始时间。
TIME为执行的时间。
COMMAND是对应的命令名。
</code></pre>
<p>查看进程信息</p>
<pre><code>#当前终端
ps

PID TTY TIME CMD
PID  进程ID
TTY  终端
TIME 进程启动后过去的时间
CMD  进程对应的命令
</code></pre>
<p>显示更多信息</p>
<pre><code>#当前终端
ps -f
</code></pre>
<p>查看所有进程</p>
<pre><code>ps aux
ps -ef
</code></pre>
<p>查看某个用户的所有进程</p>
<pre><code>ps U ken
</code></pre>
<p>命令格式</p>
<pre><code>ps [OTHER OPTIONS] -o par1,par2,par3
ps -eo comm,pcpu | head
pmem 内存使用率，comm可执行文件名,user启动进程的用户,etime启动后度过的时间
</code></pre>
<p>设置升序降序</p>
<pre><code>ps -eo comm,pcpu --sort -pcpu | head
+升序，-降序
</code></pre>
<p>找出给定命令名对应进程ID</p>
<pre><code>ps -C COMMAND_NAME
ps -C bash -o pid=
</code></pre>
<p>进程线程相关</p>
<pre><code>ps -eLf --sort -nlwp | head
</code></pre>
<p>查看子进程树</p>
<pre><code>ps axwef
</code></pre>
<p>注意：当你要知道有哪些进程在运行或者需要知道想杀死的进程PID时ps命令很管用。你可以把它与‘grep‘合用来查询指定的输出结果，例如：</p>
<pre><code># ps -A | grep -i ssh
</code></pre>
<h3 id="pgrep-1">pgrep<a href="#pgrep-1" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>pgrep只需要命令名的一部分, ps需要准确的全名</p>
<p>基本用法</p>
<pre><code>pgrep bash
</code></pre>
<p>指定进程的用户</p>
<pre><code>pgrep -u root,slynux COMMAND
</code></pre>
<p>返回匹配进程数</p>
<pre><code>pgrep -c COMANND
</code></pre>
<h3 id="top">top<a href="#top" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>查看占用cpu最多的进程列表</p>
<pre><code>top
</code></pre>
<h3 id="kill">kill<a href="#kill" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>kill是用来杀死已经无关紧要或者没有响应的进程,杀死一个进程需要知道进程的PID</p>
<p>列出可用信号</p>
<pre><code>kill -l
</code></pre>
<p>终止一个进程</p>
<pre><code>kill PROCESS_ID_LIST
</code></pre>
<p>强杀进程</p>
<pre><code>kill -9 PROCESS_ID
</code></pre>
<p>杀死一组命令</p>
<pre><code>killall process_name
killall -9 process_name

指定用户
killall -u USERNAME process_name
</code></pre>
<h3 id="pkill">pkill<a href="#pkill" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>杀，接受进程名</p>
<pre><code>pkill process_name
pkill -s SIGNAL process_name
</code></pre>
<h3 id="which">which<a href="#which" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>查找PATH下某个命令位置</p>
<pre><code>which ls
</code></pre>
<h3 id="whereis">whereis<a href="#whereis" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>whereis的作用是用来定位命令的二进制文件\资源\或者帮助页.举例来说,获得ls和kill命令的二进制文件/资源以及帮助页:</p>
<pre><code>whereis ls
whereis kill
</code></pre>
<p>类似which，多了命令手册位置，源代码位置</p>
<p>注意:当需要知道二进制文件保存位置时有用.</p>
<h3 id="file-1">file<a href="#file-1" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>确定文件类型</p>
<h3 id="whatis">whatis<a href="#whatis" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>对命令的简短描述</p>
<h3 id="hostname">hostname<a href="#hostname" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>当前主机名</p>
<h3 id="uname">uname<a href="#uname" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<pre><code>主机名
uname -n

#内核版本，硬件架构等
uname -a

#内核发行版本
uname -r

主机类型(32位/64位)
uname -m

cpu相关信息
cat /proc/cpuinfo

内存信息
cat /proc/meminfo
</code></pre>
<p>例子</p>
<pre><code>#uname -a
Linux tecmint 3.8.0-19-generic #30-Ubuntu SMP Wed May 1 16:36:13 UTC 2013 i686 i686 i686 GNU/Linux

1. “Linux“: 机器的内核名
2. “tecmint“: 机器的分支名
3. “3.8.0-19-generic“: 内核发布版本
4. “#30-Ubuntu SMP“: 内核版本
5. “i686“: 处理器架构
6. “GNU/Linux“: 操作系统名
</code></pre>
<h3 id="crontab">crontab<a href="#crontab" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>格式</p>
<pre><code>* * * * * cmd
分钟(0-59)，小时(0-23)，天(1-31)，月份(1-12)，工作日(0-6)

A,B  A and B
*/C  every C
</code></pre>
<p>查看</p>
<pre><code>crontab -l
crontab -l -u slynux
</code></pre>
<p>编辑</p>
<pre><code>crontab -e
</code></pre>
<p>移除</p>
<pre><code>crontab -r
crontab -u slynux -r
</code></pre>
<p>可以在crontab 中加入环境变量</p>
<h3 id="getopts">getopts<a href="#getopts" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>命令行参数处理</p>
<pre><code>while getopts :f:vql opt
do
    case $opt in
    f)  file=$OPTARG
        ;;
    v)  verbose=true
        ;;
    ....
</code></pre>
<h3 id="history">history<a href="#history" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>“history”命令就是历史记录。它显示了在终端中所执行过的所有命令的历史</p>
<pre><code>history
</code></pre>
<p>注意：按住“CTRL + R”就可以搜索已经执行过的命令，它可以你写命令时自动补全</p>
<h3 id="sudo">sudo<a href="#sudo" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>“sudo”(super user do)命令允许授权用户执行超级用户或者其它用户的命令。通过在sudoers列表的安全策略来指定。</p>
<p>注意：sudo 允许用户借用超级用户的权限，然而”su”命令实际上是允许用户以超级用户登录。所以sudo比su更安全。
并不建议使用sudo或者su来处理日常用途，因为它可能导致严重的错误如果你意外的做错了事，这就是为什么在linux社区流行一句话：</p>
<p>“To err is human, but to really foul up everything, you need root password.”
“人非圣贤孰能无过，但是拥有root密码就真的万劫不复了。”</p>
<h3 id="cal">cal<a href="#cal" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>“cal”（Calender），它用来显示当前月份或者未来或者过去任何年份中的月份</p>
<pre><code>cal
cal 02 1835
</code></pre>
<h3 id="cp">cp<a href="#cp" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>“copy”就是复制。它会从一个地方复制一个文件到另外一个地方</p>
<pre><code>cp file1 file2
cp -r dir1 dir2
</code></pre>
<p>快速备份一个文件：</p>
<pre><code>cp some_file_name{,.bkp}
</code></pre>
<p>注意： cp，在shell脚本中是最常用的一个命令，而且它可以使用通配符（在前面一块中有所描述），来定制所需的文件的复制。</p>
<h3 id="mv">mv<a href="#mv" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>“mv”命令将一个地方的文件移动到另外一个地方去。</p>
<p>“mv”命令将一个地方的文件移动到另外一个地方去。</p>
<h3 id="pwd">pwd<a href="#pwd" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>“pwd”（print working directory），在终端中显示当前工作目录的全路径。</p>
<p>注意： 这个命令并不会在脚本中经常使用，但是对于新手，当从连接到nux很久后在终端中迷失了路径，这绝对是救命稻草。</p>
<h3 id="free">free<a href="#free" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<pre><code>free -m
             total       used       free     shared    buffers     cached
Mem:          7982       6811       1171          0        350       5114
-/+ buffers/cache:       1346       6636
Swap:        16935         11      16924
</code></pre>
<p>显示剩余内存</p>
<pre><code>free -m | grep cache | awk '/[0-9]/{ print $4&quot; MB&quot; }'
</code></pre>
<p>在这里例子中,应用程序只使用了1346MB内存,还有6636MB空闲内存可以使用.</p>
<p>一些简单的计算方法：</p>
<p>物理已用内存 = 实际已用内存 - 缓冲 - 缓存 = 6811M - 350M - 5114M</p>
<p>物理空闲内存 = 总物理内存 - 实际已用内存 + 缓冲 + 缓存</p>
<p>应用程序可用空闲内存 = 总物理内存 - 实际已用内存</p>
<p>应用程序已用内存 = 实际已用内存 - 缓冲 - 缓存</p>
<p>原始解释：转至互联网：
Linux的基本原则是没有资源应该被浪费.因此核心会使用尽可能多的RAM,来缓存来自本地和远程的文件系统的信息.系统做读写操作的时候,会将与当前运行的进程相关的数据尽量存储在RAM里.系统报告的缓存是缓冲和页缓存两者之和.缓存并不是在进程结束的时候被回收(你可能很快会启动另外一个进程,需要同样的数据),而是随需回收–比如,当你启动一个需要大量内存的进程时,Linux核心会从内存中回收缓存,将得到的内存分配给新的进程.</p>
<p>有些区域,比如匿名内存映射(mmps)和共享内存区域,它们被报告为缓存,但不是被核心直接释放.一般的缓存不映射到进程的地址空间,仅仅是简单的核心映射,而这些特别的缓存映射到所有挂接到它们上面的进程.</p>
<h3 id="eval">eval<a href="#eval" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<pre><code>eval &quot;ls -l&quot;
</code></pre>
<h3 id="basename">basename<a href="#basename" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>获取路径中文件部分</p>
<pre><code>basename resolv.conf #resolv.conf
basename /etc/resolv.conf # resolv.conf
</code></pre>
<h3 id="cmp">cmp<a href="#cmp" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>比较两个任意类型的文件并将结果输出至标准输出。如果两个文件相同， ‘cmp‘默认返回0；如果不同，将显示不同的字节数和第一处不同的位置。</p>
<pre><code>cmp file1 file2
diff file1 file2
</code></pre>
<h3 id="rm">rm<a href="#rm" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>‘rm’ 标准移除命令。 rm 可以用来删除文件和目录</p>
<pre><code>rm file1
rm -r dir1  #递归删除空目录
</code></pre>
<p>强删</p>
<pre><code>rm -rf fileordir
</code></pre>
<p>警告: ”rm -rf” 命令是一个破坏性的命令,假如你不小心删除一个错误的目录。
一旦你使用’rm -rf’ 删除一个目录,在目录中所有的文件包括目录本身会被永久的删除,所以使用这个命令要非常小心。</p>
<h3 id="service">service<a href="#service" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>‘service‘命令控制服务的启动、停止和重启，它让你能够不重启整个系统就可以让配置生效以开启、停止或者重启某个服务。</p>
<p>注意：要想使用service命令，进程的脚本必须放在‘/etc/init.d‘，并且路径必须在指定的位置。
如果要运行“service apache2 start”实际上实在执行“service /etc/init.d/apache2 start”.</p>
<h3 id="man">man<a href="#man" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>‘man‘是系统帮助页。Man提供命令所有选项及用法的在线文档。几乎所有的命令都有它们的帮助页</p>
<pre><code>man thecommand
</code></pre>
<p>注意：系统帮助页是为了命令的使用和学习而设计的。</p>
<h3 id="passwd">passwd<a href="#passwd" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>这是一个很重要的命令，在终端中用来改变自己密码很有用。显然的，因为安全的原因，你需要知道当前的密码。</p>
<h3 id="gcc">gcc<a href="#gcc" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>gcc 是Linux环境下C语言的内建编译器。下面是一个简单的C程序，在桌面上保存为Hello.c （记住必须要有‘.c‘扩展名</p>
<pre><code>gcc Hello.c
./a.out
gcc -o Hello Hello.c
./Hello
</code></pre>
<p>注意: 编译C程序时，输出会自动保存到一个名为“a.out”的新文件，因此每次编译C程序 “a.out”都会被修改。
因此编译期间最好定义输出文件名.，这样就不会有覆盖输出文件的风险了。</p>
<h3 id="g">g++<a href="#g" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>g++是C++的内建编译器</p>
<pre><code>g++ Add.cpp
./a.out
g++ -o Add Add.cpp
./Add
</code></pre>
<h3 id="java">java<a href="#java" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>Java 是世界上使用最广泛的编程语言之一. 它也被认为是高效, 安全和可靠的编程语言. 现在大多数基于网络的服务都使用Java实现.</p>
<pre><code>javac tecmint.java
java tecmint
</code></pre>
<p>注意: 几乎所有的Linux发行版都带有gcc编译器, 大多数发行版都内建了g++ 和 java 编译器, 有些也可能没有. 你可以用apt 或 yum 安装需要的包.</p>
<h3 id="关于devnull">关于/dev/null<a href="#关于devnull" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>特别有用的特殊文件，位桶，传送到此文件的数据都会被系统丢弃。</p>
<h3 id="语言及乱码">语言及乱码<a href="#语言及乱码" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>查看变量值</p>
<pre><code>echo $LANG   未设置任何LC_XXX时使用的默认值
echo $LC_ALL 覆盖所有LC_XXX变量，总控开关
</code></pre>
<p>好的做法是，避免为任何LC_XXX变量赋值，使用LC_ALL和LANG来控制</p>
<p>避免乱码：从编辑器到语言，再到系统，统一编码为UTF-8</p>
<h3 id="shell的版本">shell的版本<a href="#shell的版本" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<pre><code>bash --version
</code></pre>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://wklken.me/tags/linuxshell">linux,shell</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>14471 Words</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2013-07-04 08:00 &#43;0800</p>
			</footer>
		</article>
		<aside id="toc">
			<div class="toc-title">Table of Contents</div>
			<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#资源">资源</a></li>
        <li><a href="#shell-script">shell script</a></li>
        <li><a href="#run-shell-script">run shell script</a></li>
        <li><a href="#echo">echo</a></li>
        <li><a href="#printf">printf</a></li>
        <li><a href="#环境变量和变量">环境变量和变量</a></li>
        <li><a href="#pgrep">pgrep</a></li>
        <li><a href="#shell数学运算">shell数学运算</a></li>
        <li><a href="#命令状态">命令状态</a></li>
        <li><a href="#文件描述符和重定向">文件描述符和重定向</a></li>
        <li><a href="#cat">cat</a></li>
        <li><a href="#数组和关联数组">数组和关联数组</a></li>
        <li><a href="#alias">alias</a></li>
        <li><a href="#date">date</a></li>
        <li><a href="#调试脚本">调试脚本</a></li>
        <li><a href="#函数和参数">函数和参数</a></li>
        <li><a href="#管道">管道</a></li>
        <li><a href="#读取命令输出">读取命令输出</a></li>
        <li><a href="#read">read</a></li>
        <li><a href="#字段分隔符和迭代器">字段分隔符和迭代器</a></li>
        <li><a href="#循环">循环</a></li>
        <li><a href="#比较和测试">比较和测试</a></li>
        <li><a href="#find">find</a></li>
        <li><a href="#xargs">xargs</a></li>
        <li><a href="#tr">tr</a></li>
        <li><a href="#md5sum">md5sum</a></li>
        <li><a href="#sha1sum">sha1sum</a></li>
        <li><a href="#对目录进行校验">对目录进行校验</a></li>
        <li><a href="#sort">sort</a></li>
        <li><a href="#uniq">uniq</a></li>
        <li><a href="#tempfile">tempfile</a></li>
        <li><a href="#split">split</a></li>
        <li><a href="#bash变量匹配切分">bash变量匹配切分</a></li>
        <li><a href="#expect">expect</a></li>
        <li><a href="#dd">dd</a></li>
        <li><a href="#comm">comm</a></li>
        <li><a href="#mkdir">mkdir</a></li>
        <li><a href="#ls">ls</a></li>
        <li><a href="#chmod">chmod</a></li>
        <li><a href="#chown">chown</a></li>
        <li><a href="#chattr">chattr</a></li>
        <li><a href="#touch">touch</a></li>
        <li><a href="#ln">ln</a></li>
        <li><a href="#readlink">readlink</a></li>
        <li><a href="#file">file</a></li>
        <li><a href="#读文件">读文件</a></li>
        <li><a href="#diff">diff</a></li>
        <li><a href="#head">head</a></li>
        <li><a href="#tail">tail</a></li>
        <li><a href="#pushdpopd">pushd/popd</a></li>
        <li><a href="#cd">cd</a></li>
        <li><a href="#wc">wc</a></li>
        <li><a href="#tree">tree</a></li>
        <li><a href="#grep">grep</a></li>
        <li><a href="#cut">cut</a></li>
        <li><a href="#join">join</a></li>
        <li><a href="#sed">sed</a></li>
        <li><a href="#awk">awk</a></li>
        <li><a href="#文件迭代">文件迭代</a></li>
        <li><a href="#paste">paste</a></li>
        <li><a href="#tac">tac</a></li>
        <li><a href="#rev">rev</a></li>
        <li><a href="#wget">wget</a></li>
        <li><a href="#curl">curl</a></li>
        <li><a href="#lynx">lynx</a></li>
        <li><a href="#tar">tar</a></li>
        <li><a href="#cpio">cpio</a></li>
        <li><a href="#gzip">gzip</a></li>
        <li><a href="#zcat">zcat</a></li>
        <li><a href="#bzip">bzip</a></li>
        <li><a href="#lzma">lzma</a></li>
        <li><a href="#zip">zip</a></li>
        <li><a href="#base64">base64</a></li>
        <li><a href="#md5sum-1">md5sum</a></li>
        <li><a href="#rsync">rsync</a></li>
        <li><a href="#git">git</a></li>
        <li><a href="#dd-1">dd</a></li>
        <li><a href="#mount">mount</a></li>
        <li><a href="#ifconfig">ifconfig</a></li>
        <li><a href="#ping">ping</a></li>
        <li><a href="#fping">fping</a></li>
        <li><a href="#lftp">lftp</a></li>
        <li><a href="#scp">scp</a></li>
        <li><a href="#ssh">SSH</a></li>
        <li><a href="#lsof">lsof</a></li>
        <li><a href="#netstat">netstat</a></li>
        <li><a href="#du">du</a></li>
        <li><a href="#df">df</a></li>
        <li><a href="#time">time</a></li>
        <li><a href="#who">who</a></li>
        <li><a href="#uptime">uptime</a></li>
        <li><a href="#last">last</a></li>
        <li><a href="#watch">watch</a></li>
      </ul>
    </li>
    <li><a href="#进程和线程">进程和线程</a>
      <ul>
        <li><a href="#ps">ps</a></li>
        <li><a href="#pgrep-1">pgrep</a></li>
        <li><a href="#top">top</a></li>
        <li><a href="#kill">kill</a></li>
        <li><a href="#pkill">pkill</a></li>
        <li><a href="#which">which</a></li>
        <li><a href="#whereis">whereis</a></li>
        <li><a href="#file-1">file</a></li>
        <li><a href="#whatis">whatis</a></li>
        <li><a href="#hostname">hostname</a></li>
        <li><a href="#uname">uname</a></li>
        <li><a href="#crontab">crontab</a></li>
        <li><a href="#getopts">getopts</a></li>
        <li><a href="#history">history</a></li>
        <li><a href="#sudo">sudo</a></li>
        <li><a href="#cal">cal</a></li>
        <li><a href="#cp">cp</a></li>
        <li><a href="#mv">mv</a></li>
        <li><a href="#pwd">pwd</a></li>
        <li><a href="#free">free</a></li>
        <li><a href="#eval">eval</a></li>
        <li><a href="#basename">basename</a></li>
        <li><a href="#cmp">cmp</a></li>
        <li><a href="#rm">rm</a></li>
        <li><a href="#service">service</a></li>
        <li><a href="#man">man</a></li>
        <li><a href="#passwd">passwd</a></li>
        <li><a href="#gcc">gcc</a></li>
        <li><a href="#g">g++</a></li>
        <li><a href="#java">java</a></li>
        <li><a href="#关于devnull">关于/dev/null</a></li>
        <li><a href="#语言及乱码">语言及乱码</a></li>
        <li><a href="#shell的版本">shell的版本</a></li>
      </ul>
    </li>
  </ul>
</nav>
		</aside>
		<div class="post-nav thin">
			<a class="next-post" href="https://wklken.me/posts/2013/07/18/python-translate-yield.html">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;Newer</span><br><span>[翻译]Python中yield的解释</span>
			</a>
			<a class="prev-post" href="https://wklken.me/posts/2013/07/04/summary-07-worktwoyear.html">
				<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>工作两周年小结</span>
			</a>
		</div>
		<div id="comments" class="thin">
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="https://wklken.me/js/md5.min.js"></script>
<script>
  const gitalk = new Gitalk({
    clientID: '549d325e74a413f1b56a',
    clientSecret: '086a83faacf152cc3f4079f002058716879e9688',
    repo: 'wklken.github.io',
    owner: 'wklken',
    admin: ['wklken'],
    id: md5(location.pathname), 
    distractionFreeMode: false 
  });
  (function() {
    if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
      document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
      return;
    }
    gitalk.render('gitalk-container');
  })();
</script>

</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2022 <a href="https://wklken.me">wklken</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://wklken.me/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>



	<script src="https://wklken.me/js/bundle.min.580988ed2982bcbb74a1773c7abea97b43e4c43b9324e10cda0813ec6ec4bb67.js" integrity="sha256-WAmI7SmCvLt0oXc8er6pe0PkxDuTJOEM2ggT7G7Eu2c=" crossorigin="anonymous"></script>
	
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-42275748-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


</body>

</html>
