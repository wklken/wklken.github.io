<!DOCTYPE html>
<html lang="en">

<!--[if IE 8]> <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->

<head>
    <meta name="google-site-verification" content="SzE6WCs23qFevgBzRIuG9vcfLU0lW_Vd5hFT-cJOLBE" />
    <title>Linux Shell脚本攻略笔记[速查]</title>
    <meta charset="utf-8" />
    <meta name="description" content="">
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

        <link rel="shortcut icon" href="/favicon.ico"/>
        <link rel="stylesheet" href="/theme/css/styles.css" media="all" />
        <link rel="stylesheet" href="/theme/css/tab.min.css" media="all" />
        <link rel="stylesheet" href="/theme/css/jquery-ui.min.css" media="all" />

        <link rel="stylesheet" href="/theme/css/font-awesome.min.css">
        <!--
        <link rel="stylesheet" href="http://apps.bdimg.com/libs/fontawesome/4.2.0/css/font-awesome.min.css">
        -->
        <!--[if IE 7]>
            <link rel="stylesheet" href="/theme/css/font-awesome-ie7.min.css">
        <![endif]-->

        <link href="/" type="application/atom+xml" rel="alternate" title="wklken's blog ATOM Feed" />
        <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="wklken's blog RSS Feed" />

</head>

<body>
    <div id="page" class="row">
        <div class="large-9 large-centered columns">

        <header id="header">
            <div class="constraint">
                <div class="o">
                    <a href="/"><h1 class="banner">Wklken <span class="blue"> Building </span></h1></a>

                <div class="social">
                            <a href="https://github.com/wklken" target='_blank'><i class="icon-github-sign icon-2x"></i></a>
                            <a href="http://weibo.com/wklken" target='_blank'><i class="icon-weibo icon-2x"></i></a>
                            <a href="mailto:wklken@yeah.net"><i class="icon-envelope icon-2x"></i></a>
                            <a href="http://www.wklken.me/feed.xml" target='_blank'><i class="icon-rss-sign icon-2x"></i></a>
                </div>
                <div class="nav">
                            <a href="/">首页</a>
                            <a href="/categories.html">分类</a>
                            <a href="/archives.html">归档</a>
                            <a href="/pages/projects.html">项目</a>
                            <a href="/pages/aboutme.html">关于</a>

                </div>

                </div>
            </div>
        </header><!-- /#banner -->

        <section id="main">


<article id="article">
    <section id="header">
        <!--
        <div class="meta">2013年07月04日</div>
        <h1 id="title"> Linux Shell脚本攻略笔记[速查] </h1>
        -->
        <div class="meta"> &nbsp; </div>
        <h1> Linux Shell脚本攻略笔记[速查] </h1>
    </section>

        <section id="toc">
            <div id="toc"><ul><li><a class="toc-href" href="#" title="Linux Shell脚本攻略笔记[速查]">Linux Shell脚本攻略笔记[速查]</a><ul><li><a class="toc-href" href="#_1" title="资源">资源</a></li><li><a class="toc-href" href="#shell-script" title="shell script">shell script</a></li><li><a class="toc-href" href="#run-shell-script" title="run shell script">run shell script</a></li><li><a class="toc-href" href="#echo" title="echo">echo</a></li><li><a class="toc-href" href="#printf" title="printf">printf</a></li><li><a class="toc-href" href="#_2" title="环境变量和变量">环境变量和变量</a></li><li><a class="toc-href" href="#pgrep" title="pgrep">pgrep</a></li><li><a class="toc-href" href="#shell" title="shell数学运算">shell数学运算</a></li><li><a class="toc-href" href="#_3" title="命令状态">命令状态</a></li><li><a class="toc-href" href="#_4" title="文件描述符和重定向">文件描述符和重定向</a></li><li><a class="toc-href" href="#cat" title="cat">cat</a></li><li><a class="toc-href" href="#_5" title="数组和关联数组">数组和关联数组</a></li><li><a class="toc-href" href="#alias" title="alias">alias</a></li><li><a class="toc-href" href="#date" title="date">date</a></li><li><a class="toc-href" href="#_6" title="调试脚本">调试脚本</a></li><li><a class="toc-href" href="#_7" title="函数和参数">函数和参数</a></li><li><a class="toc-href" href="#_8" title="管道">管道</a></li><li><a class="toc-href" href="#_9" title="读取命令输出">读取命令输出</a></li><li><a class="toc-href" href="#read" title="read">read</a></li><li><a class="toc-href" href="#_10" title="字段分隔符和迭代器">字段分隔符和迭代器</a></li><li><a class="toc-href" href="#_11" title="循环">循环</a></li><li><a class="toc-href" href="#_12" title="比较和测试">比较和测试</a></li><li><a class="toc-href" href="#find" title="find">find</a></li><li><a class="toc-href" href="#xargs" title="xargs">xargs</a></li><li><a class="toc-href" href="#tr" title="tr">tr</a></li><li><a class="toc-href" href="#md5sum" title="md5sum">md5sum</a></li><li><a class="toc-href" href="#sha1sum" title="sha1sum">sha1sum</a></li><li><a class="toc-href" href="#_13" title="对目录进行校验">对目录进行校验</a></li><li><a class="toc-href" href="#sort" title="sort">sort</a></li><li><a class="toc-href" href="#uniq" title="uniq">uniq</a></li><li><a class="toc-href" href="#tempfile" title="tempfile">tempfile</a></li><li><a class="toc-href" href="#split" title="split">split</a></li><li><a class="toc-href" href="#bash" title="bash变量匹配切分">bash变量匹配切分</a></li><li><a class="toc-href" href="#expect" title="expect">expect</a></li><li><a class="toc-href" href="#dd" title="dd">dd</a></li><li><a class="toc-href" href="#comm" title="comm">comm</a></li><li><a class="toc-href" href="#mkdir" title="mkdir">mkdir</a></li><li><a class="toc-href" href="#ls" title="ls">ls</a></li><li><a class="toc-href" href="#chmod" title="chmod">chmod</a></li><li><a class="toc-href" href="#chown" title="chown">chown</a></li><li><a class="toc-href" href="#chattr" title="chattr">chattr</a></li><li><a class="toc-href" href="#touch" title="touch">touch</a></li><li><a class="toc-href" href="#ln" title="ln">ln</a></li><li><a class="toc-href" href="#readlink" title="readlink">readlink</a></li><li><a class="toc-href" href="#file" title="file">file</a></li><li><a class="toc-href" href="#_14" title="读文件">读文件</a></li><li><a class="toc-href" href="#diff" title="diff">diff</a></li><li><a class="toc-href" href="#head" title="head">head</a></li><li><a class="toc-href" href="#tail" title="tail">tail</a></li><li><a class="toc-href" href="#pushdpopd" title="pushd/popd">pushd/popd</a></li><li><a class="toc-href" href="#cd" title="cd">cd</a></li><li><a class="toc-href" href="#wc" title="wc">wc</a></li><li><a class="toc-href" href="#tree" title="tree">tree</a></li><li><a class="toc-href" href="#grep" title="grep">grep</a></li><li><a class="toc-href" href="#cut" title="cut">cut</a></li><li><a class="toc-href" href="#join" title="join">join</a></li><li><a class="toc-href" href="#sed" title="sed">sed</a></li><li><a class="toc-href" href="#awk" title="awk">awk</a></li><li><a class="toc-href" href="#_15" title="文件迭代">文件迭代</a></li><li><a class="toc-href" href="#paste" title="paste">paste</a></li><li><a class="toc-href" href="#tac" title="tac">tac</a></li><li><a class="toc-href" href="#rev" title="rev">rev</a></li><li><a class="toc-href" href="#wget" title="wget">wget</a></li><li><a class="toc-href" href="#curl" title="curl">curl</a></li><li><a class="toc-href" href="#lynx" title="lynx">lynx</a></li><li><a class="toc-href" href="#tar" title="tar">tar</a></li><li><a class="toc-href" href="#cpio" title="cpio">cpio</a></li><li><a class="toc-href" href="#gzip" title="gzip">gzip</a></li><li><a class="toc-href" href="#zcat" title="zcat">zcat</a></li><li><a class="toc-href" href="#bzip" title="bzip">bzip</a></li><li><a class="toc-href" href="#lzma" title="lzma">lzma</a></li><li><a class="toc-href" href="#zip" title="zip">zip</a></li><li><a class="toc-href" href="#base64" title="base64">base64</a></li><li><a class="toc-href" href="#md5sum_1" title="md5sum">md5sum</a></li><li><a class="toc-href" href="#rsync" title="rsync">rsync</a></li><li><a class="toc-href" href="#git" title="git">git</a></li><li><a class="toc-href" href="#dd_1" title="dd">dd</a></li><li><a class="toc-href" href="#mount" title="mount">mount</a></li><li><a class="toc-href" href="#_17" title="网络相关">网络相关</a><ul><li><a class="toc-href" href="#ifconfig" title="ifconfig">ifconfig</a></li><li><a class="toc-href" href="#ping" title="ping">ping</a></li><li><a class="toc-href" href="#fping" title="fping">fping</a></li><li><a class="toc-href" href="#lftp" title="lftp">lftp</a></li><li><a class="toc-href" href="#scp" title="scp">scp</a></li><li><a class="toc-href" href="#ssh" title="SSH">SSH</a></li><li><a class="toc-href" href="#lsof" title="lsof">lsof</a></li><li><a class="toc-href" href="#netstat" title="netstat">netstat</a></li></ul></li><li><a class="toc-href" href="#_19" title="磁盘和系统">磁盘和系统</a><ul><li><a class="toc-href" href="#du" title="du">du</a></li><li><a class="toc-href" href="#df" title="df">df</a></li><li><a class="toc-href" href="#time" title="time">time</a></li><li><a class="toc-href" href="#who" title="who">who</a></li><li><a class="toc-href" href="#uptime" title="uptime">uptime</a></li><li><a class="toc-href" href="#last" title="last">last</a></li><li><a class="toc-href" href="#watch" title="watch">watch</a></li></ul></li><li><a class="toc-href" href="#_21" title="进程和线程">进程和线程</a><ul><li><a class="toc-href" href="#ps" title="ps">ps</a></li><li><a class="toc-href" href="#pgrep_1" title="pgrep">pgrep</a></li><li><a class="toc-href" href="#top" title="top">top</a></li><li><a class="toc-href" href="#kill" title="kill">kill</a></li><li><a class="toc-href" href="#pkill" title="pkill">pkill</a></li><li><a class="toc-href" href="#which" title="which">which</a></li><li><a class="toc-href" href="#whereis" title="whereis">whereis</a></li><li><a class="toc-href" href="#file_1" title="file">file</a></li><li><a class="toc-href" href="#whatis" title="whatis">whatis</a></li><li><a class="toc-href" href="#hostname" title="hostname">hostname</a></li><li><a class="toc-href" href="#uname" title="uname">uname</a></li><li><a class="toc-href" href="#crontab" title="crontab">crontab</a></li><li><a class="toc-href" href="#getopts" title="getopts">getopts</a></li><li><a class="toc-href" href="#history" title="history">history</a></li><li><a class="toc-href" href="#sudo" title="sudo">sudo</a></li><li><a class="toc-href" href="#cal" title="cal">cal</a></li><li><a class="toc-href" href="#cp" title="cp">cp</a></li><li><a class="toc-href" href="#mv" title="mv">mv</a></li><li><a class="toc-href" href="#pwd" title="pwd">pwd</a></li><li><a class="toc-href" href="#free" title="free">free</a></li><li><a class="toc-href" href="#eval" title="eval">eval</a></li><li><a class="toc-href" href="#basename" title="basename">basename</a></li><li><a class="toc-href" href="#cmp" title="cmp">cmp</a></li><li><a class="toc-href" href="#rm" title="rm">rm</a></li><li><a class="toc-href" href="#service" title="service">service</a></li><li><a class="toc-href" href="#man" title="man">man</a></li><li><a class="toc-href" href="#passwd" title="passwd">passwd</a></li><li><a class="toc-href" href="#gcc" title="gcc">gcc</a></li><li><a class="toc-href" href="#g" title="g++">g++</a></li><li><a class="toc-href" href="#java" title="java">java</a></li><li><a class="toc-href" href="#devnull" title="关于/dev/null">关于/dev/null</a></li><li><a class="toc-href" href="#_22" title="语言及乱码">语言及乱码</a></li><li><a class="toc-href" href="#shell_1" title="shell的版本">shell的版本</a></li></ul></li></ul></li></ul></div>
        </section>
    <section id="content">
        <p>Linux Shell脚本攻略的笔记，markdown编写，可以速查(ctrl+f)</p>
<p>2013-09-08 从历史网摘中补充
 2014-02-16 增加&lt;<shell脚本指南>&gt;笔记补充</shell脚本指南></p>
<hr/>
<h3 id="_1">资源</h3>
<p><a href="http://coolshell.cn/articles/9104.html">sed简明教程</a></p>
<p><a href="http://coolshell.cn/articles/9070.html">awk简明教程</a></p>
<hr/>
<h3 id="shell-script">shell script</h3>
<div class="codehilite"><pre><span class="ch">#!/bin/bash</span>
<span class="c1"># do something</span>
</pre></div>
<h3 id="run-shell-script">run shell script</h3>
<div class="codehilite"><pre>sh script.sh

or

chmod a+x script.sh
./script.sh
# 会读取首行的解释器, 执行
</pre></div>
<p>cmd</p>
<div class="codehilite"><pre>cmd1; cmd2

or

cmd1
cmd2
</pre></div>
<h3 id="echo">echo</h3>
<p>echo  的功能正如其名，就是基于标准输出打印一段文本</p>
<div class="codehilite"><pre>echo "welcome to bash"
echo welcome to bash
</pre></div>
<p>使用不带引号的echo时，无法显示分号</p>
<p>使用单引号echo时，bash不会对单引号中变量求值  '$var'</p>
<p>echo 中转义换行符</p>
<p>默认情况，echo将换行标志追加到文本尾部，可以忽略结尾换行符</p>
<div class="codehilite"><pre>echo -n 'test\n'
</pre></div>
<p>对字符串进行转义</p>
<div class="codehilite"><pre>echo -e '1\t2\t3'
</pre></div>
<p>打印彩色输出</p>
<div class="codehilite"><pre>文字颜色码
    重置0
    黑色30
    红色31
    绿色32
    黄色33
    蓝色34
    洋红35
    青色36
    白色37

echo -e "\e[1;31m This is red test \e[0m"

背景颜色码
    重置0
    黑色40
    红色41
    绿色42
    黄色43
    蓝色44
    洋红45
    青色46
    白色47

echo -e "\e[1;42m Green Background \e[0m"
</pre></div>
<h3 id="printf">printf</h3>
<p>可以格式化字符串, 使用参数同c中printf一样</p>
<div class="codehilite"><pre>printf "hello world"
</pre></div>
<p>默认不会加换行符, 需要手动添加</p>
<div class="codehilite"><pre>printf "%-5s %-10s %-4.2f\n" 3 Jeff 77.564

3    Jeff      77.56
</pre></div>
<h3 id="_2">环境变量和变量</h3>
<p>bash中，每个变量的值都是字符串，无论你给变量赋值时是否使用引号，值都会以字符串的形式存储</p>
<p>环境变量</p>
<p>查看所有与此终端进程相关的环境变量</p>
<div class="codehilite"><pre>env
</pre></div>
<p>查看某个进程的环境变量</p>
<div class="codehilite"><pre><span class="x">cat /proc/</span><span class="p">$</span><span class="nv">PID</span><span class="x">/environ</span>
</pre></div>
<p>变量赋值</p>
<div class="codehilite"><pre>var=value
var='the value'
var="the <span class="nv">$PARAM</span>"

echo <span class="nv">$var</span>
echo <span class="cp">${</span><span class="n">var</span><span class="cp">}</span>

var = value非变量赋值是相等操作
</pre></div>
<p>环境变量</p>
<div class="codehilite"><pre><span class="x">未在当前进程中定义，而是从父进程中继承而来的变量</span>
<span class="x">export 设置环境变量,之后,从当前shell 执行的任何程序都会继承这个变量</span>

<span class="x">export PYTHONPATH=</span><span class="p">$</span><span class="nv">PYTHONPATH</span><span class="x">:/home/ken/workspace</span>
</pre></div>
<p>常用的环境变量</p>
<div class="codehilite"><pre><span class="x">PATH 查找可执行文件路径, 通常定义在/etc/environment or /ect/profile or ~/.bashrc</span>
<span class="x">修改:        export PATH=</span><span class="p">$</span><span class="nv">PATH</span><span class="x">:/new/path/</span>
<span class="x">HOME</span>
<span class="x">PWD</span>
<span class="x">USER</span>
<span class="x">UID</span>
<span class="x">SHELL</span>
</pre></div>
<p>获取字符串长度</p>
<div class="codehilite"><pre>length=<span class="cp">${</span><span class="c1">#var</span><span class="cp">}</span>
</pre></div>
<p>识别当前shell版本</p>
<div class="codehilite"><pre><span class="x">echo </span><span class="p">$</span><span class="nv">SHELL</span><span class="x"></span>
<span class="x">    /bin/bash</span>
<span class="x">echo </span><span class="p">$</span><span class="x">0</span>
<span class="x">    bash</span>
</pre></div>
<p>检查是否为超级用户 or 普通用户</p>
<div class="codehilite"><pre><span class="x">root的UID=0</span>

<span class="x">if [ </span><span class="p">$</span><span class="nv">UID</span><span class="x"> -ne 0 ]</span>
<span class="x">then</span>
<span class="x">    echo "not root user"</span>
<span class="x">else</span>
<span class="x">    echo "root"</span>
<span class="x">fi</span>
</pre></div>
<p>修改bash的提示字符</p>
<div class="codehilite"><pre>设置PS1变量
\u用户名
\h主机名
\w当前工作目录
</pre></div>
<h3 id="pgrep">pgrep</h3>
<p>获取某个进程名对应进程id</p>
<div class="codehilite"><pre>pgrep gedit
</pre></div>
<h3 id="shell">shell数学运算</h3>
<p>整数运算</p>
<p>let</p>
<div class="codehilite"><pre>no1=4
no2=5
let result=no1+no2

let no1++
let no2--
let no1+=7
let no2-=7
</pre></div>
<p>expr(少用)</p>
<div class="codehilite"><pre><span class="x">result=`expr 3 + 4`</span>
<span class="x">result=</span><span class="p">$(</span><span class="err">expr</span> <span class="p">$</span><span class="nv">no1</span> <span class="err">+</span> <span class="m">5</span><span class="p">)</span><span class="x"></span>
</pre></div>
<p>其他方法</p>
<div class="codehilite"><pre><span class="x">result=</span><span class="p">$</span><span class="x">[ no1 + no2 ]</span>
<span class="x">result=</span><span class="p">$</span><span class="x">[ </span><span class="p">$</span><span class="nv">no</span><span class="x"> + 5 ]</span>

<span class="x">result=</span><span class="p">$((</span> <span class="err">no1</span> <span class="err">+</span> <span class="m">5</span> <span class="p">))</span><span class="x"></span>
</pre></div>
<p>浮点数</p>
<div class="codehilite"><pre>echo "4 * 0.56" | bc
设定精度
echo "scale=2;3/8" | bc
进制转换
echo "obase=2;100" | bc
平方
echo "10^10" | bc
平方根
echo "sqrt(100)" | bc
</pre></div>
<h3 id="_3">命令状态</h3>
<p>当命令成功完成, 返回0</p>
<p>发生错误并退回, 返回非0</p>
<p>可以从$?中获取  cmd; echo $?</p>
<h3 id="_4">文件描述符和重定向</h3>
<p>文件描述符: 与文件输入/输出相关联的整数, 用来跟踪已打开的文件</p>
<div class="codehilite"><pre>0 stdin  标砖输入
1 stdout 标准输出
2 stderr 标准错误
</pre></div>
<p>重定向到文件</p>
<div class="codehilite"><pre>清空文件写入新内容
echo "test" &gt; temp.txt
追加
echo "test" &gt;&gt; temp.txt

&gt;等价于1&gt;
&gt;&gt;等价于 1&gt;&gt;
</pre></div>
<p>输出分离或合并</p>
<div class="codehilite"><pre>分离
cmd 2&gt;stderr.txt  1&gt;stdout.txt

合并
cmd &gt; output.txt 2&gt;&amp;1
or
cmd &amp;&gt; output.txt
</pre></div>
<p>扔到垃圾桶</p>
<div class="codehilite"><pre>/dev/null 特殊设备文件, 接收到的任何数据都会被丢弃(位桶/黑洞)

只有标准错误
cmd 2 &gt; /dev/null

标准输出和标准错误
cmd &gt;/dev/null 2&gt;&amp;1
</pre></div>
<p>同时输出到终端和文件</p>
<div class="codehilite"><pre>cmd | tee file1

tee默认覆盖，可以-a选项追加
cmd | tee -a file1
</pre></div>
<p>将stdin作为命令参数</p>
<div class="codehilite"><pre>cmd1 | cmd2 | cmd3 -
</pre></div>
<p>将文件重定向到命令</p>
<div class="codehilite"><pre>cmd &lt; file
</pre></div>
<p>自定义文件描述符</p>
<div class="codehilite"><pre>使用文件描述符3打开并读取文件
exec 3&lt;input.txt
cat &lt;&amp;3

使用文件描述符4进行写入
exec 4&gt;output.txt
echo newline &gt;&amp;4
</pre></div>
<h3 id="cat">cat</h3>
<p>cat, concatenate(拼接)</p>
<p>&ldquo;cat&rdquo;代表了连结（Concatenation），连接两个或者更多文本文件或者以标准输出形式打印文件的内容</p>
<p>一般格式</p>
<div class="codehilite"><pre>cat file1 file2 file3

从管道中读取
OUTPUT_FROM_SOME_CMDS | cat

echo "test" | cat - file1
</pre></div>
<p>压缩空白行, 多个连续空行变成单个</p>
<div class="codehilite"><pre>cat -s  file
</pre></div>
<p>配合tr移除空白行</p>
<div class="codehilite"><pre>cat file | tr -s '\n' #连续多个\n -&gt; \n
</pre></div>
<p>加行号</p>
<div class="codehilite"><pre>cat -n file
</pre></div>
<p>显示制表符等</p>
<div class="codehilite"><pre>cat -T file

cat f &gt; t
注意：&ldquo;&gt;&gt;&rdquo;和&ldquo;&gt;&rdquo;调用了追加符号。它们用来追加到文件里，而不是显示在标准输出上。
&ldquo;&gt;&rdquo;符号会删除已存在的文件，然后创建一个新的文件。
所以因为安全的原因，建议使用&ldquo;&gt;&gt;&rdquo;，它会写入到文件中，而不是覆盖或者删除。
</pre></div>
<p>输入多行文字(CTRL + d 退出)</p>
<div class="codehilite"><pre>cat &gt; test.txt
</pre></div>
<h3 id="_5">数组和关联数组</h3>
<p>普通数组，整数作为数组索引, 借助索引将多个独立的数据存储为一个集合(list)</p>
<p>关联数组，可以使用字符串作为索引(map)</p>
<p>数组</p>
<p>定义</p>
<div class="codehilite"><pre>array_var=(1 2 3 4 5)

or
array_var[0]="test1"
array_var[3]="test3"
</pre></div>
<p>读取</p>
<div class="codehilite"><pre>echo <span class="cp">${</span><span class="n">array_var</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="cp">}</span>
</pre></div>
<p>以清单形式打印</p>
<div class="codehilite"><pre>echo <span class="cp">${</span><span class="n">array_var</span><span class="p">[</span><span class="o">*</span><span class="p">]</span><span class="cp">}</span>
echo <span class="cp">${</span><span class="n">array_var</span><span class="p">[</span><span class="err">@</span><span class="p">]</span><span class="cp">}</span>
</pre></div>
<p>长度</p>
<div class="codehilite"><pre>echo <span class="cp">${</span><span class="c1">#array_var[*]</span><span class="cp">}</span>
</pre></div>
<p>获取索引列表</p>
<div class="codehilite"><pre>echo <span class="cp">${</span><span class="err">!</span><span class="n">array_var</span><span class="p">[</span><span class="o">*</span><span class="p">]</span><span class="cp">}</span>
</pre></div>
<p>关联数组</p>
<div class="codehilite"><pre>declare -A ass_array

内嵌索引-值
ass_array=([index1]=value1 [index2]=value2)

独立
ass_array[index3]=value3

echo <span class="cp">${</span><span class="n">ass_array</span><span class="p">[</span><span class="n">index1</span><span class="p">]</span><span class="cp">}</span>
</pre></div>
<h3 id="alias">alias</h3>
<p>alias是一个系统自建的shell命令，允许你为名字比较长的或者经常使用的命令指定别名。</p>
<div class="codehilite"><pre>alias new_command='command seq'
unalias new_command

使用原生命令
\new_command
</pre></div>
<h3 id="date">date</h3>
<p>&ldquo;date&rdquo;命令使用标准的输出打印当前的日期和时间，也可以深入设置</p>
<p>读取日期</p>
<div class="codehilite"><pre>date
</pre></div>
<p>时间戳</p>
<div class="codehilite"><pre>date +%s
</pre></div>
<p>日期转换为时间戳</p>
<div class="codehilite"><pre>date --date "Thu Nov 18 08:07:21 IST 2010" +%s
</pre></div>
<p>日期格式化</p>
<div class="codehilite"><pre>星期  %a  Sat
      %A  Saturday
月    %b  Nov
      %B  November
日    %d  31
固定日期格式mm/dd/yy     %D
年    %y  10
      %Y  2010
小时  %I/%H    08
分钟  %M  33
秒    %S  10
纳秒  %N  696308515
Unix纪元时  %s
</pre></div>
<p>格式化</p>
<div class="codehilite"><pre>date "+%Y %B %d"

date +%Y-%m-%d
输出： 2011-07-28
date +"%Y-%m-%d %H:%M:%S"
</pre></div>
<p>设置日期和时间</p>
<div class="codehilite"><pre>date -s "格式化日期字符串"

date -s "21 June 2009 11:01:22"
</pre></div>
<p>延时</p>
<div class="codehilite"><pre>sleep number_of_seconds
</pre></div>
<p>两天后及两天前</p>
<div class="codehilite"><pre>date -d '2 days' +%Y%m%d
date -d '2 days ago' +%Y%m%d
</pre></div>
<p>某一天的几天前</p>
<div class="codehilite"><pre><span class="x">TODAY=`date +%Y%m%d`</span>
<span class="x">DAY_1_AGO=`date -d "</span><span class="p">$</span><span class="nv">TODAY</span><span class="x"> 1 days ago" +%Y%m%d`</span>
</pre></div>
<p>时间戳日期转换</p>
<div class="codehilite"><pre><span class="n">date</span> <span class="o">-</span><span class="n">d</span> <span class="mi">@1193144433</span>
<span class="n">date</span> <span class="o">-</span><span class="n">d</span> <span class="mi">@1193144433</span> <span class="s">"+%Y-%m-%d %T"</span>

<span class="err">反向</span><span class="o">:</span>
<span class="n">date</span> <span class="o">-</span><span class="n">d</span> <span class="s">"2007-10-23 15:00:23"</span> <span class="s">"+%s"</span>
</pre></div>
<p>赋值给变量</p>
<div class="codehilite"><pre>DATE=$(date +%Y%m%d)
DATE=`date +%Y%m%d`
</pre></div>
<h3 id="_6">调试脚本</h3>
<p>打印出所执行的每一行命令</p>
<div class="codehilite"><pre>bash -x script.sh
sh -x script.sh
</pre></div>
<p>在脚本中设置开关</p>
<div class="codehilite"><pre>set -x 在执行时显示参数和命令
set +x 关闭调试
set -v 当命令进行读取时显示输入
set +v 禁止打印输入
</pre></div>
<p>直接修改脚本</p>
<div class="codehilite"><pre><span class="ch">#!/bin/bash -xv</span>
</pre></div>
<h3 id="_7">函数和参数</h3>
<p>定义函数</p>
<div class="codehilite"><pre>function fname()
{
    statements;
}
or
fname()
{
    statements;
}
</pre></div>
<p>调用</p>
<div class="codehilite"><pre>fname;
传参
fname arg1 arg2;
</pre></div>
<p>接收参数</p>
<div class="codehilite"><pre><span class="err">$</span><span class="mi">1</span><span class="err">第一个参数</span>
<span class="err">$</span><span class="mi">2</span><span class="err">第二个参数</span>
<span class="err">$</span><span class="n">n第n个参数</span>

<span class="s">"$@"</span><span class="err">被扩展成</span> <span class="s">"$1"</span> <span class="s">"$2"</span> <span class="s">"$3"</span>
<span class="s">"$*"</span><span class="err">扩展成</span><span class="s">"$1c$2c$3"</span><span class="p">,</span> <span class="err">其中</span><span class="n">c是IFS第一个字符</span>

<span class="s">"$@"</span><span class="err">使用最多</span><span class="p">,</span> <span class="err">$</span><span class="o">*</span><span class="err">将所有的参数当做单个字符串</span>
</pre></div>
<p>bash支持递归</p>
<p>导出函数,可以作用到子进程中</p>
<div class="codehilite"><pre>export -f fname
</pre></div>
<p>函数及命令返回值</p>
<div class="codehilite"><pre>cmd;
echo $?

退出状态，成功退出，状态为0，否则，非0

cmd
if [ $? -eq 0 ]
then
    echo "success"
else
    echo "fail"
fi
</pre></div>
<h3 id="_8">管道</h3>
<p>前一个命令的输出作为后一个命令的输入</p>
<div class="codehilite"><pre><span class="p">$</span><span class="nv">cmd1</span><span class="x"> | cmd2 | cmd3</span>
</pre></div>
<h3 id="_9">读取命令输出</h3>
<div class="codehilite"><pre><span class="err">子shell</span>  <span class="err">subshell</span>
<span class="nv">cmd_output</span><span class="o">=</span><span class="k">$(</span>COMMANDS<span class="k">)</span>
<span class="err">or</span>
<span class="err">反引用</span>
<span class="nv">cmd_output</span><span class="o">=</span><span class="sb">`</span>COMMANDS<span class="sb">`</span>
</pre></div>
<p>子shell本身是独立进程, 不会对当前shell有任何影响</p>
<div class="codehilite"><pre>pwd;
(cd /bin; ls)
pwd #同上一个pwd
</pre></div>
<p>保留空格和换行符</p>
<div class="codehilite"><pre><span class="x">out=</span><span class="p">$(</span><span class="err">cat</span> <span class="err">text.txt</span><span class="p">)</span><span class="x"></span>
<span class="x">echo </span><span class="p">$</span><span class="nv">out</span><span class="x">  </span><span class="err">#</span><span class="x">丢失所有换行符</span>

<span class="x">out="</span><span class="p">$(</span><span class="err">cat</span> <span class="err">text.txt</span><span class="p">)</span><span class="x">"</span>
<span class="x">echo </span><span class="p">$</span><span class="nv">out</span><span class="x">  </span><span class="err">#</span><span class="x">保留</span>

<span class="x">cat a</span>
<span class="x">1</span>
<span class="x">2</span>
<span class="x">3</span>
<span class="x">echo </span><span class="p">$(</span><span class="err">cat</span> <span class="err">a</span><span class="p">)</span><span class="x"></span>
<span class="x">1 2 3</span>
<span class="x">echo "</span><span class="p">$(</span><span class="err">cat</span> <span class="err">a</span><span class="p">)</span><span class="x">"</span>
<span class="x">1</span>
<span class="x">2</span>
<span class="x">3</span>
</pre></div>
<h3 id="read">read</h3>
<p>read, 用于从键盘或标准输入中读取文本</p>
<p>读取n个字符存入变量</p>
<div class="codehilite"><pre>read -n number_of_chars variable_name
</pre></div>
<p>不回显的方式读取密码</p>
<div class="codehilite"><pre>read -s var
</pre></div>
<p>显示提示信息</p>
<div class="codehilite"><pre>read -p "Enter input:" var
</pre></div>
<p>限时输入</p>
<div class="codehilite"><pre>read -t  timeout var
</pre></div>
<p>设置界定符</p>
<div class="codehilite"><pre>read -d delim_char var
read -d ":" var
hello:
</pre></div>
<h3 id="_10">字段分隔符和迭代器</h3>
<p>内部字段分隔符，Internal Field Separator, IFS</p>
<p>IFS默认为空白字符（换行符，制表符，空格）</p>
<div class="codehilite"><pre><span class="x">data="name,sex,rollno"</span>
<span class="x">oldIFS=</span><span class="p">$</span><span class="nv">IFS</span><span class="x"></span>
<span class="x">IFS=,</span>
<span class="x">for item in </span><span class="p">$</span><span class="nv">data</span><span class="x"></span>
<span class="x">do</span>
<span class="x">        echo </span><span class="p">$</span><span class="nv">item</span><span class="x"></span>
<span class="x">done</span>

<span class="x">IFS=</span><span class="p">$</span><span class="nv">oldIFS</span><span class="x"></span>
</pre></div>
<h3 id="_11">循环</h3>
<p>for循环</p>
<div class="codehilite"><pre>echo {1..50}

for i in {a..z}; do actions; done;

or

for((i=0;i&lt;10;i++))
{
    commands;
}
</pre></div>
<p>while循环</p>
<div class="codehilite"><pre>while condition
do
    commands;
done
</pre></div>
<p>until循环</p>
<div class="codehilite"><pre>until condition
do
    commands;
done
</pre></div>
<h3 id="_12">比较和测试</h3>
<p>if条件</p>
<div class="codehilite"><pre>if condition;
then
    commands;
elif condition;
then
    commands;
else
    commands;
fi
</pre></div>
<p>逻辑运算符进行简化, 短路运算更简洁</p>
<div class="codehilite"><pre>[ condition ] &amp;&amp; action;
[ condition ] || action;
</pre></div>
<p>算术比较</p>
<div class="codehilite"><pre><span class="x">-gt 大于</span>
<span class="x">-lt 小于</span>
<span class="x">-ge 大于等于</span>
<span class="x">-le 小于等于</span>
<span class="x">-ne 不等于</span>
<span class="x">-eq 等于</span>

<span class="x">注意[]和操作数之间的空格</span>
<span class="x">[ </span><span class="p">$</span><span class="nv">var</span><span class="x"> -eq 0 ]</span>

<span class="x">and</span>
<span class="x">[ </span><span class="p">$</span><span class="nv">var</span><span class="x"> -ne 0 -a </span><span class="p">$</span><span class="nv">var2</span><span class="x"> -ge 2 ]</span>
<span class="x">or</span>
<span class="x">[ </span><span class="p">$</span><span class="nv">var</span><span class="x"> -ne 0 -o </span><span class="p">$</span><span class="nv">var2</span><span class="x"> -ge 2 ]</span>
</pre></div>
<p>文件测试</p>
<div class="codehilite"><pre><span class="x">[ -f </span><span class="p">$</span><span class="nv">file_var</span><span class="x"> ] 正常文件路径或文件名</span>
<span class="x">[ -x </span><span class="p">$</span><span class="nv">var</span><span class="x"> ] 可执行</span>
<span class="x">-d 目录</span>
<span class="x">-e 存在</span>
<span class="x">-c 字符设备文件</span>
<span class="x">-b 块设备文件</span>
<span class="x">-w 可写</span>
<span class="x">-r 可读</span>
<span class="x">-L 符号链接</span>
</pre></div>
<p>字符串比较</p>
<div class="codehilite"><pre><span class="k">[[ $str1 = $str2 ]]</span>
<span class="k">[[ $str1 == $str2 ]]</span>

<span class="na">[[ $str1 !</span><span class="o">=</span> <span class="s">$str2 ]] 不等</span>

<span class="k">[[ $str1 &gt; $str2 ]]</span>
<span class="k">[[ $str1 &lt; $str2 ]]</span>

<span class="err">[[</span> <span class="err">-z</span> <span class="err">$str1</span> <span class="err">]]</span>  <span class="err">空</span>
<span class="err">[[</span> <span class="err">-n</span> <span class="err">$str1</span> <span class="err">]]</span>  <span class="err">非空</span>

<span class="err">if</span> <span class="k">[[ -n $str1 ]] &amp;&amp; [[ -z $str2 ]]</span>
<span class="err">then</span>
    <span class="err">commands</span><span class="c1">;</span>
<span class="err">fi</span>
</pre></div>
<h3 id="find">find</h3>
<p>搜索指定目录下的文件，从开始于父目录，然后搜索子目录</p>
<p>基本</p>
<div class="codehilite"><pre>find base_path

# 打印文件和目录列表
find . -print  #默认\n分割文件名
</pre></div>
<p>文件名</p>
<div class="codehilite"><pre>find path -name "*.txt" -print
          -iname  忽略大小写

多个条件 or
find . \( -name "*.txt" -o -name "*.py" \)
</pre></div>
<p>文件路径</p>
<div class="codehilite"><pre>通配符
find /home/users -path "*slynux*" -print

正则
find . -regex ".*\(\.py\|\.sh\)$"
       -iregex 忽略大小写
</pre></div>
<p>否定参数</p>
<div class="codehilite"><pre>find . ! -name "*.txt" -print
</pre></div>
<p>根据文件类型</p>
<div class="codehilite"><pre>find . -type d -print
f 普通文件
l 符号链接
d 目录
c 字符设备
b 块设备
s 套接字
p Fifo
</pre></div>
<p>设定目录深度</p>
<div class="codehilite"><pre>find . -maxdepth 1 -type f -print
find . -mindepth 2 -type f -print
</pre></div>
<p>根据文件时间搜索</p>
<div class="codehilite"><pre>计量单位 天
-atime 最近一次访问时间
-mtime 最后一次被修改时间
-ctime 文件元数据，最近一次修改时间

find . -type f -atime -7 -print #最近七天内被访问的
find . -type f -atime 7 -print  #恰好在七天前
                      +7 -print #超过七天

计量单位 分钟
-amin 访问时间
-mmin 修改时间
-cmin 变化时间

find . -type f -amin +7 -print #访问时间超过7分钟的

find . -type f -newer file.txt -print  #用于比较时间戳的参考文件，比参考文件更新的文件
</pre></div>
<p>基于文件大小的搜索</p>
<div class="codehilite"><pre>find . -type f -size +2k
+ 大于  -小于   无符号，恰好等于

b 块
c 字节
w 字（2字节）
k 千字节
M 兆字节
G 吉字节
</pre></div>
<p>删除匹配的文件</p>
<div class="codehilite"><pre>find . -type f -name "*.swp" -delete
#注意：-delete位置一定是最后
</pre></div>
<p>文件权限及所有权</p>
<div class="codehilite"><pre>find . -type f -perm 644 -print

find . -type f -user slynux -print
</pre></div>
<p>执行命令或动作(最强大的命令)</p>
<div class="codehilite"><pre>find . -type f -user root -exec chown slynux {} \;
find . -type f -exec cp {} OLD \;
find . -iname "abc.txt" -exec md5sum {} \;

{} 江北替换成对应文件名
exec无法结合多个命令，可以将多个命令放入脚本，调用之
</pre></div>
<p>跳过指定目录</p>
<div class="codehilite"><pre>find . \( -name ".git" -prune \) -name '*.txt'
</pre></div>
<h3 id="xargs">xargs</h3>
<p>将标准输入数据转化成命令行参数</p>
<p>将stdin接收到的数据重新格式化，再将其作为参数传给其他命令</p>
<p>多行输入转化成单行输出</p>
<div class="codehilite"><pre>cat  example.txt | xargs  #空格替换掉\n
</pre></div>
<p>切成多行，每行n个参数</p>
<div class="codehilite"><pre>cat examplet.txt | xargs -n 3
</pre></div>
<p>可以指定分隔符</p>
<div class="codehilite"><pre>echo "aaaXbbbXccc" | xargs -d 'X'
</pre></div>
<p>将参数传递给脚本(类似循环)</p>
<div class="codehilite"><pre>cat args.txt | xargs -n 1 ./cecho.sh

./cecho.sh -p arg1 1
需要变更
cat args.txt | xargs -I {} ./cecho.sh -p {} 1
</pre></div>
<p>find与xargs组合</p>
<div class="codehilite"><pre>find . -type f -name "*.txt" -print | xargs rm -rf
</pre></div>
<p>其他</p>
<div class="codehilite"><pre><span class="x">cat file | ( while read arg; do cat </span><span class="p">$</span><span class="nv">arg</span><span class="x">; done )</span>
<span class="x">cat file | xargs -I </span><span class="err">{</span><span class="x">} cat </span><span class="err">{</span><span class="x">}</span>
</pre></div>
<h3 id="tr">tr</h3>
<p>tr可以对来自标准输入的字符进行替换，删除以及压缩(translate, 可以将一组字符变成另一组字符)</p>
<p>tr只能通过stdin，无法通过其他命令行进行接收参数</p>
<p>格式</p>
<div class="codehilite"><pre>tr [options] source-char-set replace-char-set
</pre></div>
<p>选项</p>
<div class="codehilite"><pre>-c 取source-char-set补集，通常与-d/-s配合
-d 删除字source-char-set中的所列的字符
-s 浓缩重复字符，连续多个变成一个
</pre></div>
<p>字符替换</p>
<div class="codehilite"><pre>cat /proc/12501/environ | tr '\0' '\n'
</pre></div>
<p>大小写替换</p>
<div class="codehilite"><pre>echo  "HELLO" | tr 'A-Z' 'a-z'
cat text | tr '\t' ' '
</pre></div>
<p>删除字符</p>
<div class="codehilite"><pre>echo "hello 123 world 456"| tr -d '0-9'
hello  world
</pre></div>
<p>字符集补集</p>
<div class="codehilite"><pre>echo "hello 1 char 2" | tr -d -c '0-9'  #删除非0-9
12
</pre></div>
<p>压缩字符</p>
<p>连续的重复字符</p>
<div class="codehilite"><pre>echo "GNU is    not UNix" | tr -s ' '
</pre></div>
<p>字符类</p>
<div class="codehilite"><pre>alnum 字母和数字
alpha 字母
cntrl 控制字符
digit 数字
graph 图形字符
lower 小写字母
print 可打印字符
punct 标点符号
space 空白字符
upper 大写字母
xdigit 十六进制字符

tr '[:lower:]' '[:upper:]'
</pre></div>
<h3 id="md5sum">md5sum</h3>
<p>32个字符的十六进制串</p>
<div class="codehilite"><pre>md5sum filename
md5sum filename1 filename2
</pre></div>
<h3 id="sha1sum">sha1sum</h3>
<p>40个字符十六进制串</p>
<div class="codehilite"><pre>sha1sum file
</pre></div>
<h3 id="_13">对目录进行校验</h3>
<p>需安装md5deep软件包</p>
<div class="codehilite"><pre>md5deep/sha1deep
md5deep -rl dirname
         r递归，l相对路径
</pre></div>
<h3 id="sort">sort</h3>
<p>语法</p>
<div class="codehilite"><pre>sort [options] [file(s)]

-c 检查是否已排序
-u 丢弃所有具有相同键值的记录

-b 忽略开头空白
-d 字典序
-g 一般数值，以浮点数类型比较字段，仅支持gnu
-i 忽略无法打印的字符

-k 定义排序键值字段
-n 以整数类型比较字段
-r 倒转
-o 输出到指定文件
</pre></div>
<p>排序</p>
<div class="codehilite"><pre>sort file1 &gt; file1.sorted
sort -o file1.sored file1
</pre></div>
<p>按数字, 要明确</p>
<div class="codehilite"><pre>sort -n file1
</pre></div>
<p>逆序</p>
<div class="codehilite"><pre>sort -r file
</pre></div>
<p>测试一个文件是否已经被排过序</p>
<div class="codehilite"><pre>sort -C file
if [ $? -eq 0 ]; then
    echo ssss
fi
</pre></div>
<p>合并两个排过序的文件，并不需要对合并后的文件进行再排序</p>
<div class="codehilite"><pre>sort -m sorted1 sorted2
</pre></div>
<p>根据键或者列排序(按照哪一个列)</p>
<div class="codehilite"><pre>sort -k 1 data
</pre></div>
<p>限定特定范围内一组字符</p>
<div class="codehilite"><pre>key=char4-char8
sort -k 2,3 data

sort -k2.4,5.6 file
第二个字段的第四个字符开始比较，直到第五个字段的第六个字符
</pre></div>
<p>忽略前导空白及字典序排序</p>
<div class="codehilite"><pre>sort -bd unsorted.txt
</pre></div>
<p>去重</p>
<div class="codehilite"><pre>sort a.txt | uniq
sort -u a.txt
</pre></div>
<h3 id="uniq">uniq</h3>
<p>用法</p>
<div class="codehilite"><pre>uniq file
</pre></div>
<p>只显示未重复的记录</p>
<div class="codehilite"><pre>uniq -u file
</pre></div>
<p>找出重复的行</p>
<div class="codehilite"><pre>uniq -d file
-s 可指定跳过前N个字符
-w 指定用于比较的最大字符数
</pre></div>
<p>统计各行出现的次数</p>
<div class="codehilite"><pre>uniq -c file
</pre></div>
<p>p57</p>
<h3 id="tempfile">tempfile</h3>
<p>只有在基于Debian的发布版才有(Ubuntu/Debian)</p>
<div class="codehilite"><pre><span class="x">temp_file=</span><span class="p">$(</span><span class="err">tempfile</span><span class="p">)</span><span class="x"></span>
<span class="x">等同</span>
<span class="x">temp_file="/tmp/file-</span><span class="p">$</span><span class="nv">RANDOM</span><span class="x">"</span>

<span class="err">#</span><span class="p">$$</span><span class="x">为进程id</span>
<span class="x">temp_file="/tmp/var.</span><span class="p">$$</span><span class="x">"</span>
</pre></div>
<h3 id="split">split</h3>
<p>按大小分割文件, 单位k(KB), M, G, c(byte), w(word)</p>
<div class="codehilite"><pre>split -b 10k data.file
</pre></div>
<p>-d数字后缀，-a后缀长度</p>
<div class="codehilite"><pre>split -b 10k data.file -d -a 4
</pre></div>
<p>分割后指定文件名前缀</p>
<div class="codehilite"><pre>split -b 10k data.file file_prefix

设置后缀格式
split -b 10k data.file -d -a 4 file_prefix
</pre></div>
<p>根据行数分割</p>
<div class="codehilite"><pre>spilt -l 10 data
</pre></div>
<p>其扩展是csplit，可根据文件特性切分，关注</p>
<h3 id="bash">bash变量匹配切分</h3>
<p>sample.jpg</p>
<div class="codehilite"><pre>file_jpg="sample.jpg"

从右向左匹配
<span class="cp">${</span><span class="n">file_jpg</span><span class="o">%.*</span><span class="cp">}</span>
#sample

从左向右匹配
<span class="cp">${</span><span class="n">file_jpg</span><span class="c1">#.*</span><span class="cp">}</span>
#jpg

% # 属于非贪婪
%% ## 属于贪婪
</pre></div>
<p>贪婪非贪婪</p>
<div class="codehilite"><pre>var=hack.fun.book.txt
<span class="cp">${</span><span class="n">var</span><span class="o">%.*</span><span class="cp">}</span> #hack.fun.book
<span class="cp">${</span><span class="n">var</span><span class="o">%%.*</span><span class="cp">}</span> #hack

<span class="cp">${</span><span class="n">var</span><span class="c1">#.*</span><span class="cp">}</span> #fun.book.txt
<span class="cp">${</span><span class="n">var</span><span class="c1">##.*</span><span class="cp">}</span> #txt
</pre></div>
<h3 id="expect">expect</h3>
<p>实现自动化</p>
<div class="codehilite"><pre>spawn ./ineractive.sh
expect "Enter the number"
send "1\n"
expect "Enter name:"
send "hello\n"
expect eof

spawn指定需要自动化的命令
expect提供需要等待的消息
send发送消息
expect eof指明命令交互结束
</pre></div>
<h3 id="dd">dd</h3>
<p>生成任意大小的文件</p>
<div class="codehilite"><pre># 创建一个1M大小的文件junk.data
bs=2M count=2 则文件大小4M

dd if=/dev/zero of=junk.data bs=1M count=1
   输入文件     输出文件     块大小   复制块数

块大小单位
字节(1B) c
字(2B)   w
块(512B)   b
千字节(1024B) k
兆字节(1024KB) M
吉字节(1024MB) G
</pre></div>
<h3 id="comm">comm</h3>
<p>两个文件之间比较，输出三列</p>
<div class="codehilite"><pre>onleA \t onlyB \t bothAB

comm A B -1 -2 #删除第一第二列
-3 删除第三列

可以得到A^B  A-B B-A
</pre></div>
<h3 id="mkdir">mkdir</h3>
<p>&ldquo;mkdir&rdquo;(Make directory)命令在命名路径下创建新的目录。然而如果目录已经存在了，那么它就会返回一个错误信息&rdquo;不能创建文件夹，文件夹已经存在了&rdquo;(&ldquo;cannot create folder, folder already exists&rdquo;)</p>
<div class="codehilite"><pre>mkdir dirpath

mkdir -p dirpath1/dirpath2

#一次多个目录
mkdir -p /home/user/{test,test1,test2}
</pre></div>
<p>注意：目录只能在用户拥有写权限的目录下才能创建</p>
<h3 id="ls">ls</h3>
<p>ls命令是列出目录内容(List Directory Contents)的意思。运行它就是列出文件夹里的内容，可能是文件也可能是文件夹</p>
<p>ls文件的内容关系</p>
<div class="codehilite"><pre>- 普通文件
d 目录
c 字符设备
b 块设备
l 符号链接
s 套接字
p 管道

文件权限序列
rwx
rwS  setuid(S)，特殊权限, 出现在x的位置, 允许用户以其拥有者的权限来执行文件, 即使这个可执行文件是由其他用户运行的

目录
r,允许读取目录中文件和子目录列表
w,允许在目录中创建或删除文件或目录
x,指明是否可以访问目录中的文件和子目录
rwt/rwT 粘滞位，只有创建该目录的用户才能删除目录中的文件，即使用户组和其他用户也有写权限，典型例子/tmp, 写保护
</pre></div>
<p>查看目录</p>
<div class="codehilite"><pre>ls -d */
ls -F | grep "/$"
ls -l | grep "^d"
find . -type d -maxdepth 1 -print
</pre></div>
<p>其他</p>
<div class="codehilite"><pre>ls -l    命令已详情模式(long listing fashion)列出文件夹的内容
ls -a    命令会列出文件夹里的所有内容，包括以&rdquo;.&rdquo;开头的隐藏文件
</pre></div>
<h3 id="chmod">chmod</h3>
<p>设置文件权限</p>
<p>&ldquo;chmod&rdquo;命令就是改变文件的模式位。chmod会根据要求的模式来改变每个所给的文件，文件夹，脚本等等的文件模式（权限）。</p>
<p>设置权限</p>
<div class="codehilite"><pre>user group others all
u    g     o      a

chmod u=rwx g=rw o=r filename

chmod u+x filename
chomd a+x filename #所有

chmod a-x filename

chmod 764 filename

#设置粘滞位
chmod a+t dirname

#递归改变

chmod 777 . -R
</pre></div>
<p>注意：对于系统管理员和用户来说，这个命令是最有用的命令之一了。在多用户环境或者服务器上，对于某个用户，如果设置了文件不可访问，那么这个命令就可以解决，如果设置了错误的权限，那么也就提供了为授权的访问。</p>
<h3 id="chown">chown</h3>
<p>每个文件都属于一个用户组和一个用户&ldquo;chown&rdquo;命令用来改变文件的所有权，所以仅仅用来管理和提供文件的用户和用户组授权。</p>
<p>改变所有权</p>
<div class="codehilite"><pre>chown user.group filename
</pre></div>
<p>递归</p>
<div class="codehilite"><pre>chown -R user.group .
</pre></div>
<p>每次都以其他用户身份执行(允许其他用户以文件所有者的身份来执行)</p>
<div class="codehilite"><pre>chomod +s executable_file

chown root.root executable_file
chmod +s executable_file
./executable_file
</pre></div>
<h3 id="chattr">chattr</h3>
<p>创建不可修改文件</p>
<div class="codehilite"><pre>chattr +i file
</pre></div>
<p>一旦被设置为不可修改, 任何用户包括超级用户都不能删除该文件, 除非其不可修改的属性被移除</p>
<div class="codehilite"><pre>chattr -i file
</pre></div>
<h3 id="touch">touch</h3>
<p>&ldquo;touch&rdquo;命令代表了将文件的访问和修改时间更新为当前时间。</p>
<p>touch命令只会在文件不存在的时候才会创建它(空白文件)。如果文件已经存在了，它会更新时间戳，但是并不会改变文件的内容。</p>
<p>空白文件</p>
<div class="codehilite"><pre><span class="x">touch filename</span>

<span class="x">for name </span><span class="err">{</span><span class="x">1..100}.txt</span>
<span class="x">do</span>
<span class="x">    touch </span><span class="p">$</span><span class="nv">name</span><span class="x"></span>
<span class="x">done</span>
</pre></div>
<p>修改文件访问时间</p>
<div class="codehilite"><pre>touch -a "Fri Jun 25 20:50:14 IST 1999" filename
touch -m #修改文件内容的修改时间
</pre></div>
<p>修改文件或目录的时间戳(YYMMDDhhmm)</p>
<div class="codehilite"><pre>touch -t 0712250000 file
</pre></div>
<p>注意：touch 可以用来在用户拥有写权限的目录下创建不存在的文件。</p>
<h3 id="ln">ln</h3>
<p>建立软连接</p>
<div class="codehilite"><pre>ln -s target symbolic_link_name
</pre></div>
<p>如果目的路径已经存在，而没有指定 -f 标志，ln 命令不会创建新的链接，而是向标准错误写一条诊断消息并继续链接剩下的 SourceFiles。</p>
<p>-f 促使 ln 命令替换掉任何已经存在的目的路径</p>
<h3 id="readlink">readlink</h3>
<p>读取链接对应真是路径</p>
<div class="codehilite"><pre>readlink web

 readlink ~/.vim
 /Users/ken/github/k-vim
</pre></div>
<h3 id="file">file</h3>
<p>通过查看文件内容来找出特定类型的文件</p>
<p>打印文件类型信息</p>
<div class="codehilite"><pre>file filename
</pre></div>
<p>打印不包含文件名在内</p>
<div class="codehilite"><pre>file -b filename
</pre></div>
<p>e.g.</p>
<div class="codehilite"><pre>file /etc/passwd
/etc/passwd: ASCII English text

file -b /etc/passwd
ASCII English text
</pre></div>
<h3 id="_14">读文件</h3>
<div class="codehilite"><pre>while read line;
do
    something
done &lt; filename
</pre></div>
<h3 id="diff">diff</h3>
<p>生成文件差异</p>
<p>非一体化</p>
<div class="codehilite"><pre><span class="gh">diff version1.txt version2.txt</span>
</pre></div>
<p>一体化, 可读性更好</p>
<div class="codehilite"><pre><span class="gh">diff -u version.txt</span>
</pre></div>
<p>使用patch将命令应用于任意一个文件</p>
<div class="codehilite"><pre><span class="gh">diff -u version1.txt version2.txt &gt; version.patch</span>
patch -p1 version1.txt &lt; version.patch
</pre></div>
<p>递归作用于目录</p>
<div class="codehilite"><pre><span class="gh">diff -Naur directory1 directory2</span>

<span class="gd">-N 所有缺失的文件作为空文件</span>
<span class="gd">-a 所有文件视为文本文件</span>
<span class="gd">-u 一体化输出</span>
<span class="gd">-r 递归遍历</span>
</pre></div>
<h3 id="head">head</h3>
<p>前10行打印</p>
<div class="codehilite"><pre>head file
</pre></div>
<p>前n行</p>
<div class="codehilite"><pre>head -n 4 file
</pre></div>
<p>扣除最后N行之外的所有行</p>
<div class="codehilite"><pre>head -n -5 file
</pre></div>
<h3 id="tail">tail</h3>
<p>最后10行</p>
<div class="codehilite"><pre>tail file
</pre></div>
<p>打印最后五行</p>
<div class="codehilite"><pre>tail -n 5 file
tail -5 file
</pre></div>
<p>扣除前n行</p>
<div class="codehilite"><pre>tail -n +(N+1)
</pre></div>
<p>实时动态打印</p>
<div class="codehilite"><pre>tail -f growing_file
</pre></div>
<p>当某个给定进程结束后,  tail随之终结</p>
<div class="codehilite"><pre><span class="x">tail -f file --PID </span><span class="p">$</span><span class="nv">PID</span><span class="x"></span>
</pre></div>
<h3 id="pushdpopd">pushd/popd</h3>
<p>将当前路径压入栈</p>
<div class="codehilite"><pre>pushd
</pre></div>
<p>压入某个路径</p>
<div class="codehilite"><pre>pushd /home/ken
</pre></div>
<p>查看当前路径列表</p>
<div class="codehilite"><pre>dirs
</pre></div>
<p>切换到某一个</p>
<div class="codehilite"><pre>#dirs从左到右编号 0 -
pushd +3
</pre></div>
<p>移除最近压入栈的路径并切换到下一个目录</p>
<div class="codehilite"><pre>popd
</pre></div>
<h3 id="cd">cd</h3>
<p>经常使用的&ldquo;cd&rdquo;命令代表了改变目录。它在终端中改变工作目录来执行，复制，移动，读，写等等操作</p>
<p>切换到上一目录</p>
<div class="codehilite"><pre>cd -
</pre></div>
<p>会到HOME目录</p>
<div class="codehilite"><pre>cd
cd ~
</pre></div>
<p>会到上一级目录</p>
<div class="codehilite"><pre>cd ..
</pre></div>
<h3 id="wc">wc</h3>
<p>Word Count</p>
<p>统计行数</p>
<div class="codehilite"><pre>wc -l file
</pre></div>
<p>统计单词数</p>
<div class="codehilite"><pre>wc -w file
</pre></div>
<p>统计字符数</p>
<div class="codehilite"><pre>wc -c file
</pre></div>
<p>统计所有</p>
<div class="codehilite"><pre>wc file
</pre></div>
<p>统计最长行的长度</p>
<div class="codehilite"><pre>wc file -L
</pre></div>
<h3 id="tree">tree</h3>
<p>以图形化的树状结构打印文件和目录的结构，需要自行安装</p>
<div class="codehilite"><pre>tree ~/unixfile
</pre></div>
<p>重点标记出匹配某种样式的文件</p>
<div class="codehilite"><pre>tree PATH -P "*.sh"
</pre></div>
<p>只标记符合样式之外的文件</p>
<div class="codehilite"><pre>tree path -I PATTERN
</pre></div>
<p>同时打印文件和目录大小</p>
<div class="codehilite"><pre>tree -h
</pre></div>
<h3 id="grep">grep</h3>
<p>文本搜索工具, 支持正则表达式和通配符</p>
<p>&lsquo;grep&lsquo;命令搜索指定文件中包含给定字符串或者单词的行</p>
<p>基本用法</p>
<div class="codehilite"><pre>grep "match_pattern" file1 file2
</pre></div>
<p>使用颜色重点标记</p>
<div class="codehilite"><pre>grep word filename --color=auto
</pre></div>
<p>扩展型使用正则</p>
<div class="codehilite"><pre>grep -E "[a-z]+"
egrep "[a-z]+"
</pre></div>
<p>只输出匹配到的文本部分</p>
<div class="codehilite"><pre>grep -o word filename
</pre></div>
<p>除匹配行外的所有行</p>
<div class="codehilite"><pre>grep -v word filename
</pre></div>
<p>统计匹配行数</p>
<div class="codehilite"><pre>grep -c 'text' filename
</pre></div>
<p>打印出包含匹配字符串的行数</p>
<div class="codehilite"><pre>grep linux -n filename
</pre></div>
<p>打印样式匹配所位于的字符或字节的偏移</p>
<div class="codehilite"><pre>echo "gnu is not unix" | grep -b -o "not"
</pre></div>
<p>搜索多个文件，找出匹配文本位于哪个文件中</p>
<div class="codehilite"><pre>grep -l linux file1 file2
取反
grep -L
</pre></div>
<p>递归搜索目录</p>
<div class="codehilite"><pre>grep -R "text" dir
</pre></div>
<p>忽略大小写</p>
<div class="codehilite"><pre>grep -i "hello" filename
</pre></div>
<p>匹配多个样式</p>
<div class="codehilite"><pre>grep -e "pattern1" -e "pattern2" file
</pre></div>
<p>运行匹配脚本</p>
<div class="codehilite"><pre>grep -f pattern_file source_file

pattern_file:
hello
cool
</pre></div>
<p>在搜索中包含、排除文件</p>
<div class="codehilite"><pre>grep --include *.{c,cpp} word file
</pre></div>
<p>排除</p>
<div class="codehilite"><pre>grep --exclude "Readme" filename
--exclude-dir
</pre></div>
<p>静默输出，用于判断(不会产生任何输出)</p>
<div class="codehilite"><pre>grep -q word file
if [ $? -eq 0 ]
</pre></div>
<p>打印匹配行之前，之后的行</p>
<div class="codehilite"><pre>grep -A 3 之后3行
grep -B 3 之前
grep -C 3 前后
</pre></div>
<p>使用行缓冲</p>
<div class="codehilite"><pre>在使用tail -f命令时是可以及时看到文件的变化的，但是如果再加上一个grep命令，可能看到的就不那么及时了，
因为grep命令在buffer写不满时就不输出，可以通过选项  --line-buffered 来搞定，如：

tail -f file.txt | grep something  --line-buffered
</pre></div>
<h3 id="cut">cut</h3>
<p>语法</p>
<div class="codehilite"><pre>cut -c list [ file ... ]
cut -f list [ -d delim ] [ file ...]

-c list 以字符为主，作剪切操作
-f list 以字段为主，作剪切操作
</pre></div>
<p>提取字段或列</p>
<div class="codehilite"><pre>#第一列
cut -f1 filenam

#第二三列
cut -f2,3 filename
</pre></div>
<p>提取补集</p>
<div class="codehilite"><pre>cut -f1 --complement filename
</pre></div>
<p>指定字段分隔符</p>
<div class="codehilite"><pre>cut -d ";" -f2 filename
cut -d : -f 1,5 /etc/passwd
</pre></div>
<p>指定字符</p>
<div class="codehilite"><pre>-b 字节
-c 字符
-f 字段

cut -c1-5 filename
N-
N-M
-M

ls -l | cut -c 1-10
</pre></div>
<p>指定输出分隔符</p>
<div class="codehilite"><pre>cut -c1-3,6-9 --output-delimiter ","
</pre></div>
<h3 id="join">join</h3>
<p>语法</p>
<div class="codehilite"><pre>join [options] file1 file2

选项
-1 field1
-2 field2
-o file.field
-t separator
</pre></div>
<p>例子</p>
<div class="codehilite"><pre>join file1 file2
</pre></div>
<h3 id="sed">sed</h3>
<p>sed(Stream editor)流编辑器, 可以配合正则使用, 进行替换等</p>
<p>sed替换语法</p>
<div class="codehilite"><pre>sed 's/pattern/replace_string/' file
</pre></div>
<p>将结果直接运用于源文件</p>
<div class="codehilite"><pre>-i 用于, 直接修改源文件

替换第一个
sed -i 's/pattern/replace_string/' file

替换第二个
sed -i 's/pattern/replace_string/2' file

替换所有
sed -i 's/pattern/replace_string/g' file

从第N处开始替换
sed -i 's/pattern/replcae_string/2g' file
</pre></div>
<p>移除空白行</p>
<div class="codehilite"><pre>sed '/^$/d' file
</pre></div>
<p>已匹配字符串标记</p>
<div class="codehilite"><pre>引用匹配到的
sed 's/\w\+/[&amp;]/g' filename
</pre></div>
<p>组合多个表达式</p>
<div class="codehilite"><pre>sed 'exp1' | sed 'exp2'
等价
sed 'exp1;exp2'
</pre></div>
<p>使用引用</p>
<div class="codehilite"><pre><span class="x">sed "s/</span><span class="p">$</span><span class="nv">text</span><span class="x">/HELLO/"</span>
</pre></div>
<p>子串匹配标记(后向引用，最多9个)</p>
<div class="codehilite"><pre>sed 's/\([a-z]\+\)' \([A-Z\]\+\)/\2 \1/' filename
</pre></div>
<p>保存到文件</p>
<div class="codehilite"><pre>sed 's/pattern/replacement/' -i outfile
</pre></div>
<p>使用其他分隔符</p>
<div class="codehilite"><pre>sed 's#/home/#/tmp/#'
</pre></div>
<h3 id="awk">awk</h3>
<p>基本结构</p>
<div class="codehilite"><pre>awk -F '-' 'BEGIN{statements} {statements} END{statements}' file
表达式中单引号可以换成双引号
BEGIN -&gt; 每一行，执行statements, 执行END
</pre></div>
<p>打印某一列</p>
<div class="codehilite"><pre>awk -F '-' '{print $0}' file #全部
awk -F '-' '{print $2}' file #第二列
</pre></div>
<p>print拼接字符</p>
<div class="codehilite"><pre>awk '{var="v1"; var1="v2"; print var1"-"var2;}'
</pre></div>
<p>特殊变量</p>
<div class="codehilite"><pre><span class="x">NR nuber of records, 记录数</span>
<span class="x">NF number of fields, 字段数</span>
<span class="p">$</span><span class="x">0 当前行文本</span>
<span class="p">$</span><span class="x">1 第一字段</span>
<span class="p">$</span><span class="x">2 第二字段</span>
<span class="p">$</span><span class="nv">NF</span><span class="x"> 最后一个字段</span>

<span class="x">FILENAME 当前输入文件的名称</span>
<span class="x">FNR 当前输入文件记录数</span>
<span class="x">FS 字段分隔字符</span>
<span class="x">OFS 输出字段分隔符，默认" "</span>
<span class="x">ORS 输出记录分隔符，默认"\n"</span>
</pre></div>
<p>统计行数</p>
<div class="codehilite"><pre>awk 'END{print NF}'
</pre></div>
<p>将外部变量值传递给awk</p>
<div class="codehilite"><pre><span class="x">awk -v VARIABLE=</span><span class="p">$</span><span class="nv">VAR</span><span class="x"> '</span><span class="err">{</span><span class="x"> print VARIABLE }'</span>
<span class="x">awk '</span><span class="err">{</span><span class="x">print v1, v2}' v1=</span><span class="p">$</span><span class="nv">var1</span><span class="x"> v2=</span><span class="p">$</span><span class="nv">var2</span><span class="x"></span>
</pre></div>
<p>读取行</p>
<div class="codehilite"><pre>seq 5 | awk '{ getline var; print var}'
</pre></div>
<p>进行行过滤</p>
<div class="codehilite"><pre>awk 'NR&lt;5' #行号小于5
awk 'NR==1,NR==4' #行号在1到5之间
awk '/linux/' #包含样式linux
awk '!/linux/' #不包含
awk '$1 ~/jones/' #第一个字段包含jones

tail file
awk 'NR &lt;= 10' file
</pre></div>
<p>设定分隔符</p>
<div class="codehilite"><pre><span class="x">awk -F: '</span><span class="err">{</span><span class="x"> print </span><span class="p">$</span><span class="nv">NF</span><span class="x"> }' file</span>
</pre></div>
<p>设定输出分隔符</p>
<div class="codehilite"><pre>awk -F: -v "OFS=-" '{print $1,$2}' /etc/passwd
</pre></div>
<p>打印空行</p>
<div class="codehilite"><pre>awk 'NF&gt;0 {print $0}'
or
awk 'NF&gt;0' #未指定action默认打印
</pre></div>
<p>print和printf</p>
<div class="codehilite"><pre>awk -F: '{print "User", $1, "is really", $5}' /etc/passwd
awk -F: '{printf "User %s is really %s\n", $1, $5}' /etc/passwd
</pre></div>
<p>awk中使用循环</p>
<div class="codehilite"><pre><span class="x">for(i=0;i&lt;10;i++) </span><span class="err">{</span><span class="x"> print </span><span class="p">$</span><span class="nv">i</span><span class="x">; }</span>

<span class="x">for(i in array) </span><span class="err">{</span><span class="x"> print array[i] }</span>
</pre></div>
<p>内建函数</p>
<div class="codehilite"><pre>length(str)
index(str,search_str)
split(str,array,delimiter) 用界定符生成一个字符串列表
substr(string, start, end) #子串
sub(regex, replacement_str, str) #正则替换首个匹配位置
gsub(regex, replacement_str, string) #最后一个匹配位置
match(string, regex) #检查是否能够匹配字符串
tolower(string) #转小写
toupper(string) #转大写
</pre></div>
<p>写成脚本文件</p>
<div class="codehilite"><pre>BEGIN {}
pattern1 {action1}
pattern2 {action2}
END {}
</pre></div>
<h3 id="_15">文件迭代</h3>
<p>读文件行</p>
<div class="codehilite"><pre><span class="x">while read line;</span>
<span class="x">do</span>
<span class="x">    echo </span><span class="p">$</span><span class="nv">line</span><span class="x">;</span>
<span class="x">done &lt; file.txt</span>
</pre></div>
<p>迭代每个单词</p>
<div class="codehilite"><pre><span class="x">for word in </span><span class="p">$</span><span class="nv">line</span><span class="x">;</span>
<span class="x">do</span>
<span class="x">    echo </span><span class="p">$</span><span class="nv">word</span><span class="x">;</span>
<span class="x">done</span>
</pre></div>
<p>迭代每一个字符</p>
<div class="codehilite"><pre>for((i=0;i<span class="err">&lt;</span><span class="cp">${</span><span class="c1">#word</span><span class="cp">}</span>;i++))
do
    echo <span class="cp">${</span><span class="n">word</span><span class="p">:</span><span class="n">i</span><span class="p">:</span><span class="mi">1</span><span class="cp">}</span> ;
done
</pre></div>
<h3 id="paste">paste</h3>
<p>按列合并文件</p>
<div class="codehilite"><pre>paste file1 file2 file3
</pre></div>
<p>指定分隔符</p>
<div class="codehilite"><pre>paste file1 file2 -d ','
</pre></div>
<h3 id="tac">tac</h3>
<p>逆序打印</p>
<div class="codehilite"><pre>tac file1 file2
</pre></div>
<h3 id="rev">rev</h3>
<p>接收一个文件或stdin作为输入, 逆序打印每一行内容</p>
<div class="codehilite"><pre>echo "abc" | rev
</pre></div>
<h3 id="wget">wget</h3>
<p>Wget是用于非交互式（例如后台）下载文件的免费工具.支持HTTP, HTTPS, FTP协议和 HTTP 代理(选项多, 用法灵活)</p>
<p>一个用于文件下载的命令行工具</p>
<div class="codehilite"><pre>wget URL1 URL2
</pre></div>
<p>指定保存文件名</p>
<div class="codehilite"><pre>wget URL -O local.txt
</pre></div>
<p>指定日志，默认达到stdout</p>
<div class="codehilite"><pre>wget URL -O local.txt -o log.txt
</pre></div>
<p>指定重复尝试次数</p>
<div class="codehilite"><pre>wget -t 5 URL
</pre></div>
<p>下载限速</p>
<div class="codehilite"><pre>wget --limit-rate 20k url
</pre></div>
<p>指定限额</p>
<div class="codehilite"><pre>wget -Q 100m url
</pre></div>
<p>断点续传</p>
<div class="codehilite"><pre>wget -c URL

$ wget -c -t 100 -T 120 http://www.linux.com/xxxx.data

当文件特别大或者网络特别慢的时候，往往一个文件还没有下载完，连接就已经被切断，此时就需要断点续传。
wget的断点续传是自动的。
-c 选项的作用为断点续传。
-t 参数表示重试次数(例如重试100次，-t 100，如果设成-t 0，表示无穷次重试，直到连接成功)
-T 参数表示超时等待时间，例如-T 120，表示等待120秒连接不上就算超时
</pre></div>
<p>复制或镜像整个网站</p>
<div class="codehilite"><pre>wget --mirror exampledomain.com
wget -r -N -l DEPTH URL
     递归，允许对文件使用时间戳，层级
$ wget -r -np -nd http://www.linux.com/packs/

-np 的作用是不遍历父目录
-nd 表示不在本机重新创建目录结构
</pre></div>
<p>访问需要认证的HTTP/FTP</p>
<div class="codehilite"><pre>wget --user username --password pass URL
</pre></div>
<p>post请求</p>
<div class="codehilite"><pre>wget url -post-data "name=value" -O output.html
</pre></div>
<p>批量下载</p>
<div class="codehilite"><pre>wget -i downloads.txt #将文件地址写入一个文件
</pre></div>
<p>用wget命令执行ftp下载</p>
<div class="codehilite"><pre>wget -m ftp://username:password@hostname
</pre></div>
<h3 id="curl">curl</h3>
<p>基本用法</p>
<div class="codehilite"><pre>curl url &gt; index.html
</pre></div>
<p>不显示进度信息</p>
<div class="codehilite"><pre>curl URL --slient
</pre></div>
<p>将内容写入文件，而非标准输出</p>
<div class="codehilite"><pre>curl URL --slient -O
</pre></div>
<p>写入指定文件</p>
<div class="codehilite"><pre>curl URL --slient -o filename
</pre></div>
<p>显示进度条</p>
<div class="codehilite"><pre>curl url -o index.html --progress
</pre></div>
<p>断点续传</p>
<div class="codehilite"><pre>curl -C - URL
</pre></div>
<p>设置参照页字符串</p>
<div class="codehilite"><pre>curl --referer Referer_URL target_URL
跳转到target_URL,其头部referer为Referer_URL
</pre></div>
<p>设置cookie</p>
<div class="codehilite"><pre>curl url --cookie "user=slynux;pass=hack"
另存为一个文件

curl URL --cookie-jar cookie_file
</pre></div>
<p>设置用户代理</p>
<div class="codehilite"><pre>curl URL --user-agent "Mozilla/5.0"
头部信息
curl -H "Host: www.slynux.org" -H "Accept-language: en" url
</pre></div>
<p>限定下载带宽</p>
<div class="codehilite"><pre>curl url --limit-rate 20k
</pre></div>
<p>指定最大下载量(可下载的最大文件大小)</p>
<div class="codehilite"><pre>curl url --max-filesize bytes
超出限制的话，返回非0
</pre></div>
<p>进行认证</p>
<div class="codehilite"><pre>curl -u user:pass url
</pre></div>
<p>只打印头部信息,不下载远程文件</p>
<div class="codehilite"><pre>curl -I url
curl -head url
</pre></div>
<p>发送post请求</p>
<div class="codehilite"><pre>curl URL -d "va1=1&amp;va2=2"
         --data
</pre></div>
<h3 id="lynx">lynx</h3>
<p>将网页以ascii字符形式下载</p>
<div class="codehilite"><pre>lynx -dump URL &gt; webpage_as_text.txt
</pre></div>
<p>打印出网站的文本板块而非html</p>
<div class="codehilite"><pre>lynx -dump url
</pre></div>
<p>生成信息文件</p>
<div class="codehilite"><pre>lynx -traversal url
</pre></div>
<h3 id="tar">tar</h3>
<p>&ldquo;tar&rdquo;命令是磁带归档(Tape Archive)，对创建一些文件的的归档和它们的解压很有用。</p>
<p>将多个文件和文件夹保存成单个文件, 同时还能保留所有的文件属性</p>
<p>对文件进行归档</p>
<div class="codehilite"><pre>-c create file,创建文件
-f specify filename,指定文件名

tar -cf output.tar file1 file2 file3
tar -cf output.tar *.txt

tar -cvf output.tar *.txt
</pre></div>
<p>向归档中追加文件</p>
<div class="codehilite"><pre>tar -rvf original.tar new_file
-r,追加
</pre></div>
<p>查看过程中更多信息</p>
<div class="codehilite"><pre>tar -tvvf archive.tar
-v/-vv, verbose
</pre></div>
<p>提取文件或文件夹</p>
<div class="codehilite"><pre>-x, exact
tar -xf archive.tar

-C,指定文件
tar -xf archive.tar -C /path/to/extraction_directory


tar -xvf archive.tar
</pre></div>
<p>提取指定文件</p>
<div class="codehilite"><pre>tar -xvf file.tar file1 file4
</pre></div>
<p>拼接两个归档文件</p>
<div class="codehilite"><pre>tar -Af file1.tar file2.tar
#file2合并到file1中
</pre></div>
<p>只有在文件内容修改时间更新(newer),才进行添加</p>
<div class="codehilite"><pre>tar -uvvf archive.tar filea
</pre></div>
<p>比较归档文件与文件系统中的内容</p>
<div class="codehilite"><pre>tar -df archive.tar filename1 filename2
</pre></div>
<p>从归档文件中删除文件</p>
<div class="codehilite"><pre>tar -f archive.tar --delete file1 file2
</pre></div>
<p>提取到某个目录</p>
<div class="codehilite"><pre> tar zxvf package.tar.gz -C new_dir
</pre></div>
<p>压缩归档文件</p>
<div class="codehilite"><pre>gzip/gunzip -&gt; .gz
f.tar.gz   -z
tar -czvf 
tar -xzvf

bzip/bunzip -&gt; .bz2
f.tar.bz2  -j

f.tar.lzma --lzma
f.tar.lzo
</pre></div>
<p>从归档中排除部分文件</p>
<div class="codehilite"><pre>tar -cf arch.tar * --exclude "*.txt"
cat list
   filea
   fileb
tar -cf arch.tar * -X list
</pre></div>
<p>排除版本控制文件</p>
<div class="codehilite"><pre>tar --exclude-vcs -czvvf source.tar.gz files
</pre></div>
<p>打印总字节数</p>
<div class="codehilite"><pre>tar -cf arc.tar * --exclude "*.txt" --totals
</pre></div>
<h3 id="cpio">cpio</h3>
<p>使用频率不高</p>
<p>归档，保留文件属性（权限、所有权等）</p>
<div class="codehilite"><pre>echo file1 file2 | cpio -ov &gt; archive.cpio
-o 指定输出
-v 打印归档文件列表
</pre></div>
<p>列出cpio中的文件内容</p>
<div class="codehilite"><pre>cpio -it &lt; archive.cpio
-i指定输入
-t列出归档文件中的内容
</pre></div>
<h3 id="gzip">gzip</h3>
<p>压缩，会删除源文件</p>
<div class="codehilite"><pre>gzip filename
#got filename.gz
</pre></div>
<p>解压</p>
<div class="codehilite"><pre>gunzip filename.gz
</pre></div>
<p>列出文件属性信息</p>
<div class="codehilite"><pre>gzip -l text.gz
</pre></div>
<p>stdin读入文件并写出到stdout</p>
<div class="codehilite"><pre>cat file | gzip -c &gt; file.gz
</pre></div>
<p>压缩归档文件</p>
<div class="codehilite"><pre>tar -czvvf archive.tar.gz [files]
or
tar -cvvf archive.tar.gz [files]
gzip archive.tar
</pre></div>
<p>指定压缩率</p>
<div class="codehilite"><pre>1-9,1最低，但速度最快
gzip -9 test.img
</pre></div>
<h3 id="zcat">zcat</h3>
<p>无需解压缩，直接从.gz中提取内容</p>
<div class="codehilite"><pre>zcat test.gz
</pre></div>
<h3 id="bzip">bzip</h3>
<p>更大的压缩率</p>
<div class="codehilite"><pre>bzip2 filename
</pre></div>
<p>解压缩</p>
<div class="codehilite"><pre>bunzip2 filename.bz2
</pre></div>
<p>stdin到stdout</p>
<div class="codehilite"><pre>cat file &gt; bzip2 -c &gt; file.tar.bz2
</pre></div>
<p>压缩归档</p>
<div class="codehilite"><pre>tar -cjvvf archive.tar.bz2 [files]
or
tar -cvvf archive.tar [files]
bzip2 archive.tar
</pre></div>
<p>保留输入文件</p>
<div class="codehilite"><pre>bunzip2 test.bz2 -k
</pre></div>
<p>压缩率</p>
<div class="codehilite"><pre>bzip2 -9 test.img
</pre></div>
<h3 id="lzma">lzma</h3>
<p>比gzip/bzip2更好的压缩率</p>
<p>压缩</p>
<div class="codehilite"><pre>lzma filename
</pre></div>
<p>解压</p>
<div class="codehilite"><pre>unlzma filename.lzma
</pre></div>
<p>stdin到stdout</p>
<div class="codehilite"><pre>cat file | lzma -c &gt; file.lzma
</pre></div>
<p>创建归档</p>
<div class="codehilite"><pre>tar -cavvf archive.tar.lzma [files]
    -xavf
</pre></div>
<p>保留输入文件</p>
<div class="codehilite"><pre>lzma test.bz2 -k
</pre></div>
<p>压缩率</p>
<div class="codehilite"><pre>lzma -9 test.img
</pre></div>
<h3 id="zip">zip</h3>
<p>压缩</p>
<div class="codehilite"><pre>zip archive_name.zip [source files/dirs]
</pre></div>
<p>对目录和文件进行递归操作</p>
<div class="codehilite"><pre>zip -r archive.zip folder1 file2
</pre></div>
<h3 id="base64">base64</h3>
<p>编码</p>
<div class="codehilite"><pre>base64 filename &gt; outfile
cat file | base64 &gt; outfile
</pre></div>
<p>解码</p>
<div class="codehilite"><pre>base64 -d file &gt; outfile
</pre></div>
<h3 id="md5sum_1">md5sum</h3>
<p>&ldquo;md5sum&rdquo;就是计算和检验MD5信息签名。
md5 checksum(通常叫做哈希)使用匹配或者验证文件的文件的完整性，因为文件可能因为传输错误，磁盘错误或者无恶意的干扰等原因而发生改变。</p>
<p>单向散列</p>
<div class="codehilite"><pre>md5sum file
sha1sum file
</pre></div>
<h3 id="rsync">rsync</h3>
<p>可以对位于不同位置的文件和目录进行备份, 借助差异计算和压缩技术实现最小化数据传输量</p>
<p>要确保远端安装了 openssh</p>
<p>从一个目录复制到另一个目录</p>
<div class="codehilite"><pre>rsync -av source_path dest_path
-a 进行归档  -v打印细节
路径可以使本地，也可以是远端路径

e.g.
rsync -av /home/test /home/backups/ #复制到backups目录下
rsync -av /home/test /home/backups  #创建backups目录, 复制
</pre></div>
<p>备份到远程服务器</p>
<div class="codehilite"><pre>rsync -av source_path user@host:PATH
可以反向
</pre></div>
<p>改善传输速度</p>
<div class="codehilite"><pre>rsync -avz source destination
</pre></div>
<p>排除文件</p>
<div class="codehilite"><pre>rsync -avz source dest --exclude "*.txt"
                       --exclude-from FILEPATH
FILEPATH:
*.bak
</pre></div>
<p>更新备份时，删除不存在的文件</p>
<div class="codehilite"><pre>rsync -avz source dest --delete
</pre></div>
<h3 id="git">git</h3>
<p>初始化目录</p>
<div class="codehilite"><pre>git init
</pre></div>
<p>配置用户信息</p>
<div class="codehilite"><pre>git config --global user.name "wklken"
git config --global user.email "wklken@yeah.net"
</pre></div>
<p>加到远端</p>
<div class="codehilite"><pre>git remote add origin user@remotehost:/home/backup/backup.git
git push origin master
</pre></div>
<p>添加</p>
<div class="codehilite"><pre>git add *
</pre></div>
<p>删除</p>
<div class="codehilite"><pre>git rm *.py
</pre></div>
<p>标记一个检查点</p>
<div class="codehilite"><pre>git commit -m "Commit message"
</pre></div>
<p>查看日志</p>
<div class="codehilite"><pre>git log
</pre></div>
<p>回滚到某个版本</p>
<div class="codehilite"><pre>git checkout hashid [ filename ]
</pre></div>
<p>克隆</p>
<div class="codehilite"><pre>git clone url
</pre></div>
<h3 id="dd_1">dd</h3>
<p>Dtat Definiton, 要注意参数顺序, 错误的参数会损毁所有数据</p>
<p>可以用来转换和复制文件，大多数时间是用来复制iso文件(或任何其它文件)到一个usb设备(或任何其它地方)中去，所以可以用来制作USB启动器</p>
<p>语法说明</p>
<div class="codehilite"><pre>dd if=SOURCE of=TARGET bs=BLOCK_SIZE count=COUNT
if/of  输入/输出文件或设备路径
bs块大小
count 限制复制到目标的字节数

dd if=/dev/zero of=/dev/sda1

#制作iso 从cdrom设备读取所有数据, 创建iso文件
dd if=/dev/cdrom of=cdrom.iso
</pre></div>
<p>备份恢复</p>
<div class="codehilite"><pre>dd if=/dev/sda1 of=x.img

dd if=x.img of=/dev/sda1
</pre></div>
<h3 id="mount">mount</h3>
<p>mount 是一个很重要的命令，用来挂载不能自动挂载的文件系统。你需要root权限挂载设备。
在插入你的文件系统后，</p>
<div class="codehilite"><pre>mount --bind /source /destination

首先运行&rdquo;lsblk&rdquo;命令，识别出你的设备，然后把分配的设备名记下来。
root@tecmint:~# lsblk
创建一个任何名字的目录，但是最好和引用相关。

root@tecmint:~# su
Password:
root@tecmint:~# cd /dev
root@tecmint:~# mkdir usb
现在将&ldquo;sdb1&rdquo;文件系统挂载到&ldquo;usb&rdquo;目录.
root@tecmint:~# mount /dev/sdb1 /dev/usb
</pre></div>
<p>挂载镜像</p>
<div class="codehilite"><pre>mount -o loop file.img /mnt/mount_point
</pre></div>
<h2 id="_17">网络相关</h2>
<h3 id="ifconfig">ifconfig</h3>
<p>显示网络接口、子网掩码等详细信息</p>
<div class="codehilite"><pre>ifconfig
/sbin/ifconfig
</pre></div>
<p>打印某个特定网络接口</p>
<div class="codehilite"><pre>ifconfig iface_name

e.g.
ifconfig en1

HWaddr     MAC地址
inet addr  ip地址
Bcast      广播地址
Mask       子网掩码
</pre></div>
<p>设置网络接口ip</p>
<div class="codehilite"><pre>ifconfig wlan0 192.168.0.80
</pre></div>
<p>dns</p>
<div class="codehilite"><pre>cat /etc/resolv.conf

host google.com #Dns查找

nslookup google.com #更详细信息
</pre></div>
<p>修改dns/host</p>
<div class="codehilite"><pre>echo nameserver IP_ADDRESS &gt;&gt; /etc/resolv.conf

echo ip domain &gt;&gt; /etc/hosts
</pre></div>
<p>ping</p>
<div class="codehilite"><pre>ping www.baidu.com
</pre></div>
<p>路由信息</p>
<div class="codehilite"><pre>显示路由表
route

以数字形式显示地址
route -n
</pre></div>
<p>设置默认网关</p>
<div class="codehilite"><pre>route add default gw 192.168.0.1 wlan0
</pre></div>
<p>trace_route, 显示分组途径的所有网关的地址</p>
<div class="codehilite"><pre>traceroute google.com
</pre></div>
<h3 id="ping">ping</h3>
<p>基本</p>
<div class="codehilite"><pre>ping ADDRESS  #主机名，域名或ip
</pre></div>
<p>PING命令可以得到RTT(Round Trip Time), 分组从源到目的主机的往返时间, 单位ms</p>
<p>限制发送分组数</p>
<div class="codehilite"><pre>ping ADDRESS -c COUNT

ping
</pre></div>
<h3 id="fping">fping</h3>
<p>同时ping一组ip, 而且响应非常快</p>
<div class="codehilite"><pre>fping -a ip1 ip2 -g
fping -a 192.160.1/24 -g
fping -a &lt; ip.list

-a, 所有活动主机的ip
-g, 从IP/mask生成的ip地址范围
</pre></div>
<p>进行dns查询</p>
<div class="codehilite"><pre>fping -a -d 2 &gt; /dev/null  &lt; ip.list
</pre></div>
<h3 id="lftp">lftp</h3>
<p>基本用法</p>
<div class="codehilite"><pre>lftp username@ftphost
cd dir
lcd改变本地主机目录
mkdir 创建目录
get/put 下载上传
quit退出
</pre></div>
<h3 id="scp">scp</h3>
<p>scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。</p>
<p>linux的scp命令可以在linux服务器之间复制文件和目录.</p>
<p>拷贝文件</p>
<div class="codehilite"><pre>scp filename user@remotehost:/home/pat
ip或主机名均可

scp SOURCE DESTINATION
</pre></div>
<p>递归复制</p>
<div class="codehilite"><pre>scp -r dir1 user@remotehost:/home/backup
</pre></div>
<p>提高拷贝速度</p>
<div class="codehilite"><pre>scp  -c arcfour -r -P20755 dir/ 192.168.2.*:/**/**/data/
-c arcfour 这个算法没有加校验不保证完整性，注意慎用，内网1000M带宽，默认算法速度只能达到30M/s，用arcfour这个算法速度可以达到50-80M/s
</pre></div>
<h3 id="ssh">SSH</h3>
<p>连接远程</p>
<div class="codehilite"><pre>ssh username@remote_host

ssh -p port username@remote_host
</pre></div>
<p>执行命令</p>
<div class="codehilite"><pre>ssh username@remote_host 'cmd1; cmd2' &gt; stdout.txt 2&gt;errors.txt
</pre></div>
<p>压缩功能</p>
<div class="codehilite"><pre>ssh -C user@hostname 'cmds'
</pre></div>
<p>打通ssh</p>
<div class="codehilite"><pre>1.创建SSH密钥
  ssh-keygen -t rsa
  公钥, ~/.ssh/id_rsa.pub
2.登陆远端服务器, 将公钥写入 ~/.ssh/authorized_keys
</pre></div>
<h3 id="lsof">lsof</h3>
<p>列出系统中开放端口及运行在端口上的服务</p>
<div class="codehilite"><pre>lsof -i
</pre></div>
<p>配合grep, 获取需要的信息</p>
<h3 id="netstat">netstat</h3>
<p>查看开放端口和服务</p>
<div class="codehilite"><pre>netstat -tnp
</pre></div>
<h2 id="_19">磁盘和系统</h2>
<h3 id="du">du</h3>
<p>du = disk usage</p>
<p>估计文件的空间占用。 逐层统计文件（例如以递归方式）并输出摘要。</p>
<p>查看占用磁盘空间</p>
<div class="codehilite"><pre>du FILENAME1 FILENAME2
</pre></div>
<p>查看目录</p>
<div class="codehilite"><pre>du -a dir
</pre></div>
<p>以KB,MB或块为单位展示</p>
<div class="codehilite"><pre>du -h FILENAME1
</pre></div>
<p>显示总计情况</p>
<div class="codehilite"><pre>du -c FILENAME1
</pre></div>
<p>只显示合计</p>
<div class="codehilite"><pre>du -s FILENAME1
</pre></div>
<p>以特定单位打印</p>
<div class="codehilite"><pre>du -b/-k/-m/-B FILES
</pre></div>
<p>排除部分文件</p>
<div class="codehilite"><pre>du --exclude "*.txt" DIR
   --exclude-from EXCLUDE.txt DIR
</pre></div>
<p>指定最深层级</p>
<div class="codehilite"><pre>du --max-depth 2 DIR
</pre></div>
<p>指定目录最大的10个文件</p>
<div class="codehilite"><pre>du -ak S_DIR | sort -nrk 1 | head
</pre></div>
<h3 id="df">df</h3>
<p>df = disk free</p>
<p>报告系统的磁盘使用情况。在跟踪磁盘使用情况方面对于普通用户和系统管理员都很有用。 &lsquo;df&lsquo; 通过检查目录大小工作，但这一数值仅当文件关闭时才得到更新。</p>
<p>查看磁盘可用空间</p>
<div class="codehilite"><pre>df
df -h
</pre></div>
<h3 id="time">time</h3>
<p>计算命令执行时间</p>
<div class="codehilite"><pre>time COMMAND

real 挂钟时间, 从开始执行到结束的时间
user 进程花费在用户模式中的cpu时间, 真正用于执行进程所花得时间
sys  进程花费在内核模式中的cpu时间
</pre></div>
<p>写入文件</p>
<div class="codehilite"><pre>time -o output.txt COMMAND
time -a output.txt COMMAND #追加
</pre></div>
<p>格式化输出</p>
<div class="codehilite"><pre>time -f "Time: %U"  -a -o timing.log uname
real %e
user %U
sys %S
</pre></div>
<h3 id="who">who</h3>
<p>获取当前用户登陆信息</p>
<div class="codehilite"><pre>who / w
</pre></div>
<p>当前登陆主机的用户列表</p>
<div class="codehilite"><pre>users
</pre></div>
<h3 id="uptime">uptime</h3>
<p>查看系统已经通电运行多长时间了</p>
<div class="codehilite"><pre>uptime
#也可以看到负载
</pre></div>
<h3 id="last">last</h3>
<p>显示上次用户登录信息- 前一次启动会话信息</p>
<div class="codehilite"><pre>last
</pre></div>
<p>获取单个用户</p>
<div class="codehilite"><pre>last USER
</pre></div>
<h3 id="watch">watch</h3>
<p>在终端中以固定间隔监视命令输出</p>
<div class="codehilite"><pre>#default 2s
watch ls

# 5s
watch -n 5 ls
</pre></div>
<p>颜色标示</p>
<div class="codehilite"><pre>watch -d 'COMMAND'
</pre></div>
<h2 id="_21">进程和线程</h2>
<h3 id="ps">ps</h3>
<p>ps命令给出正在运行的某个进程的状态，每个进程有特定的id成为PID。</p>
<p>ps命令主要查看系统中进程的状态</p>
<div class="codehilite"><pre>USER              PID  %CPU %MEM      VSZ    RSS   TT  STAT STARTED      TIME COMMAND
USER表示启动进程用户
PID表示进程标志号

%CPU表示运行该进程占用CPU的时间与该进程总的运行时间的比例
%MEM表示该进程占用内存和总内存的比例。

VSZ表示占用的虚拟内存大小，以KB为单位。
RSS为进程占用的物理内存值，以KB为单位。

TTY表示该进程建立时所对应的终端，"?"表示该进程不占用终端。
STAT表示进程的运行状态，包括以下几种代码：
    D，不可中断的睡眠；
    R，就绪（在可运行队列中）；
    S，睡眠；
    T，被跟踪或停止；
    Z，终止（僵死）的进程，Z不存在，但暂时无法消除；
    W，没有足够的内存分页可分配；&lt;高优先序的进程；
    N，低优先序的进程；
    L，有内存分页分配并锁在内存体内（实时系统或I/O）。

START为进程开始时间。
TIME为执行的时间。
COMMAND是对应的命令名。
</pre></div>
<p>查看进程信息</p>
<div class="codehilite"><pre>#当前终端
ps

PID TTY TIME CMD
PID  进程ID
TTY  终端
TIME 进程启动后过去的时间
CMD  进程对应的命令
</pre></div>
<p>显示更多信息</p>
<div class="codehilite"><pre>#当前终端
ps -f
</pre></div>
<p>查看所有进程</p>
<div class="codehilite"><pre>ps aux
ps -ef
</pre></div>
<p>查看某个用户的所有进程</p>
<div class="codehilite"><pre>ps U ken
</pre></div>
<p>命令格式</p>
<div class="codehilite"><pre><span class="n">ps</span> <span class="p">[</span><span class="n">OTHER</span> <span class="n">OPTIONS</span><span class="p">]</span> <span class="o">-</span><span class="n">o</span> <span class="n">par1</span><span class="p">,</span><span class="n">par2</span><span class="p">,</span><span class="n">par3</span>
<span class="n">ps</span> <span class="o">-</span><span class="n">eo</span> <span class="n">comm</span><span class="p">,</span><span class="n">pcpu</span> <span class="o">|</span> <span class="n">head</span>
<span class="n">pmem</span> <span class="err">内存使用率，</span><span class="n">comm可执行文件名</span><span class="p">,</span><span class="n">user启动进程的用户</span><span class="p">,</span><span class="n">etime启动后度过的时间</span>
</pre></div>
<p>设置升序降序</p>
<div class="codehilite"><pre>ps -eo comm,pcpu --sort -pcpu | head
+升序，-降序
</pre></div>
<p>找出给定命令名对应进程ID</p>
<div class="codehilite"><pre>ps -C COMMAND_NAME
ps -C bash -o pid=
</pre></div>
<p>进程线程相关</p>
<div class="codehilite"><pre>ps -eLf --sort -nlwp | head
</pre></div>
<p>查看子进程树</p>
<div class="codehilite"><pre>ps axwef
</pre></div>
<p>注意：当你要知道有哪些进程在运行或者需要知道想杀死的进程PID时ps命令很管用。你可以把它与&lsquo;grep&lsquo;合用来查询指定的输出结果，例如：</p>
<div class="codehilite"><pre># ps -A | grep -i ssh
</pre></div>
<h3 id="pgrep_1">pgrep</h3>
<p>pgrep只需要命令名的一部分, ps需要准确的全名</p>
<p>基本用法</p>
<div class="codehilite"><pre>pgrep bash
</pre></div>
<p>指定进程的用户</p>
<div class="codehilite"><pre>pgrep -u root,slynux COMMAND
</pre></div>
<p>返回匹配进程数</p>
<div class="codehilite"><pre>pgrep -c COMANND
</pre></div>
<h3 id="top">top</h3>
<p>查看占用cpu最多的进程列表</p>
<div class="codehilite"><pre>top
</pre></div>
<h3 id="kill">kill</h3>
<p>kill是用来杀死已经无关紧要或者没有响应的进程,杀死一个进程需要知道进程的PID</p>
<p>列出可用信号</p>
<div class="codehilite"><pre>kill -l
</pre></div>
<p>终止一个进程</p>
<div class="codehilite"><pre>kill PROCESS_ID_LIST
</pre></div>
<p>强杀进程</p>
<div class="codehilite"><pre>kill -9 PROCESS_ID
</pre></div>
<p>杀死一组命令</p>
<div class="codehilite"><pre>killall process_name
killall -9 process_name

指定用户
killall -u USERNAME process_name
</pre></div>
<h3 id="pkill">pkill</h3>
<p>杀，接受进程名</p>
<div class="codehilite"><pre>pkill process_name
pkill -s SIGNAL process_name
</pre></div>
<h3 id="which">which</h3>
<p>查找PATH下某个命令位置</p>
<div class="codehilite"><pre>which ls
</pre></div>
<h3 id="whereis">whereis</h3>
<p>whereis的作用是用来定位命令的二进制文件\资源\或者帮助页.举例来说,获得ls和kill命令的二进制文件/资源以及帮助页:</p>
<div class="codehilite"><pre>whereis ls
whereis kill
</pre></div>
<p>类似which，多了命令手册位置，源代码位置</p>
<p>注意:当需要知道二进制文件保存位置时有用.</p>
<h3 id="file_1">file</h3>
<p>确定文件类型</p>
<h3 id="whatis">whatis</h3>
<p>对命令的简短描述</p>
<h3 id="hostname">hostname</h3>
<p>当前主机名</p>
<h3 id="uname">uname</h3>
<div class="codehilite"><pre>主机名
uname -n

#内核版本，硬件架构等
uname -a

#内核发行版本
uname -r

主机类型(32位/64位)
uname -m

cpu相关信息
cat /proc/cpuinfo

内存信息
cat /proc/meminfo
</pre></div>
<p>例子</p>
<div class="codehilite"><pre>#uname -a
Linux tecmint 3.8.0-19-generic #30-Ubuntu SMP Wed May 1 16:36:13 UTC 2013 i686 i686 i686 GNU/Linux

1. &ldquo;Linux&ldquo;: 机器的内核名
2. &ldquo;tecmint&ldquo;: 机器的分支名
3. &ldquo;3.8.0-19-generic&ldquo;: 内核发布版本
4. &ldquo;#30-Ubuntu SMP&ldquo;: 内核版本
5. &ldquo;i686&ldquo;: 处理器架构
6. &ldquo;GNU/Linux&ldquo;: 操作系统名
</pre></div>
<h3 id="crontab">crontab</h3>
<p>格式</p>
<div class="codehilite"><pre>* * * * * cmd
分钟(0-59)，小时(0-23)，天(1-31)，月份(1-12)，工作日(0-6)

A,B  A and B
*/C  every C
</pre></div>
<p>查看</p>
<div class="codehilite"><pre>crontab -l
crontab -l -u slynux
</pre></div>
<p>编辑</p>
<div class="codehilite"><pre>crontab -e
</pre></div>
<p>移除</p>
<div class="codehilite"><pre>crontab -r
crontab -u slynux -r
</pre></div>
<p>可以在crontab 中加入环境变量</p>
<h3 id="getopts">getopts</h3>
<p>命令行参数处理</p>
<div class="codehilite"><pre><span class="x">while getopts :f:vql opt</span>
<span class="x">do</span>
<span class="x">    case </span><span class="p">$</span><span class="nv">opt</span><span class="x"> in</span>
<span class="x">    f)  file=</span><span class="p">$</span><span class="nv">OPTARG</span><span class="x"></span>
<span class="x">        ;;</span>
<span class="x">    v)  verbose=true</span>
<span class="x">        ;;</span>
<span class="x">    ....</span>
</pre></div>
<h3 id="history">history</h3>
<p>&ldquo;history&rdquo;命令就是历史记录。它显示了在终端中所执行过的所有命令的历史</p>
<div class="codehilite"><pre>history
</pre></div>
<p>注意：按住&ldquo;CTRL + R&rdquo;就可以搜索已经执行过的命令，它可以你写命令时自动补全</p>
<h3 id="sudo">sudo</h3>
<p>&ldquo;sudo&rdquo;(super user do)命令允许授权用户执行超级用户或者其它用户的命令。通过在sudoers列表的安全策略来指定。</p>
<p>注意：sudo 允许用户借用超级用户的权限，然而&rdquo;su&rdquo;命令实际上是允许用户以超级用户登录。所以sudo比su更安全。
并不建议使用sudo或者su来处理日常用途，因为它可能导致严重的错误如果你意外的做错了事，这就是为什么在linux社区流行一句话：</p>
<p>&ldquo;To err is human, but to really foul up everything, you need root password.&rdquo;
&ldquo;人非圣贤孰能无过，但是拥有root密码就真的万劫不复了。&rdquo;</p>
<h3 id="cal">cal</h3>
<p>&ldquo;cal&rdquo;（Calender），它用来显示当前月份或者未来或者过去任何年份中的月份</p>
<div class="codehilite"><pre>cal
cal 02 1835
</pre></div>
<h3 id="cp">cp</h3>
<p>&ldquo;copy&rdquo;就是复制。它会从一个地方复制一个文件到另外一个地方</p>
<div class="codehilite"><pre>cp file1 file2
cp -r dir1 dir2
</pre></div>
<p>快速备份一个文件：</p>
<div class="codehilite"><pre>cp some_file_name{,.bkp}
</pre></div>
<p>注意： cp，在shell脚本中是最常用的一个命令，而且它可以使用通配符（在前面一块中有所描述），来定制所需的文件的复制。</p>
<h3 id="mv">mv</h3>
<p>&ldquo;mv&rdquo;命令将一个地方的文件移动到另外一个地方去。</p>
<p>&ldquo;mv&rdquo;命令将一个地方的文件移动到另外一个地方去。</p>
<h3 id="pwd">pwd</h3>
<p>&ldquo;pwd&rdquo;（print working directory），在终端中显示当前工作目录的全路径。</p>
<p>注意： 这个命令并不会在脚本中经常使用，但是对于新手，当从连接到nux很久后在终端中迷失了路径，这绝对是救命稻草。</p>
<h3 id="free">free</h3>
<div class="codehilite"><pre>free -m
             total       used       free     shared    buffers     cached
Mem:          7982       6811       1171          0        350       5114
-/+ buffers/cache:       1346       6636
Swap:        16935         11      16924
</pre></div>
<p>显示剩余内存</p>
<div class="codehilite"><pre>free -m | grep cache | awk '/[0-9]/{ print $4" MB" }'
</pre></div>
<p>在这里例子中,应用程序只使用了1346MB内存,还有6636MB空闲内存可以使用.</p>
<p>一些简单的计算方法：</p>
<p>物理已用内存 = 实际已用内存 - 缓冲 - 缓存 = 6811M - 350M - 5114M</p>
<p>物理空闲内存 = 总物理内存 - 实际已用内存 + 缓冲 + 缓存</p>
<p>应用程序可用空闲内存 = 总物理内存 - 实际已用内存</p>
<p>应用程序已用内存 = 实际已用内存 - 缓冲 - 缓存</p>
<p>原始解释：转至互联网：
Linux的基本原则是没有资源应该被浪费.因此核心会使用尽可能多的RAM,来缓存来自本地和远程的文件系统的信息.系统做读写操作的时候,会将与当前运行的进程相关的数据尽量存储在RAM里.系统报告的缓存是缓冲和页缓存两者之和.缓存并不是在进程结束的时候被回收(你可能很快会启动另外一个进程,需要同样的数据),而是随需回收&ndash;比如,当你启动一个需要大量内存的进程时,Linux核心会从内存中回收缓存,将得到的内存分配给新的进程.</p>
<p>有些区域,比如匿名内存映射(mmps)和共享内存区域,它们被报告为缓存,但不是被核心直接释放.一般的缓存不映射到进程的地址空间,仅仅是简单的核心映射,而这些特别的缓存映射到所有挂接到它们上面的进程.</p>
<h3 id="eval">eval</h3>
<div class="codehilite"><pre>eval "ls -l"
</pre></div>
<h3 id="basename">basename</h3>
<p>获取路径中文件部分</p>
<div class="codehilite"><pre>basename resolv.conf #resolv.conf
basename /etc/resolv.conf # resolv.conf
</pre></div>
<h3 id="cmp">cmp</h3>
<p>比较两个任意类型的文件并将结果输出至标准输出。如果两个文件相同， &lsquo;cmp&lsquo;默认返回0；如果不同，将显示不同的字节数和第一处不同的位置。</p>
<div class="codehilite"><pre>cmp file1 file2
diff file1 file2
</pre></div>
<h3 id="rm">rm</h3>
<p>&lsquo;rm&rsquo; 标准移除命令。 rm 可以用来删除文件和目录</p>
<div class="codehilite"><pre>rm file1
rm -r dir1  #递归删除空目录
</pre></div>
<p>强删</p>
<div class="codehilite"><pre>rm -rf fileordir
</pre></div>
<p>警告: &rdquo;rm -rf&rdquo; 命令是一个破坏性的命令,假如你不小心删除一个错误的目录。
一旦你使用&rsquo;rm -rf&rsquo; 删除一个目录,在目录中所有的文件包括目录本身会被永久的删除,所以使用这个命令要非常小心。</p>
<h3 id="service">service</h3>
<p>&lsquo;service&lsquo;命令控制服务的启动、停止和重启，它让你能够不重启整个系统就可以让配置生效以开启、停止或者重启某个服务。</p>
<p>注意：要想使用service命令，进程的脚本必须放在&lsquo;/etc/init.d&lsquo;，并且路径必须在指定的位置。
如果要运行&ldquo;service apache2 start&rdquo;实际上实在执行&ldquo;service /etc/init.d/apache2 start&rdquo;.</p>
<h3 id="man">man</h3>
<p>&lsquo;man&lsquo;是系统帮助页。Man提供命令所有选项及用法的在线文档。几乎所有的命令都有它们的帮助页</p>
<div class="codehilite"><pre>man thecommand
</pre></div>
<p>注意：系统帮助页是为了命令的使用和学习而设计的。</p>
<h3 id="passwd">passwd</h3>
<p>这是一个很重要的命令，在终端中用来改变自己密码很有用。显然的，因为安全的原因，你需要知道当前的密码。</p>
<h3 id="gcc">gcc</h3>
<p>gcc 是Linux环境下C语言的内建编译器。下面是一个简单的C程序，在桌面上保存为Hello.c （记住必须要有&lsquo;.c&lsquo;扩展名</p>
<div class="codehilite"><pre>gcc Hello.c
./a.out
gcc -o Hello Hello.c
./Hello
</pre></div>
<p>注意: 编译C程序时，输出会自动保存到一个名为&ldquo;a.out&rdquo;的新文件，因此每次编译C程序 &ldquo;a.out&rdquo;都会被修改。
因此编译期间最好定义输出文件名.，这样就不会有覆盖输出文件的风险了。</p>
<h3 id="g">g++</h3>
<p>g++是C++的内建编译器</p>
<div class="codehilite"><pre>g++ Add.cpp
./a.out
g++ -o Add Add.cpp
./Add
</pre></div>
<h3 id="java">java</h3>
<p>Java 是世界上使用最广泛的编程语言之一. 它也被认为是高效, 安全和可靠的编程语言. 现在大多数基于网络的服务都使用Java实现.</p>
<div class="codehilite"><pre>javac tecmint.java
java tecmint
</pre></div>
<p>注意: 几乎所有的Linux发行版都带有gcc编译器, 大多数发行版都内建了g++ 和 java 编译器, 有些也可能没有. 你可以用apt 或 yum 安装需要的包.</p>
<h3 id="devnull">关于/dev/null</h3>
<p>特别有用的特殊文件，位桶，传送到此文件的数据都会被系统丢弃。</p>
<h3 id="_22">语言及乱码</h3>
<p>查看变量值</p>
<div class="codehilite"><pre><span class="x">echo </span><span class="p">$</span><span class="nv">LANG</span><span class="x">   未设置任何LC_XXX时使用的默认值</span>
<span class="x">echo </span><span class="p">$</span><span class="nv">LC_ALL</span><span class="x"> 覆盖所有LC_XXX变量，总控开关</span>
</pre></div>
<p>好的做法是，避免为任何LC_XXX变量赋值，使用LC_ALL和LANG来控制</p>
<p>避免乱码：从编辑器到语言，再到系统，统一编码为UTF-8</p>
<h3 id="shell_1">shell的版本</h3>
<div class="codehilite"><pre>bash --version
</pre></div>
    </section>

    <section id="copyright">
        <div class="copyright">
            版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" >Creative Commons BY-NC-ND 3.0</a>
        </div>

        <div class="donation">
            <center>
            <img src="/imgs/life/donation.png"/>
            <strong> 如果你觉得我的文章或项目对你有所帮助, 可小额捐赠 ¥0.99/¥2.99/¥4.99/¥9.9 用于站点维护:)</strong>
            </center>
        </div>
    </section>


    <section id="neighbors">
        <div>
                        <a class="left" href="http://www.wklken.me/posts/2013/07/04/summary-07-worktwoyear.html">
                            上一篇:  工作两周年小结
                        </a>
                        <a class="right" href="http://www.wklken.me/posts/2013/07/18/python-translate-yield.html">
                            下一篇: [翻译]Python中yield的解释
                        </a>
        </div>
    </section>

    <section id="ad">
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <!-- blog_ad_001 -->
        <ins class="adsbygoogle"
            style="display:block"
            data-ad-client="ca-pub-7635941258020589"
            data-ad-slot="3455159758"
            data-ad-format="auto"></ins>
        <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
        </script>

        <a href='http://www.vultr.com/?ref=6847203' target="_blank">
        <img src="/imgs/ads/vultr.png"> </img>
        </a>
    </section>



<section id="comments">
        <div class="comments">
            <div id="disqus_thread"></div>
            <script type="text/javascript">
                var disqus_identifier = "posts/2013/07/04/note-of-linux-shell-scripting-cookbook.html";
                (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = 'http://wklken.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            </script>
            </div>
</section>



</article>
        </section><!--end #main-->

            <footer class="row">
                <div class="large-12 columns">
                    <p>
                            Copyright © 2015 wklken <br>
                            Hosted on <a href="http://www.vultr.com/?ref=6847203"> vultr </a> Also <a href="https://www.digitalocean.com/?refcode=8ee73f2c47ce"> DigitalOcean </a>. Powered by <a href="http://alexis.notmyidea.org/pelican/">pelican</a>. Social Icons by <a href="http://fortawesome.github.io/Font-Awesome/">Font-Awesome</a>.
                    </p>
                </div>
            </footer>

            </div>
        </div>

        <section id="extras" class="body">
        </section><!-- /#extras -->



<script src="http://apps.bdimg.com/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="http://apps.bdimg.com/libs/jquery-scrollUp/2.1.0/jquery.scrollUp.min.js"></script>
<script src="http://apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script>
<script>
    $(function(){
        $.scrollUp({
              scrollText: '', // Text for element, can contain HTML
            });
    });
</script>


<script type="text/javascript">
  /* var Swiftype = window.Swiftype || {}; */
  /* Swiftype.searchSearchFields = { */
    /* "page": ["title^10", "body"] */
  /* }; */

  /* (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){ */
  /* (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t); */
  /* e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e); */
  /* })(window,document,'script','//s.swiftypecdn.com/install/v1/st.js','_st'); */

  /* _st('install','v6K-_DamCeHvwX6z3o2F'); */
</script>



    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-42275748-1");
    pageTracker._trackPageview();
    } catch(err) {}</script>




<div id="share">
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":["mshare","tsina","weixin","douban","meilishuo","mogujie","youdao","sdo","mail","twi","copy","print"],"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"5","bdPos":"right","bdTop":"96.5"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
</div>



<script  src="http://www.wklken.me/theme/js/scroll-header.js" type="text/javascript"></script>




</body>
</html>