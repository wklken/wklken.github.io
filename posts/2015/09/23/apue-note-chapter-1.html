<!DOCTYPE html>
<html lang="en-us">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">
<meta itemprop="name" content="APUE笔记-第一章 UNIX基础知识">
<meta itemprop="description" content="最近在找工作, 额, 从七月份一直休息到九月初, 开始找, 结果发现快到十月了, 节点不是很好, 要过两个节, 所以估计入职什么的要到节后了&gt;_&l">
<meta itemprop="datePublished" content="2015-09-23T08:00:00+08:00" />
<meta itemprop="dateModified" content="2015-09-23T08:00:00+08:00" />
<meta itemprop="wordCount" content="3624">



<meta itemprop="keywords" content="apue," />
<meta property="og:title" content="APUE笔记-第一章 UNIX基础知识" />
<meta property="og:description" content="最近在找工作, 额, 从七月份一直休息到九月初, 开始找, 结果发现快到十月了, 节点不是很好, 要过两个节, 所以估计入职什么的要到节后了&gt;_&l" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wklken.me/posts/2015/09/23/apue-note-chapter-1.html" />
<meta property="article:published_time" content="2015-09-23T08:00:00+08:00" />
<meta property="article:modified_time" content="2015-09-23T08:00:00+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="APUE笔记-第一章 UNIX基础知识"/>
<meta name="twitter:description" content="最近在找工作, 额, 从七月份一直休息到九月初, 开始找, 结果发现快到十月了, 节点不是很好, 要过两个节, 所以估计入职什么的要到节后了&gt;_&l"/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>APUE笔记-第一章 UNIX基础知识</title>
	<link rel="stylesheet" href="https://wklken.me/css/style.min.7c28645f246457293fca7e4bd85d4ec31ca56746889e9b709ef76744b7be9779.css" crossorigin="anonymous">
	
	
	<link rel="stylesheet" href="https://wklken.me/css/custom.css">
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://wklken.me">WKLKEN THINKING</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					<a href="https://wklken.me/posts.html">Posts</a>
					<a href="https://wklken.me/about.html">About</a>
				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<button id="toc-btn" class="hdr-btn desktop-only-ib" title="Table of Contents"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-list"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3" y2="6"></line><line x1="3" y1="12" x2="3" y2="12"></line><line x1="3" y1="18" x2="3" y2="18"></line></svg></button><span class="hdr-social hide-in-mobile"><a href="https://github.com/wklken" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a><a href="wklken@gmail.com" target="_blank" rel="noopener me" title="Email"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-mail"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg></a><a href="https://twitter.com/wklken" target="_blank" rel="noopener me" title="Twitter"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-twitter"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://wklken.me/posts.html">Posts</a></li>
			<li><a href="https://wklken.me/about.html">About</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Sep 23, 2015</span></div>
				<h1>APUE笔记-第一章 UNIX基础知识</h1>
			</header>
			<div class="content">
				<hr>
<p>最近在找工作, 额, 从七月份一直休息到九月初, 开始找, 结果发现快到十月了, 节点不是很好, 要过两个节, 所以估计入职什么的要到节后了&gt;_&lt;#</p>
<p>这几个月也在思考一些东西, 顺手也解决掉了<code>Python源码剖析</code>, 目前在逐步梳理笔记</p>
<p>发现自己首次做笔记还是太杂太乱, 堆在wiki里面一大坨的感觉, 还是要梳理画图, 思路更清晰些, 静候吧, 还是十篇左右的样子</p>
<p>读APUE, 做法比较<code>残忍</code>, 把书切开, 拆成一章一章地装订, 方便携带和阅读, 最后发现画满了一堆东西</p>
<p>发现还是不方便自己查阅, 所以还是决定重读, 转成笔记, 放到博客上方便搜索/查阅</p>
<p>对了, 代码之前只是下了看到的时候run下, 这次重读写写注释, 放到github了, <a href="https://github.com/wklken/apue.3e">链接</a></p>
<p>在此感谢作者W.Richard Stevens :) 这本书五星好评, 建议如果搞linux相关后端, 可以读下</p>
<hr>
<h1 id="第一章-unix基础知识">第一章 UNIX基础知识<a href="#第一章-unix基础知识" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>
<h2 id="unix体系结构-内核与系统调用">Unix体系结构: 内核与系统调用<a href="#unix体系结构-内核与系统调用" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p><img src="/imgs/apue/1-1.jpg" alt="">￼</p>
<p>内核(kernel): 严格意义上, 将操作系统定义为一种软件, 它控制计算机硬件资源, 提供程序运行环境(相对较小, 位于环境的中心)</p>
<p>系统调用(system call): 内核的接口</p>
<p>关系: 公用函数库构建在系统调用接口之上, 应用软件既可以使用公用函数库, 也可以使用系统调用</p>
<h2 id="登陆">登陆<a href="#登陆" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>口令文件<code>/etc/passwd</code>, 七个字段,冒号分隔</p>
<pre><code>登录名:加密口令:数值用户 ID: 数值组 ID: 注释字段:起始目录:shell
</code></pre><p>加密口令已经转移到另一个文件</p>
<p>shell: 一个命令行解释器, 它读取用户输入, 然后执行命令</p>
<p>Linux 默认shell是Bourne-again shell</p>
<h2 id="文件和目录">文件和目录<a href="#文件和目录" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>文件系统: 目录和文件组成的一种层次接口, 目录的起点称为根(root), 其名字是<code>\\</code></p>
<p>目录(directory)是一个包含许多目录项的文件</p>
<p>文件名(filename): 不能出现斜线<code>/</code>和空操作符<code>null</code>(好的习惯只使用印刷字符的一个子集作为文件名字符)</p>
<p>创建目录时, 会自动创建两个文件名, 当前目录<code>.</code> 以及父目录<code>..</code></p>
<p>路径名(pathname): 一个或多个以斜线分割的文件名序列. 以斜线开头的是绝对路径(absolute pathname), 否则是相对路径(relative pathname)</p>
<p><a href="https://github.com/wklken/apue.3e/blob/master/intro/ls1.c">ls.c源代码</a></p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;apue.h&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;dirent.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 可编译执行
</span><span class="c1">// apue.h, 包含某些标准头文件, 定义了很多常量及库函数
</span><span class="c1"></span>
<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">DIR</span>                <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
    <span class="c1">// 结构体
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">dirent</span>    <span class="o">*</span><span class="n">dirp</span><span class="p">;</span>

    <span class="c1">// 需要至少一个参数
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1">// apue.h自定义函数
</span><span class="c1"></span>        <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: ls directory_name&#34;</span><span class="p">);</span>

    <span class="c1">// 赋值后判断, opendir返回指向 DIR 结构体的指针
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">dp</span> <span class="o">=</span> <span class="n">opendir</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="c1">// apue.h自定义函数err_sys
</span><span class="c1"></span>        <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;can&#39;t open %s&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="c1">// 赋值后判断, 读每一项, 返回指向readdir结构的指针或null(没有目录项可读时)
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">((</span><span class="n">dirp</span> <span class="o">=</span> <span class="n">readdir</span><span class="p">(</span><span class="n">dp</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="c1">// 取出每个目录的名字
</span><span class="c1"></span>        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">dirp</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>

    <span class="n">closedir</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>

    <span class="c1">// 终止程序, 0正常结束, 1-255出错
</span><span class="c1"></span>    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>工作目录(working directory), 每个进程都有一个, 优势成为当前工作目录, 进程可以通过chdir函数更改其工作目录.</p>
<h2 id="输入和输出">输入和输出<a href="#输入和输出" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>文件描述符(file descriptor), 一个小的负整数, 内核使用它标识一个特定进程正在访问的文件. 当内核打开或创建一个新文件时, 返回一个文件描述符, 在读写的时候使用</p>
<p>每当运行一个新程序时, 所有的shell都为其打开三个文件描述符: 标准输入(standard input), 标准输出(standard output)以及标准错误(standard error)</p>
<p>不用缓冲的I/O
函数open/read/write/lseek/close</p>
<p><a href="https://github.com/wklken/apue.3e/blob/master/intro/mycat.c">mycat.c源码</a></p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;apue.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 缓冲区大小, 常量 */</span>
<span class="cp">#define    BUFFSIZE    4096
</span><span class="cp"></span>
<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span>     <span class="n">n</span><span class="p">;</span>
    <span class="kt">char</span>    <span class="n">buf</span><span class="p">[</span><span class="n">BUFFSIZE</span><span class="p">];</span>

    <span class="cm">/* STDIN_FILENO/STDOUT_FILENO -&gt; apue.h -&gt; unisted.h, 标准输入文件描述符0/标准输出文件描述符1 */</span>

    <span class="cm">/* 从标准输入读, read返回读得的字节数, 读到末端返回0, 发生错误返回-1 */</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUFFSIZE</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="cm">/* 写到标准输入 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;write error&#34;</span><span class="p">);</span>

    <span class="cm">/* 发生错误 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;read error&#34;</span><span class="p">);</span>

    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>标准I/O函数: 提供了一种对不用缓冲 I/O 函数的带缓冲接口, 可以无需担心如何选取最佳的缓冲区大小</p>
<p><a href="https://github.com/wklken/apue.3e/blob/master/intro/getcputc.c">getputc.c源码</a></p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;apue.h&#34;</span><span class="cp">
</span><span class="cp"></span>

<span class="cm">/* stdin/stdout -&gt; apue.h -&gt; stdio.h 标准输入文件/标准输出文件 */</span>
<span class="cm">/* EOF为stdio.h中定义的常量 */</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>

    <span class="cm">/* 从标准输入中读入一个字符 */</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">c</span> <span class="o">=</span> <span class="n">getc</span><span class="p">(</span><span class="n">stdin</span><span class="p">))</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span>
        <span class="cm">/* 输出到标准输出 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">putc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">stdout</span><span class="p">)</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span>
            <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;output error&#34;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ferror</span><span class="p">(</span><span class="n">stdin</span><span class="p">))</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;input error&#34;</span><span class="p">);</span>

    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h2 id="程序和进程">程序和进程<a href="#程序和进程" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>程序(program): 存放在磁盘上, 处于某个目录中的一个可执行文件.(使用6个exec函数中的一个有内核将程序读入存储器, 并使其执行)</p>
<p>进程(process): 程序的执行实例</p>
<p>进程ID(process ID), 每个进程都有一个唯一的数字标识符, 总是一非负整数</p>
<p><a href="https://github.com/wklken/apue.3e/blob/master/intro/hello.c">hello.c 源码</a></p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;apue.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* getpid得到进程pid */</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;hello world from process ID %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">getpid</span><span class="p">());</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>进程控制: 三个主要函数, fork/exec(六种变体)/waitpid</p>
<p><a href="https://github.com/wklken/apue.3e/blob/master/intro/shell1.c">shell1.c 源码</a></p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;apue.h&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span><span class="cp"></span>

<span class="cm">/* fork创建一个新进程, 它被调用一次(由父进程调用), 返回两次(在父进程中返回子进程的进程ID, 在子进程中返回0) */</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span>    <span class="n">buf</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>    <span class="cm">/* from apue.h */</span>
    <span class="n">pid_t</span>    <span class="n">pid</span><span class="p">;</span>
    <span class="kt">int</span>        <span class="n">status</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%% &#34;</span><span class="p">);</span>    <span class="cm">/* print prompt (printf requires %% to print %) */</span>

    <span class="cm">/* 读入一行, 每一行命令会产生一个子进程用于执行 */</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span> <span class="n">stdin</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 去掉换行符 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
            <span class="n">buf</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* replace newline with null */</span>

        <span class="cm">/* 执行读入的命令 */</span>
        <span class="cm">/* fork创建一个子进程, 返回&lt;0则表示fork发生了错误 */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;fork error&#34;</span><span class="p">);</span>

        <span class="cm">/* 对于子进程, fork返回的pid=0(父进程fork返回的pid&gt;0) */</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>        <span class="cm">/* child */</span>

            <span class="cm">/* 调用execlp以执行从标准输入读入的命令 */</span>
            <span class="cm">/* fork+exec组合, 是某些操作系统所称的产生(spawn)一个新的进程 */</span>
            <span class="n">execlp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
            <span class="n">err_ret</span><span class="p">(</span><span class="s">&#34;couldn&#39;t execute: %s&#34;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
            <span class="cm">/* 退出 */</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* 父进程, 等待子进程终止 */</span>
        <span class="cm">/* pid为子进程id, status为子进程终止状态(用于判断其实如何终止的) */</span>
        <span class="cm">/* parent */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;waitpid error&#34;</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%% &#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

</code></pre></div><p>通常, 一个进程只有一个控制线程(thread), 同一时刻只执行一组机器指令.(对于某些问题, 如果不同部分各使用一个控制线程, 那么整个问题解决相对容易, 多个控制线程也能充分利用多处理器系统的并行性)</p>
<p>在一个进程内的所有线程共享同一地址空间/文件描述符/栈以及与进程相关的属性(所以各线程在访问共享数据时需要采取同步措施以避免不一致性)</p>
<p>线程也用 ID 标识, 但只在其所属进程内起作用</p>
<h2 id="出错处理">出错处理<a href="#出错处理" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>UNIX 函数出错的时候, 常常返回一个负值, 而整型变量errno通常被设置为含有附加信息的一个值</p>
<p><code>errno.h</code>中, 定义了符号errno以及可以赋予它的各种常量.(errno(3)手册中)</p>
<p>对于errno两条规则</p>
<pre><code>1. 如果没有出错, 其值则不会被一个例程清楚, 因此, 仅当函数的返回值指明出错时, 才检验其值
2. 任一函数都不会将errno值设置为0, 在errnoh中定义的所有常量都不为0
</code></pre><p><a href="https://github.com/wklken/apue.3e/blob/master/intro/testerror.c">testerror.c 源码</a></p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;apue.h&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
</span><span class="cp"></span>

<span class="cm">/* strerror, 将errnum映射为一个出错信息字符串, 并且返回此字符串的指针 */</span>
<span class="cm">/* perror, 基于errno的当前值, 在标准出错上产生一条出错信息, 然后返回 */</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="cm">/* 常量 EACCES / ENOENT */</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;EACCES: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">EACCES</span><span class="p">));</span>
    <span class="n">errno</span> <span class="o">=</span> <span class="n">ENOENT</span><span class="p">;</span>
    <span class="n">perror</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>出错恢复: errno.h中定义的各种出错分为致命性和非致命性两类.</p>
<p>致命性出错: 无法执行恢复动作, 最多只能在屏幕上打印一条出错信息, 或写入日志, 然后终止</p>
<p>非致命性出错: 可以较为妥善地处理</p>
<h2 id="用户标识">用户标识<a href="#用户标识" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>用户ID(user ID), 数值, 系统中标识各个不同的用户, 每个用户唯一(用户不能更改其用户 ID)</p>
<p>用户 ID 为0的用户为根( root) 或超级用户(superuser)</p>
<p>组ID(group ID), 一个数值, 指定用户登陆名时同时指定的. 允许同组各个成员之间共享资源</p>
<p>组文件将组名映射为数字 ID, <code>/etc/group</code></p>
<p>口令文件包含: 登录名 = 用户 ID 的映射</p>
<p>组文件包含: 组名 = 组ID 的映射</p>
<p>打印用户ID和组ID</p>
<p><a href="https://github.com/wklken/apue.3e/blob/master/intro/uidgid.c">uidgid.c 源码</a></p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;apue.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* getuid / getgid */</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;uid = %d, gid = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getuid</span><span class="p">(),</span> <span class="n">getgid</span><span class="p">());</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>附加组ID</p>
<p>允许一个用户属于多个组, 最多16个.</p>
<h2 id="信号">信号<a href="#信号" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>信号(signal): 通知进程已发生某种情况的一种技术.</p>
<p>e.g. 一个进程执行除法操作, 其除数为0, 则将名为SIGFPE的信号发给该进程</p>
<p>进程如何处理信号?</p>
<pre><code>1. 忽略该信号
2. 按系统默认方式处理.
3. 提供一个函数, 信号发生时则调用该函数(捕捉信号)
</code></pre><p>信号捕捉</p>
<p><a href="https://github.com/wklken/apue.3e/blob/master/intro/shell2.c">shell2.c 源码</a></p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;apue.h&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 声明信号处理函数 */</span>
<span class="k">static</span> <span class="kt">void</span>    <span class="nf">sig_int</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>        <span class="cm">/* our signal-catching function */</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span>    <span class="n">buf</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>    <span class="cm">/* from apue.h */</span>
    <span class="n">pid_t</span>    <span class="n">pid</span><span class="p">;</span>
    <span class="kt">int</span>        <span class="n">status</span><span class="p">;</span>


    <span class="cm">/* signal函数, 指定SIGINT 到处理函数 sig_int */</span>
    <span class="cm">/* 机制, 类似于直接注册到了进程, 观察是否异常发生后捕获处理 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">sig_int</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;signal error&#34;</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%% &#34;</span><span class="p">);</span>    <span class="cm">/* print prompt (printf requires %% to print %) */</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span> <span class="n">stdin</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
            <span class="n">buf</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* replace newline with null */</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;fork error&#34;</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>        <span class="cm">/* child */</span>
            <span class="n">execlp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
            <span class="n">err_ret</span><span class="p">(</span><span class="s">&#34;couldn&#39;t execute: %s&#34;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* parent */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;waitpid error&#34;</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%% &#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* 处理函数, 打印 */</span>
<span class="kt">void</span>
<span class="nf">sig_int</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;interrupt</span><span class="se">\n</span><span class="s">%% &#34;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h2 id="时间值">时间值<a href="#时间值" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>UNIX系统两种不同的时间值</p>
<p>日历时间, time_t, 从1970年1月1日00:00:00以来的国际标准时间UTC锁经过的秒数</p>
<p>进程时间, clock_t, CPU时间, 度量进程使用的中央处理器资源, 以始终滴答计算</p>
<p>Unix系统使用三个进程时间</p>
<pre><code>1. 时钟时间, 总时间, real
2. 用户cpu时间, 执行用户指令耗时, user
3. 系统cpu时间, 执行内核程序耗时, sys
</code></pre><h2 id="系统调用和库函数">系统调用和库函数<a href="#系统调用和库函数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>所有操作系统都提供多种服务的入口点(系统调用), 程序由此想内核请求服务</p>
<p>UNIX所使用的技术是为每个系统调用在标准 C 库中设置一个具有同样名字的函数. 用户进程用标准 C 调用序列来调用这些函数, 然后函数又用系统所要求的技术调用相应的内核服务</p>
<p>系统调用通常提供一种最小接口，而库函数通常提供比较复杂的功能。</p>
<p><img src="/imgs/apue/1-2.jpg" alt="">￼</p>
<p>系统调用: 最小接口, 单一职责, 不可替换</p>
<p>C库函数: 复杂功能, 可替换, 可自行定义</p>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://wklken.me/tags/apue.html">apue</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>3624 Words</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2015-09-23 08:00 &#43;0800</p>
			</footer>
		</article>
		<aside id="toc" class="show-toc">
			<div class="toc-title">Table of Contents</div>
			<nav id="TableOfContents">
  <ul>
    <li><a href="#unix体系结构-内核与系统调用">Unix体系结构: 内核与系统调用</a></li>
    <li><a href="#登陆">登陆</a></li>
    <li><a href="#文件和目录">文件和目录</a></li>
    <li><a href="#输入和输出">输入和输出</a></li>
    <li><a href="#程序和进程">程序和进程</a></li>
    <li><a href="#出错处理">出错处理</a></li>
    <li><a href="#用户标识">用户标识</a></li>
    <li><a href="#信号">信号</a></li>
    <li><a href="#时间值">时间值</a></li>
    <li><a href="#系统调用和库函数">系统调用和库函数</a></li>
  </ul>
</nav>
		</aside>
		<div class="post-nav thin">
			<a class="next-post" href="https://wklken.me/posts/2015/09/26/why-i-keep-blogging.html">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;Newer</span><br><span>我为什么要写博客</span>
			</a>
			<a class="prev-post" href="https://wklken.me/posts/2015/09/04/python-source-closure.html">
				<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>Python源码阅读-闭包的实现</span>
			</a>
		</div>

		<div id="comments" class="thin">
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="https://wklken.me/js/md5.min.js"></script>
<script>
  const gitalk = new Gitalk({
    clientID: '549d325e74a413f1b56a',
    clientSecret: '086a83faacf152cc3f4079f002058716879e9688',
    repo: 'wklken.github.io',
    owner: 'wklken',
    admin: ['wklken'],
    id: md5(location.pathname), 
    distractionFreeMode: false 
  });
  (function() {
    if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
      document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
      return;
    }
    gitalk.render('gitalk-container');
  })();
</script>

</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2021 <a href="https://wklken.me">wklken</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://wklken.me/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>


	<script src="https://wklken.me/js/main.min.784417f5847151f848c339cf0acb13a06cbb648b1483435a28ed4556c4ead69b.js" integrity="sha256-eEQX9YRxUfhIwznPCssToGy7ZIsUg0NaKO1FVsTq1ps="></script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-42275748-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


</body>

</html>
