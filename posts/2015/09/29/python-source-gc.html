<!DOCTYPE html>
<html lang="en-us">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">
<meta itemprop="name" content="Python 源码阅读 - 垃圾回收机制">
<meta itemprop="description" content="概述 无论何种垃圾收集机制, 一般都是两阶段: 垃圾检测和垃圾回收. 在Python中, 大多数对象的生命周期都是通过对象的引用计数来管理的. 问题: 但"><meta itemprop="datePublished" content="2015-09-29T08:00:00+08:00" />
<meta itemprop="dateModified" content="2015-09-29T08:00:00+08:00" />
<meta itemprop="wordCount" content="5007">
<meta itemprop="keywords" content="python," /><meta property="og:title" content="Python 源码阅读 - 垃圾回收机制" />
<meta property="og:description" content="概述 无论何种垃圾收集机制, 一般都是两阶段: 垃圾检测和垃圾回收. 在Python中, 大多数对象的生命周期都是通过对象的引用计数来管理的. 问题: 但" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wklken.me/posts/2015/09/29/python-source-gc.html" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-09-29T08:00:00+08:00" />
<meta property="article:modified_time" content="2015-09-29T08:00:00+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Python 源码阅读 - 垃圾回收机制"/>
<meta name="twitter:description" content="概述 无论何种垃圾收集机制, 一般都是两阶段: 垃圾检测和垃圾回收. 在Python中, 大多数对象的生命周期都是通过对象的引用计数来管理的. 问题: 但"/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>Python 源码阅读 - 垃圾回收机制</title>
	<link rel="stylesheet" href="https://wklken.me/css/style.min.a634759f5e59454c8c91bba6cb21df1387610e17a0916dfc23b1723d2e0623ed.css" integrity="sha256-pjR1n15ZRUyMkbumyyHfE4dhDhegkW38I7FyPS4GI+0=" crossorigin="anonymous">
	
	<link rel="stylesheet" href="https://wklken.me/css/custom.css">
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://wklken.me">WKLKEN THINKING</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://wklken.me/posts.html">Posts</a>
				<a href="https://wklken.me/about.html">About</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<button id="toc-btn" class="hdr-btn desktop-only-ib" title="Table of Contents"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-list"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3" y2="6"></line><line x1="3" y1="12" x2="3" y2="12"></line><line x1="3" y1="18" x2="3" y2="18"></line></svg></button><span class="hdr-social hide-in-mobile"><a href="https://github.com/wklken" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a><a href="https://twitter.com/wklken" target="_blank" rel="noopener me" title="Twitter"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://wklken.me/posts.html">Posts</a></li>
			<li><a href="https://wklken.me/about.html">About</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Sep 29, 2015</span></div>
				<h1>Python 源码阅读 - 垃圾回收机制</h1>
			</header>
			<div class="content">
				<h2 id="概述">概述<a href="#概述" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>无论何种垃圾收集机制, 一般都是两阶段: 垃圾检测和垃圾回收.</p>
<p>在Python中, 大多数对象的生命周期都是通过对象的引用计数来管理的.</p>
<p>问题: 但是存在循环引用的问题: a 引用 b, b 引用 a, 导致每一个对象的引用计数都不为0, 所占用的内存永远不会被回收</p>
<p>要解决循环引用: 必需引入其他垃圾收集技术来打破循环引用. Python中使用了<code>标记-清除</code>以及<code>分代收集</code></p>
<p>即, Python 中垃圾回收机制: 引用计数(主要), 标记清除, 分代收集(辅助)</p>
<h2 id="引用计数">引用计数<a href="#引用计数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>引用计数, 意味着必须在每次分配和释放内存的时候, 加入管理引用计数的动作</p>
<p>引用计数的优点: 最直观最简单, 实时性, 任何内存, 一旦没有指向它的引用, 就会立即被回收</p>
<h3 id="计数存储">计数存储<a href="#计数存储" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>回顾  <a href="http://www.wklken.me/posts/2014/08/05/python-source-object.html">Python 的对象</a></p>
<p><img src="http://www.wklken.me/imgs/python-source/PyObject.png" alt="">￼</p>
<p><img src="http://www.wklken.me/imgs/python-source/PyVarObject.png" alt="">￼</p>
<p>e.g. 引用计数增加以及减少</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="n">getrefcount</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">getrefcount</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">getrefcount</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="k">del</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">getrefcount</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span>
</span></span></code></pre></div><h3 id="计数增加">计数增加<a href="#计数增加" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>增加对象引用计数, refcnt incr</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define Py_INCREF(op) (                         \
</span></span></span><span class="line"><span class="cl"><span class="cp">	_Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA       \
</span></span></span><span class="line"><span class="cl"><span class="cp">	((PyObject*)(op))-&gt;ob_refcnt++)
</span></span></span></code></pre></div><h3 id="计数减少">计数减少<a href="#计数减少" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>减少对象引用计数, refcnt desc</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define _Py_DEC_REFTOTAL        _Py_RefTotal--
</span></span></span><span class="line"><span class="cl"><span class="cp">#define _Py_REF_DEBUG_COMMA     ,
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define Py_DECREF(op)                                   \
</span></span></span><span class="line"><span class="cl"><span class="cp">	do {                                                \
</span></span></span><span class="line"><span class="cl"><span class="cp">		if (_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA       \
</span></span></span><span class="line"><span class="cl"><span class="cp">		--((PyObject*)(op))-&gt;ob_refcnt != 0)            \
</span></span></span><span class="line"><span class="cl"><span class="cp">			_Py_CHECK_REFCNT(op)                        \
</span></span></span><span class="line"><span class="cl"><span class="cp">		else                                            \
</span></span></span><span class="line"><span class="cl"><span class="cp">		_Py_Dealloc((PyObject *)(op));                  \
</span></span></span><span class="line"><span class="cl"><span class="cp">	} while (0)
</span></span></span></code></pre></div><p>即, 发现refcnt变成0的时候, 会调用<code>_Py_Dealloc</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">PyAPI_FUNC</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">_Py_Dealloc</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define _Py_REF_DEBUG_COMMA     ,
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define _Py_Dealloc(op) (                               \
</span></span></span><span class="line"><span class="cl"><span class="cp">	_Py_INC_TPFREES(op) _Py_COUNT_ALLOCS_COMMA          \
</span></span></span><span class="line"><span class="cl"><span class="cp">	(*Py_TYPE(op)-&gt;tp_dealloc)((PyObject *)(op)))
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif </span><span class="cm">/* !Py_TRACE_REFS */</span><span class="cp">
</span></span></span></code></pre></div><p>会调用各自类型的<code>tp_dealloc</code></p>
<p>例如dict</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">PyTypeObject</span> <span class="n">PyDict_Type</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PyType_Type</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;dict&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">sizeof</span><span class="p">(</span><span class="n">PyDictObject</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="n">destructor</span><span class="p">)</span><span class="n">dict_dealloc</span><span class="p">,</span>                   <span class="cm">/* tp_dealloc */</span>
</span></span><span class="line"><span class="cl">    <span class="p">....</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="n">dict_dealloc</span><span class="p">(</span><span class="k">register</span> <span class="n">PyDictObject</span> <span class="o">*</span><span class="n">mp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">.....</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果满足条件, 放入到缓冲池freelist中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">numfree</span> <span class="o">&lt;</span> <span class="n">PyDict_MAXFREELIST</span> <span class="o">&amp;&amp;</span> <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">PyDict_Type</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">free_list</span><span class="p">[</span><span class="n">numfree</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 否则, 调用tp_free
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Py_TYPE</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">((</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">mp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Py_TRASHCAN_SAFE_END</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Python基本类型的<code>tp_dealloc</code>, 通常都会与各自的缓冲池机制相关, 释放会优先放入缓冲池中(对应的分配会优先从缓冲池取). 这个内存分配与回收同缓冲池机制相关</p>
<p>当无法放入缓冲池时, 会调用各自类型的<code>tp_free</code></p>
<p>int, 比较特殊</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// int, 通用整数对象缓冲池机制
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">(</span><span class="n">freefunc</span><span class="p">)</span><span class="n">int_free</span><span class="p">,</span>                         <span class="cm">/* tp_free */</span>
</span></span></code></pre></div><p>string</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">PyObject_Del</span><span class="p">,</span>                               <span class="cm">/* tp_free */</span>
</span></span></code></pre></div><p>dict/tuple/list</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">    <span class="n">PyObject_GC_Del</span><span class="p">,</span>                            <span class="cm">/* tp_free */</span>
</span></span></code></pre></div><p>然后, 我们再回头看, 自定义对象的<code>tp_free</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">PyTypeObject</span> <span class="n">PyType_Type</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PyType_Type</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;type&#34;</span><span class="p">,</span>                                     <span class="cm">/* tp_name */</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">PyObject_GC_Del</span><span class="p">,</span>                            <span class="cm">/* tp_free */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>即, 最终, 当计数变为0, 触发内存回收动作. 涉及函数<code>PyObject_Del</code>和<code>PyObject_GC_Del</code>, 并且, 自定义类以及容器类型(dict/list/tuple/set等)使用的都是后者<code>PyObject_GC_Del</code>.</p>
<h3 id="内存回收-pyobject_del--pyobject_gc_del">内存回收 PyObject_Del / PyObject_GC_Del<a href="#内存回收-pyobject_del--pyobject_gc_del" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>如果引用计数=0:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">1. 放入缓冲池
</span></span><span class="line"><span class="cl">2. 真正销毁, PyObject_Del/PyObject_GC_Del内存操作
</span></span></code></pre></div><p>这两个操作都是进行内存级别的操作</p>
<ul>
<li>PyObject_Del</li>
</ul>
<blockquote>
<p>PyObject_Del(op) releases the memory allocated for an object.  It does not
run a destructor &ndash; it only frees the memory.  PyObject_Free is identical.</p>
</blockquote>
<p>这块删除, <code>PyObject_Free</code> 涉及到了Python底层内存的分配和管理机制, 具体见前面的博文</p>
<ul>
<li>PyObject_GC_Del</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">PyObject_GC_Del</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">g</span> <span class="o">=</span> <span class="n">AS_GC</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Returns true if a given object is tracked
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">IS_TRACKED</span><span class="p">(</span><span class="n">op</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 从跟踪链表中移除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">gc_list_remove</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">PyObject_FREE</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>IS_TRACKED</code> 涉及到标记-清除的机制</p>
<p><code>generations</code> 涉及到了分代回收</p>
<p><code>PyObject_FREE</code>, 则和Python底层内存池机制相关</p>
<h2 id="标记-清除">标记-清除<a href="#标记-清除" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<h3 id="问题-什么对象可能产生循环引用">问题: 什么对象可能产生循环引用?<a href="#问题-什么对象可能产生循环引用" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>只需要关注关注可能产生循环引用的对象</p>
<p>PyIntObject/PyStringObject等不可能</p>
<p>Python中的循环引用总是发生在container对象之间, 所谓containser对象即是内部可持有对其他对象的引用: list/dict/class/instance等等</p>
<p>垃圾收集带来的开销依赖于container对象的数量, 必需跟踪所创建的每一个container对象, 并将这些对象组织到一个集合中.</p>
<h3 id="可收集对象链表">可收集对象链表<a href="#可收集对象链表" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>可收集对象链表: 将需要被收集和跟踪的container, 放到可收集的链表中</p>
<p>任何一个python对象都分为两部分: PyObject_HEAD + 对象本身数据</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* PyObject_HEAD defines the initial segment of every PyObject. */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define PyObject_HEAD                   \
</span></span></span><span class="line"><span class="cl"><span class="cp">    _PyObject_HEAD_EXTRA                \
</span></span></span><span class="line"><span class="cl"><span class="cp">    Py_ssize_t ob_refcnt;               \
</span></span></span><span class="line"><span class="cl"><span class="cp">    struct _typeobject *ob_type;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//----------------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="cp">#define _PyObject_HEAD_EXTRA            \
</span></span></span><span class="line"><span class="cl"><span class="cp">      struct _object *_ob_next;           \
</span></span></span><span class="line"><span class="cl"><span class="cp">      struct _object *_ob_prev;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 双向链表结构, 垃圾回收
</span></span></span></code></pre></div><p>可收集对象链表</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">Modules</span><span class="o">/</span><span class="n">gcmodule</span><span class="p">.</span><span class="n">c</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* GC information is stored BEFORE the object structure. */</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">union</span> <span class="n">_gc_head</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 建立链表需要的前后指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">union</span> <span class="n">_gc_head</span> <span class="o">*</span><span class="n">gc_next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">union</span> <span class="n">_gc_head</span> <span class="o">*</span><span class="n">gc_prev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 在初始化时会被初始化为 GC_UNTRACED
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Py_ssize_t</span> <span class="n">gc_refs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="n">gc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="kt">double</span> <span class="n">dummy</span><span class="p">;</span>  <span class="cm">/* force worst-case alignment */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">PyGC_Head</span><span class="p">;</span>
</span></span></code></pre></div><p>创建container的过程: <code>container对象 = pyGC_Head | PyObject_HEAD | Container Object</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">PyObject</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="nf">_PyObject_GC_New</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="n">_PyObject_GC_Malloc</span><span class="p">(</span><span class="n">_PyObject_SIZE</span><span class="p">(</span><span class="n">tp</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">op</span> <span class="o">=</span> <span class="n">PyObject_INIT</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">tp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">op</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">=&gt;</span> <span class="n">_PyObject_GC_Malloc</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#define _PyGC_REFS_UNTRACKED                    (-2)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define GC_UNTRACKED                    _PyGC_REFS_UNTRACKED
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">PyObject</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="n">_PyObject_GC_Malloc</span><span class="p">(</span><span class="n">size_t</span> <span class="n">basicsize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">g</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">basicsize</span> <span class="o">&gt;</span> <span class="n">PY_SSIZE_T_MAX</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PyGC_Head</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">PyErr_NoMemory</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 为 对象本身+PyGC_Head申请内存, 注意分配的size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyGC_Head</span> <span class="o">*</span><span class="p">)</span><span class="n">PyObject_MALLOC</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="k">sizeof</span><span class="p">(</span><span class="n">PyGC_Head</span><span class="p">)</span> <span class="o">+</span> <span class="n">basicsize</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">g</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">PyErr_NoMemory</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化 GC_UNTRACED
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">g</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">=</span> <span class="n">GC_UNTRACKED</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">count</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* number of allocated GC objects */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果大于阈值, 执行分代回收
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">threshold</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="n">enabled</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">threshold</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="o">!</span><span class="n">collecting</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="o">!</span><span class="n">PyErr_Occurred</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">collecting</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">collect_generations</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">collecting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">op</span> <span class="o">=</span> <span class="n">FROM_GC</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">op</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="pyobject_head-and-pygc_head">PyObject_HEAD and PyGC_HEAD<a href="#pyobject_head-and-pygc_head" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>注意, <code>FROM_GC</code>和<code>AS_GC</code>用于 <code>PyObject_HEAD &lt;=&gt; PyGC_HEAD</code>地址相互转换</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// =&gt; Modules/gcmodule.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Get an object&#39;s GC head */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define AS_GC(o) ((PyGC_Head *)(o)-1)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Get the object given the GC head */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define FROM_GC(g) ((PyObject *)(((PyGC_Head *)g)+1))
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// =&gt; objimpl.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define _Py_AS_GC(o) ((PyGC_Head *)(o)-1)
</span></span></span></code></pre></div><h3 id="问题-什么时候将container放到这个对象链表中">问题: 什么时候将container放到这个对象链表中<a href="#问题-什么时候将container放到这个对象链表中" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>e.g list</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// =&gt; listobject.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">PyObject</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="nf">PyList_New</span><span class="p">(</span><span class="n">Py_ssize_t</span> <span class="n">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">PyListObject</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">op</span> <span class="o">=</span> <span class="n">PyObject_GC_New</span><span class="p">(</span><span class="n">PyListObject</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">PyList_Type</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">_PyObject_GC_TRACK</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">op</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// =&gt;  _PyObject_GC_TRACK
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// objimpl.h
</span></span></span><span class="line"><span class="cl"><span class="c1">// 加入到可收集对象链表中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define _PyObject_GC_TRACK(o) do { \
</span></span></span><span class="line"><span class="cl"><span class="cp">    PyGC_Head *g = _Py_AS_GC(o); \
</span></span></span><span class="line"><span class="cl"><span class="cp">    if (g-&gt;gc.gc_refs != _PyGC_REFS_UNTRACKED) \
</span></span></span><span class="line"><span class="cl"><span class="cp">        Py_FatalError(&#34;GC object already tracked&#34;); \
</span></span></span><span class="line"><span class="cl"><span class="cp">    g-&gt;gc.gc_refs = _PyGC_REFS_REACHABLE; \
</span></span></span><span class="line"><span class="cl"><span class="cp">    g-&gt;gc.gc_next = _PyGC_generation0; \
</span></span></span><span class="line"><span class="cl"><span class="cp">    g-&gt;gc.gc_prev = _PyGC_generation0-&gt;gc.gc_prev; \
</span></span></span><span class="line"><span class="cl"><span class="cp">    g-&gt;gc.gc_prev-&gt;gc.gc_next = g; \
</span></span></span><span class="line"><span class="cl"><span class="cp">    _PyGC_generation0-&gt;gc.gc_prev = g; \
</span></span></span><span class="line"><span class="cl"><span class="cp">    } while (0);
</span></span></span></code></pre></div><h3 id="问题-什么时候将container从这个对象链表中摘除">问题: 什么时候将container从这个对象链表中摘除<a href="#问题-什么时候将container从这个对象链表中摘除" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// Objects/listobject.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">list_dealloc</span><span class="p">(</span><span class="n">PyListObject</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Py_ssize_t</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">PyObject_GC_UnTrack</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">.....</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// =&gt; PyObject_GC_UnTrack =&gt; _PyObject_GC_UNTRACK
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 对象销毁的时候
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define _PyObject_GC_UNTRACK(o) do { \
</span></span></span><span class="line"><span class="cl"><span class="cp">    PyGC_Head *g = _Py_AS_GC(o); \
</span></span></span><span class="line"><span class="cl"><span class="cp">    assert(g-&gt;gc.gc_refs != _PyGC_REFS_UNTRACKED); \
</span></span></span><span class="line"><span class="cl"><span class="cp">    g-&gt;gc.gc_refs = _PyGC_REFS_UNTRACKED; \
</span></span></span><span class="line"><span class="cl"><span class="cp">    g-&gt;gc.gc_prev-&gt;gc.gc_next = g-&gt;gc.gc_next; \
</span></span></span><span class="line"><span class="cl"><span class="cp">    g-&gt;gc.gc_next-&gt;gc.gc_prev = g-&gt;gc.gc_prev; \
</span></span></span><span class="line"><span class="cl"><span class="cp">    g-&gt;gc.gc_next = NULL; \
</span></span></span><span class="line"><span class="cl"><span class="cp">    } while (0);
</span></span></span></code></pre></div><h3 id="问题-如何进行标记-清除">问题: 如何进行标记-清除<a href="#问题-如何进行标记-清除" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>现在, 我们得到了一个链表</p>
<p>Python将自己的垃圾收集限制在这个链表上, 循环引用一定发生在这个链表的一群独享之间.</p>
<h4 id="0-概览">0. 概览<a href="#0-概览" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p><code>_PyObject_GC_Malloc</code> 分配内存时, 发现超过阈值, 此时, 会触发gc, <code>collect_generations</code>
然后调用<code>collect</code>, <code>collect</code>包含标记-清除逻辑</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">gcmodule</span><span class="p">.</span><span class="n">c</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* This is the main function.  Read this to understand how the
</span></span></span><span class="line"><span class="cl"><span class="cm">   * collection process works. */</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="n">Py_ssize_t</span>
</span></span><span class="line"><span class="cl">  <span class="n">collect</span><span class="p">(</span><span class="kt">int</span> <span class="n">generation</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 第1步: 将所有比 当前代 年轻的代中的对象 都放到 当前代 的对象链表中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="cm">/* merge younger generations with one we are currently collecting */</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">generation</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">gc_list_merge</span><span class="p">(</span><span class="n">GEN_HEAD</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">GEN_HEAD</span><span class="p">(</span><span class="n">generation</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 第2步
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">update_refs</span><span class="p">(</span><span class="n">young</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 第3步
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">subtract_refs</span><span class="p">(</span><span class="n">young</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 第4步
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">gc_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unreachable</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">move_unreachable</span><span class="p">(</span><span class="n">young</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unreachable</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 第5步
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="cm">/* Move reachable objects to next generation. */</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">young</span> <span class="o">!=</span> <span class="n">old</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="n">generation</span> <span class="o">==</span> <span class="n">NUM_GENERATIONS</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="n">long_lived_pending</span> <span class="o">+=</span> <span class="n">gc_list_size</span><span class="p">(</span><span class="n">young</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="n">gc_list_merge</span><span class="p">(</span><span class="n">young</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="cm">/* We only untrack dicts in full collections, to avoid quadratic
</span></span></span><span class="line"><span class="cl"><span class="cm">             dict build-up. See issue #14775. */</span>
</span></span><span class="line"><span class="cl">          <span class="n">untrack_dicts</span><span class="p">(</span><span class="n">young</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="n">long_lived_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="n">long_lived_total</span> <span class="o">=</span> <span class="n">gc_list_size</span><span class="p">(</span><span class="n">young</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 第6步
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">delete_garbage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unreachable</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><h4 id="1-第一步--gc_list_merge">1. 第一步:  gc_list_merge<a href="#1-第一步--gc_list_merge" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>将所有比 当前代 年轻的代中的对象 都放到 当前代 的对象链表中</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// =&gt; gc_list_merge
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 执行拷贝而已
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/* append list `from` onto list `to`; `from` becomes an empty list */</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">gc_list_merge</span><span class="p">(</span><span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">to</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">from</span> <span class="o">!=</span> <span class="n">to</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gc_list_is_empty</span><span class="p">(</span><span class="n">from</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">tail</span> <span class="o">=</span> <span class="n">to</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_prev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">tail</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">tail</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_prev</span> <span class="o">=</span> <span class="n">tail</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">to</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_prev</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_prev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">to</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_prev</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span> <span class="o">=</span> <span class="n">to</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 清空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">gc_list_init</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">=&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="n">gc_list_init</span><span class="p">(</span><span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">list</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_prev</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">list</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>即, 此刻, 所有待进行处理的对象都集中在同一个链表中</p>
<p>处理,</p>
<p>其逻辑是, 要去除循环引用, 得到有效引用计数</p>
<p>有效引用计数: 将循环引用的计数去除, 最终得到的 =&gt; 将环从引用中摘除, 各自引用计数数值-1</p>
<p>实际操作, 并不要直接修改对象的 ob_refcnt, 而是修改其副本, <code>PyGC_Head</code>中的<code>gc.gc_ref</code></p>
<h4 id="2-第二步-update_refs">2. 第二步: update_refs<a href="#2-第二步-update_refs" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>遍历对象链表, 将每个对象的gc.gc_ref值设置为ob_refcnt</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// =&gt; gcmodule.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">update_refs</span><span class="p">(</span><span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">containers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">gc</span> <span class="o">=</span> <span class="n">containers</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(;</span> <span class="n">gc</span> <span class="o">!=</span> <span class="n">containers</span><span class="p">;</span> <span class="n">gc</span> <span class="o">=</span> <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">assert</span><span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">==</span> <span class="n">GC_REACHABLE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">=</span> <span class="n">Py_REFCNT</span><span class="p">(</span><span class="n">FROM_GC</span><span class="p">(</span><span class="n">gc</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* Python&#39;s cyclic gc should never see an incoming refcount
</span></span></span><span class="line"><span class="cl"><span class="cm">         * of 0:  if something decref&#39;ed to 0, it should have been
</span></span></span><span class="line"><span class="cl"><span class="cm">         * deallocated immediately at that time.
</span></span></span><span class="line"><span class="cl"><span class="cm">         * Possible cause (if the assert triggers):  a tp_dealloc
</span></span></span><span class="line"><span class="cl"><span class="cm">         * routine left a gc-aware object tracked during its teardown
</span></span></span><span class="line"><span class="cl"><span class="cm">         * phase, and did something-- or allowed something to happen --
</span></span></span><span class="line"><span class="cl"><span class="cm">         * that called back into Python.  gc can trigger then, and may
</span></span></span><span class="line"><span class="cl"><span class="cm">         * see the still-tracked dying object.  Before this assert
</span></span></span><span class="line"><span class="cl"><span class="cm">         * was added, such mistakes went on to allow gc to try to
</span></span></span><span class="line"><span class="cl"><span class="cm">         * delete the object again.  In a debug build, that caused
</span></span></span><span class="line"><span class="cl"><span class="cm">         * a mysterious segfault, when _Py_ForgetReference tried
</span></span></span><span class="line"><span class="cl"><span class="cm">         * to remove the object from the doubly-linked list of all
</span></span></span><span class="line"><span class="cl"><span class="cm">         * objects a second time.  In a release build, an actual
</span></span></span><span class="line"><span class="cl"><span class="cm">         * double deallocation occurred, which leads to corruption
</span></span></span><span class="line"><span class="cl"><span class="cm">         * of the allocator&#39;s internal bookkeeping pointers.  That&#39;s
</span></span></span><span class="line"><span class="cl"><span class="cm">         * so serious that maybe this should be a release-build
</span></span></span><span class="line"><span class="cl"><span class="cm">         * check instead of an assert?
</span></span></span><span class="line"><span class="cl"><span class="cm">         */</span>
</span></span><span class="line"><span class="cl">        <span class="n">assert</span><span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="3-第三步-计算有效引用计数">3. 第三步: 计算有效引用计数<a href="#3-第三步-计算有效引用计数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="cm">/* A traversal callback for subtract_refs. */</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">  <span class="nf">visit_decref</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">assert</span><span class="p">(</span><span class="n">op</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 判断op指向的对象是否是被垃圾收集监控的, 对象的type对象中有Py_TPFLAGS_HAVE_GC符号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="n">PyObject_IS_GC</span><span class="p">(</span><span class="n">op</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">gc</span> <span class="o">=</span> <span class="n">AS_GC</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="cm">/* We&#39;re only interested in gc_refs for objects in the
</span></span></span><span class="line"><span class="cl"><span class="cm">           * generation being collected, which can be recognized
</span></span></span><span class="line"><span class="cl"><span class="cm">           * because only they have positive gc_refs.
</span></span></span><span class="line"><span class="cl"><span class="cm">           */</span>
</span></span><span class="line"><span class="cl">          <span class="n">assert</span><span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* else refcount was too small */</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">              <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span><span class="o">--</span><span class="p">;</span>  <span class="c1">// -1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Subtract internal references from gc_refs.  After this, gc_refs is &gt;= 0
</span></span></span><span class="line"><span class="cl"><span class="cm">   * for all objects in containers, and is GC_REACHABLE for all tracked gc
</span></span></span><span class="line"><span class="cl"><span class="cm">   * objects not in containers.  The ones with gc_refs &gt; 0 are directly
</span></span></span><span class="line"><span class="cl"><span class="cm">   * reachable from outside containers, and so can&#39;t be collected.
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl">  <span class="nf">subtract_refs</span><span class="p">(</span><span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">containers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">traverseproc</span> <span class="n">traverse</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">gc</span> <span class="o">=</span> <span class="n">containers</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 遍历链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">for</span> <span class="p">(;</span> <span class="n">gc</span> <span class="o">!=</span> <span class="n">containers</span><span class="p">;</span> <span class="n">gc</span><span class="o">=</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 与特定的类型相关, 得到类型对应的traverse函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">traverse</span> <span class="o">=</span> <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">FROM_GC</span><span class="p">(</span><span class="n">gc</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">tp_traverse</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">traverse</span><span class="p">(</span><span class="n">FROM_GC</span><span class="p">(</span><span class="n">gc</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                         <span class="p">(</span><span class="n">visitproc</span><span class="p">)</span><span class="n">visit_decref</span><span class="p">,</span> <span class="c1">// 回调形式传入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                         <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><p>我们可以看看dictobject的traverse函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">  <span class="nf">dict_traverse</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="n">visitproc</span> <span class="n">visit</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">Py_ssize_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">PyObject</span> <span class="o">*</span><span class="n">pk</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">PyObject</span> <span class="o">*</span><span class="n">pv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// 遍历所有键和值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">while</span> <span class="p">(</span><span class="n">PyDict_Next</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pv</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">Py_VISIT</span><span class="p">(</span><span class="n">pk</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="n">Py_VISIT</span><span class="p">(</span><span class="n">pv</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><p>逻辑大概是: 遍历容器对象里面的所有对象, 通过<code>visit_decref</code>将这些对象的引用计数都-1,</p>
<p>最终, 遍历完链表之后, 整个可收集对象链表中所有container对象之间的循环引用都被去掉了</p>
<h4 id="4-第四步-垃圾标记">4. 第四步: 垃圾标记<a href="#4-第四步-垃圾标记" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p><code>move_unreachable</code>, 将可收集对象链表中, 根据有效引用计数 不等于0(root对象) 和 等于0(非root对象, 垃圾, 可回收), 一分为二</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"> <span class="cm">/* Move the unreachable objects from young to unreachable.  After this,
</span></span></span><span class="line"><span class="cl"><span class="cm">   * all objects in young have gc_refs = GC_REACHABLE, and all objects in
</span></span></span><span class="line"><span class="cl"><span class="cm">   * unreachable have gc_refs = GC_TENTATIVELY_UNREACHABLE.  All tracked
</span></span></span><span class="line"><span class="cl"><span class="cm">   * gc objects not in young or unreachable still have gc_refs = GC_REACHABLE.
</span></span></span><span class="line"><span class="cl"><span class="cm">   * All objects in young after this are directly or indirectly reachable
</span></span></span><span class="line"><span class="cl"><span class="cm">   * from outside the original young; and all objects in unreachable are
</span></span></span><span class="line"><span class="cl"><span class="cm">   * not.
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl">  <span class="nf">move_unreachable</span><span class="p">(</span><span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">young</span><span class="p">,</span> <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">unreachable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">gc</span> <span class="o">=</span> <span class="n">young</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="cm">/* Invariants:  all objects &#34;to the left&#34; of us in young have gc_refs
</span></span></span><span class="line"><span class="cl"><span class="cm">       * = GC_REACHABLE, and are indeed reachable (directly or indirectly)
</span></span></span><span class="line"><span class="cl"><span class="cm">       * from outside the young list as it was at entry.  All other objects
</span></span></span><span class="line"><span class="cl"><span class="cm">       * from the original young &#34;to the left&#34; of us are in unreachable now,
</span></span></span><span class="line"><span class="cl"><span class="cm">       * and have gc_refs = GC_TENTATIVELY_UNREACHABLE.  All objects to the
</span></span></span><span class="line"><span class="cl"><span class="cm">       * left of us in &#39;young&#39; now have been scanned, and no objects here
</span></span></span><span class="line"><span class="cl"><span class="cm">       * or to the right have been scanned yet.
</span></span></span><span class="line"><span class="cl"><span class="cm">       */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">while</span> <span class="p">(</span><span class="n">gc</span> <span class="o">!=</span> <span class="n">young</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="c1">// 对于root object,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="k">if</span> <span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="cm">/* gc is definitely reachable from outside the
</span></span></span><span class="line"><span class="cl"><span class="cm">               * original &#39;young&#39;.  Mark it as such, and traverse
</span></span></span><span class="line"><span class="cl"><span class="cm">               * its pointers to find any other objects that may
</span></span></span><span class="line"><span class="cl"><span class="cm">               * be directly reachable from it.  Note that the
</span></span></span><span class="line"><span class="cl"><span class="cm">               * call to tp_traverse may append objects to young,
</span></span></span><span class="line"><span class="cl"><span class="cm">               * so we have to wait until it returns to determine
</span></span></span><span class="line"><span class="cl"><span class="cm">               * the next object to visit.
</span></span></span><span class="line"><span class="cl"><span class="cm">               */</span>
</span></span><span class="line"><span class="cl">              <span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="n">FROM_GC</span><span class="p">(</span><span class="n">gc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">              <span class="n">traverseproc</span> <span class="n">traverse</span> <span class="o">=</span> <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">op</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_traverse</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">              <span class="n">assert</span><span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">              <span class="c1">// 设置其gc-&gt;gc.gc_refs = GC_REACHABLE
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">=</span> <span class="n">GC_REACHABLE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">              <span class="c1">// 注意这里逻辑, visit_reachable, 意图是?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">traverse</span><span class="p">(</span><span class="n">op</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                              <span class="p">(</span><span class="n">visitproc</span><span class="p">)</span><span class="n">visit_reachable</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                              <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">young</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">              <span class="n">next</span> <span class="o">=</span> <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">              <span class="k">if</span> <span class="p">(</span><span class="n">PyTuple_CheckExact</span><span class="p">(</span><span class="n">op</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="n">_PyTuple_MaybeUntrack</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">              <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 有效引用计数=0, 非root对象, 移动到unreachable链表中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="cm">/* This *may* be unreachable.  To make progress,
</span></span></span><span class="line"><span class="cl"><span class="cm">               * assume it is.  gc isn&#39;t directly reachable from
</span></span></span><span class="line"><span class="cl"><span class="cm">               * any object we&#39;ve already traversed, but may be
</span></span></span><span class="line"><span class="cl"><span class="cm">               * reachable from an object we haven&#39;t gotten to yet.
</span></span></span><span class="line"><span class="cl"><span class="cm">               * visit_reachable will eventually move gc back into
</span></span></span><span class="line"><span class="cl"><span class="cm">               * young if that&#39;s so, and we&#39;ll see it again.
</span></span></span><span class="line"><span class="cl"><span class="cm">               */</span>
</span></span><span class="line"><span class="cl">              <span class="n">next</span> <span class="o">=</span> <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">              <span class="n">gc_list_move</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span> <span class="n">unreachable</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">              <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">=</span> <span class="n">GC_TENTATIVELY_UNREACHABLE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="n">gc</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><h4 id="5-第五步-将存活对象放入下一代">5. 第五步: 将存活对象放入下一代<a href="#5-第五步-将存活对象放入下一代" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">      <span class="cm">/* Move reachable objects to next generation. */</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">young</span> <span class="o">!=</span> <span class="n">old</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="n">generation</span> <span class="o">==</span> <span class="n">NUM_GENERATIONS</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="n">long_lived_pending</span> <span class="o">+=</span> <span class="n">gc_list_size</span><span class="p">(</span><span class="n">young</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="n">gc_list_merge</span><span class="p">(</span><span class="n">young</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="cm">/* We only untrack dicts in full collections, to avoid quadratic
</span></span></span><span class="line"><span class="cl"><span class="cm">             dict build-up. See issue #14775. */</span>
</span></span><span class="line"><span class="cl">          <span class="n">untrack_dicts</span><span class="p">(</span><span class="n">young</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="n">long_lived_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="n">long_lived_total</span> <span class="o">=</span> <span class="n">gc_list_size</span><span class="p">(</span><span class="n">young</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span></code></pre></div><h4 id="6-第六步-执行回收">6. 第六步: 执行回收<a href="#6-第六步-执行回收" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">gcmoudle</span><span class="p">.</span><span class="n">c</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">  <span class="n">gc_list_is_empty</span><span class="p">(</span><span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span> <span class="o">==</span> <span class="n">list</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Break reference cycles by clearing the containers involved.  This is
</span></span></span><span class="line"><span class="cl"><span class="cm">   * tricky business as the lists can be changing and we don&#39;t know which
</span></span></span><span class="line"><span class="cl"><span class="cm">   * objects may be freed.  It is possible I screwed something up here.
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl">  <span class="n">delete_garbage</span><span class="p">(</span><span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">collectable</span><span class="p">,</span> <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">old</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">inquiry</span> <span class="n">clear</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// 遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">gc_list_is_empty</span><span class="p">(</span><span class="n">collectable</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">gc</span> <span class="o">=</span> <span class="n">collectable</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 得到对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="n">FROM_GC</span><span class="p">(</span><span class="n">gc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="n">assert</span><span class="p">(</span><span class="n">IS_TENTATIVELY_UNREACHABLE</span><span class="p">(</span><span class="n">op</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="n">DEBUG_SAVEALL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="n">PyList_Append</span><span class="p">(</span><span class="n">garbage</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="c1">// 清引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="k">if</span> <span class="p">((</span><span class="n">clear</span> <span class="o">=</span> <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">op</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_clear</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                  <span class="c1">// 这个操作会调整container对象中每个引用所有对象的引用计数, 从而完成打破循环的最终目标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="n">clear</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                  <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">              <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="c1">// 重新送回到reachable链表.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="c1">// 原因: 在进行clear动作, 如果成功, 会把自己从垃圾收集机制维护的链表中摘除, 由于某些原因, 对象可能在clear的时候, 没有成功完成必要动作, 还不能被销毁, 所以放回去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="k">if</span> <span class="p">(</span><span class="n">collectable</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span> <span class="o">==</span> <span class="n">gc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="cm">/* object is still alive, move it, it may die later */</span>
</span></span><span class="line"><span class="cl">              <span class="n">gc_list_move</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">              <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">=</span> <span class="n">GC_REACHABLE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">=&gt;</span> <span class="err">来看下</span><span class="p">,</span> <span class="n">list的clear</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="n">list_clear</span><span class="p">(</span><span class="n">PyListObject</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Py_ssize_t</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">PyObject</span> <span class="o">**</span><span class="n">item</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">ob_item</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">item</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* Because XDECREF can recursively invoke operations on
</span></span></span><span class="line"><span class="cl"><span class="cm">           this list, we make it empty first. */</span>
</span></span><span class="line"><span class="cl">        <span class="n">i</span> <span class="o">=</span> <span class="n">Py_SIZE</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">Py_SIZE</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">a</span><span class="o">-&gt;</span><span class="n">ob_item</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">a</span><span class="o">-&gt;</span><span class="n">allocated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 减引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">PyMem_FREE</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Never fails; the return value can be ignored.
</span></span></span><span class="line"><span class="cl"><span class="cm">       Note that there is no guarantee that the list is actually empty
</span></span></span><span class="line"><span class="cl"><span class="cm">       at this point, because XDECREF may have populated it again! */</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// e.g. 处理list3, 调用其list_clear, 减少list4的引用计数, list4.ob_refcnt=0, 引发对象销毁, 调用list4的list_dealloc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="n">list_dealloc</span><span class="p">(</span><span class="n">PyListObject</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Py_ssize_t</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">PyObject_GC_UnTrack</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>  <span class="c1">//  从可收集对象链表中去除, 会影响到list4所引用所有对象的引用计数, =&gt; list3.refcnt=0, list3的销毁动作也被触发
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">Py_TRASHCAN_SAFE_BEGIN</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">ob_item</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* Do it backwards, for Christian Tismer.
</span></span></span><span class="line"><span class="cl"><span class="cm">           There&#39;s a simple test case where somehow this reduces
</span></span></span><span class="line"><span class="cl"><span class="cm">           thrashing when a *very* large list is created and
</span></span></span><span class="line"><span class="cl"><span class="cm">           immediately deleted. */</span>
</span></span><span class="line"><span class="cl">        <span class="n">i</span> <span class="o">=</span> <span class="n">Py_SIZE</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">ob_item</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">PyMem_FREE</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">ob_item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">numfree</span> <span class="o">&lt;</span> <span class="n">PyList_MAXFREELIST</span> <span class="o">&amp;&amp;</span> <span class="n">PyList_CheckExact</span><span class="p">(</span><span class="n">op</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="n">free_list</span><span class="p">[</span><span class="n">numfree</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Py_TYPE</span><span class="p">(</span><span class="n">op</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">((</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">op</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Py_TRASHCAN_SAFE_END</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="7-gc逻辑">7. gc逻辑<a href="#7-gc逻辑" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<pre tabindex="0"><code>分配内存
-&gt; 发现超过阈值了
-&gt; 触发垃圾回收
-&gt; 将所有可收集对象链表放到一起
-&gt; 遍历, 计算有效引用计数
-&gt; 分成 有效引用计数=0 和 有效引用计数 &gt; 0 两个集合
-&gt; 大于0的, 放入到更老一代
-&gt; =0的, 执行回收
-&gt; 回收遍历容器内的各个元素, 减掉对应元素引用计数(破掉循环引用)
-&gt; 执行-1的逻辑, 若发现对象引用计数=0, 触发内存回收
-&gt; python底层内存管理机制回收内存
</code></pre><h2 id="分代回收">分代回收<a href="#分代回收" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>分代收集: 以空间换时间</p>
<p>思想: 将系统中的所有内存块根据其存货的时间划分为不同的集合, 每个集合就成为一个&quot;代&quot;, 垃圾收集的频率随着&quot;代&quot;的存活时间的增大而减小(活得越长的对象, 就越不可能是垃圾, 就应该减少去收集的频率)</p>
<p>Python中, 引入了分代收集, 总共三个&quot;代&quot;. Python 中, 一个代就是一个链表, 所有属于同一&quot;代&quot;的内存块都链接在同一个链表中</p>
<h3 id="表头数据结构">表头数据结构<a href="#表头数据结构" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">gcmodule</span><span class="p">.</span><span class="n">c</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">gc_generation</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">PyGC_Head</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">int</span> <span class="n">threshold</span><span class="p">;</span> <span class="cm">/* collection threshold */</span>  <span class="c1">// 阈值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kt">int</span> <span class="n">count</span><span class="p">;</span> <span class="cm">/* count of allocations or collections of younger
</span></span></span><span class="line"><span class="cl"><span class="cm">                    generations */</span>    <span class="c1">// 实时个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">};</span>
</span></span></code></pre></div><h3 id="三个代的定义">三个代的定义<a href="#三个代的定义" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="cp">#define NUM_GENERATIONS 3
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="cp">#define GEN_HEAD(n) (&amp;generations[n].head)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">//  三代都放到这个数组中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="cm">/* linked lists of container objects */</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="k">struct</span> <span class="n">gc_generation</span> <span class="n">generations</span><span class="p">[</span><span class="n">NUM_GENERATIONS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* PyGC_Head,                               threshold,      count */</span>
</span></span><span class="line"><span class="cl">      <span class="p">{{{</span><span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">}},</span>           <span class="mi">700</span><span class="p">,</span>            <span class="mi">0</span><span class="p">},</span>    <span class="c1">//700个container, 超过立即触发垃圾回收机制
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">{{{</span><span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">}},</span>           <span class="mi">10</span><span class="p">,</span>             <span class="mi">0</span><span class="p">},</span>    <span class="c1">// 10个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">{{{</span><span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">}},</span>           <span class="mi">10</span><span class="p">,</span>             <span class="mi">0</span><span class="p">},</span>    <span class="c1">// 10个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">_PyGC_generation0</span> <span class="o">=</span> <span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span></code></pre></div><h3 id="超过阈值-触发垃圾回收">超过阈值, 触发垃圾回收<a href="#超过阈值-触发垃圾回收" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"> <span class="n">PyObject</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl">  <span class="nf">_PyObject_GC_Malloc</span><span class="p">(</span><span class="n">size_t</span> <span class="n">basicsize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 执行分配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">....</span>
</span></span><span class="line"><span class="cl">      <span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">count</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* number of allocated GC objects */</span>  <span class="c1">//增加一个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">threshold</span> <span class="o">&amp;&amp;</span> <span class="c1">// 发现大于预支了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">enabled</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">          <span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">threshold</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">          <span class="o">!</span><span class="n">collecting</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">          <span class="o">!</span><span class="n">PyErr_Occurred</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">          <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="n">collecting</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">              <span class="n">collect_generations</span><span class="p">();</span>  <span class="c1">//  执行收集
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="n">collecting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="n">op</span> <span class="o">=</span> <span class="n">FROM_GC</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">op</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">=&gt;</span> <span class="n">collect_generations</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="n">Py_ssize_t</span>
</span></span><span class="line"><span class="cl">  <span class="n">collect_generations</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">Py_ssize_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="cm">/* Find the oldest generation (highest numbered) where the count
</span></span></span><span class="line"><span class="cl"><span class="cm">       * exceeds the threshold.  Objects in the that generation and
</span></span></span><span class="line"><span class="cl"><span class="cm">       * generations younger than it will be collected. */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// 从最老的一代, 开始回收
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">NUM_GENERATIONS</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 遍历所有generation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="k">if</span> <span class="p">(</span><span class="n">generations</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">generations</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">threshold</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 如果超过了阈值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="cm">/* Avoid quadratic performance degradation in number
</span></span></span><span class="line"><span class="cl"><span class="cm">                 of tracked objects. See comments at the beginning
</span></span></span><span class="line"><span class="cl"><span class="cm">                 of this file, and issue #4074.
</span></span></span><span class="line"><span class="cl"><span class="cm">              */</span>
</span></span><span class="line"><span class="cl">              <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">NUM_GENERATIONS</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">                  <span class="o">&amp;&amp;</span> <span class="n">long_lived_pending</span> <span class="o">&lt;</span> <span class="n">long_lived_total</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                  <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">              <span class="n">n</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 执行收集
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="k">break</span><span class="p">;</span>  <span class="c1">// notice: break了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><h2 id="python-中的gc模块">Python 中的gc模块<a href="#python-中的gc模块" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>gc模块, 提供了观察和手动使用gc的接口</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">gc</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">gc</span><span class="o">.</span><span class="n">set_debug</span><span class="p">(</span><span class="n">gc</span><span class="o">.</span><span class="n">DEBUG_STATS</span> <span class="o">|</span> <span class="n">gc</span><span class="o">.</span><span class="n">DEBUG_LEAK</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
</span></span></code></pre></div><p>注意<code>__del__</code>给gc带来的影响</p>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://wklken.me/tags/python">python</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>5007 Words</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2015-09-29 00:00 &#43;0000</p>
			</footer>
		</article>
		<aside id="toc">
			<div class="toc-title">Table of Contents</div>
			<nav id="TableOfContents">
  <ul>
    <li><a href="#概述">概述</a></li>
    <li><a href="#引用计数">引用计数</a>
      <ul>
        <li><a href="#计数存储">计数存储</a></li>
        <li><a href="#计数增加">计数增加</a></li>
        <li><a href="#计数减少">计数减少</a></li>
        <li><a href="#内存回收-pyobject_del--pyobject_gc_del">内存回收 PyObject_Del / PyObject_GC_Del</a></li>
      </ul>
    </li>
    <li><a href="#标记-清除">标记-清除</a>
      <ul>
        <li><a href="#问题-什么对象可能产生循环引用">问题: 什么对象可能产生循环引用?</a></li>
        <li><a href="#可收集对象链表">可收集对象链表</a></li>
        <li><a href="#pyobject_head-and-pygc_head">PyObject_HEAD and PyGC_HEAD</a></li>
        <li><a href="#问题-什么时候将container放到这个对象链表中">问题: 什么时候将container放到这个对象链表中</a></li>
        <li><a href="#问题-什么时候将container从这个对象链表中摘除">问题: 什么时候将container从这个对象链表中摘除</a></li>
        <li><a href="#问题-如何进行标记-清除">问题: 如何进行标记-清除</a></li>
      </ul>
    </li>
    <li><a href="#分代回收">分代回收</a>
      <ul>
        <li><a href="#表头数据结构">表头数据结构</a></li>
        <li><a href="#三个代的定义">三个代的定义</a></li>
        <li><a href="#超过阈值-触发垃圾回收">超过阈值, 触发垃圾回收</a></li>
      </ul>
    </li>
    <li><a href="#python-中的gc模块">Python 中的gc模块</a></li>
  </ul>
</nav>
		</aside>
		<div class="post-nav thin">
			<a class="next-post" href="https://wklken.me/posts/2015/11/08/summary-13-some-points.html">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;Newer</span><br><span>这段时间的一些想法</span>
			</a>
			<a class="prev-post" href="https://wklken.me/posts/2015/09/26/why-i-keep-blogging.html">
				<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>我为什么要写博客</span>
			</a>
		</div>
		<div id="comments" class="thin">
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="https://wklken.me/js/md5.min.js"></script>
<script>
  const gitalk = new Gitalk({
    clientID: '549d325e74a413f1b56a',
    clientSecret: '086a83faacf152cc3f4079f002058716879e9688',
    repo: 'wklken.github.io',
    owner: 'wklken',
    admin: ['wklken'],
    id: md5(location.pathname), 
    distractionFreeMode: false 
  });
  (function() {
    if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
      document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
      return;
    }
    gitalk.render('gitalk-container');
  })();
</script>

</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2024 <a href="https://wklken.me">wklken</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://wklken.me/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>



	<script src="https://wklken.me/js/bundle.min.580988ed2982bcbb74a1773c7abea97b43e4c43b9324e10cda0813ec6ec4bb67.js" integrity="sha256-WAmI7SmCvLt0oXc8er6pe0PkxDuTJOEM2ggT7G7Eu2c=" crossorigin="anonymous"></script>
	
<script async src="https://www.googletagmanager.com/gtag/js?id=G-2GRCMEVXLQ"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-2GRCMEVXLQ', { 'anonymize_ip': false });
}
</script>



</body>

</html>
