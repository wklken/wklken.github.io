<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>python on WKLKEN THINKING</title>
    <link>https://wklken.me/tags/python.html</link>
    <description>Recent content in python on WKLKEN THINKING</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Tue, 24 May 2022 23:00:00 +0800</lastBuildDate><atom:link href="https://wklken.me/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Better Code: 异常时, 该提示用户哪些信息?</title>
      <link>https://wklken.me/posts/2022/05/24/better-code-3-better-error-message.html</link>
      <pubDate>Tue, 24 May 2022 23:00:00 +0800</pubDate>
      
      <guid>https://wklken.me/posts/2022/05/24/better-code-3-better-error-message.html</guid>
      <description>接前一篇 Better Code: 更好的异常日志打印 做 toB 一个非常高的成本是, 用户的环境/网络/数据等, 可能跟你预期的差异很大, 再加上沟通相对困难(涉及三方/四方,</description>
    </item>
    
    <item>
      <title>Better Code: 更好的异常日志打印</title>
      <link>https://wklken.me/posts/2022/01/16/better-code-2-logging.html</link>
      <pubDate>Sun, 16 Jan 2022 00:04:00 +0800</pubDate>
      
      <guid>https://wklken.me/posts/2022/01/16/better-code-2-logging.html</guid>
      <description>维护一个 N 年前的Python项目, 协助排查问题时发现, 原先的日志打印真真一言难尽 导致了一个问题, 同负责的运维 A 沟通, A 与其对接的甲方沟通&amp;h</description>
    </item>
    
    <item>
      <title>Better Code: 使用property</title>
      <link>https://wklken.me/posts/2019/10/07/better-code-1-use-property.html</link>
      <pubDate>Mon, 07 Oct 2019 08:00:00 +0800</pubDate>
      
      <guid>https://wklken.me/posts/2019/10/07/better-code-1-use-property.html</guid>
      <description>introduction @property 是Python的一个内置函数, 通过property, 我们可以获得更好的可读性/可维护性 屏蔽细节, 对于外部使用者, 不需要知道更多的细节! 可</description>
    </item>
    
    <item>
      <title>Django项目重构小结</title>
      <link>https://wklken.me/posts/2018/12/06/python-refactor-django-project.html</link>
      <pubDate>Thu, 06 Dec 2018 08:00:00 +0800</pubDate>
      
      <guid>https://wklken.me/posts/2018/12/06/python-refactor-django-project.html</guid>
      <description>由于历史原因, 项目组中存在很多历史悠久的项目. 这类项目, 有着一些共同特征: 历史悠久, 几度经手, 缺乏文档, 维护困难, 模块不合理, 代码坏味道, 版</description>
    </item>
    
    <item>
      <title>Python 代码规范小结</title>
      <link>https://wklken.me/posts/2016/11/03/python-code-style.html</link>
      <pubDate>Thu, 03 Nov 2016 08:00:00 +0800</pubDate>
      
      <guid>https://wklken.me/posts/2016/11/03/python-code-style.html</guid>
      <description>code review中一些小结, 还没来得及加例子, 简要记录, 供参考 law 一: 一切都与复杂度有关 二: 代码应当易于理解 对人: &amp;ldquo;好程序员”应当竭</description>
    </item>
    
    <item>
      <title>[分享]Python源码剖析-数据结构</title>
      <link>https://wklken.me/posts/2016/03/01/python-source-datastructure.html</link>
      <pubDate>Tue, 01 Mar 2016 08:00:00 +0800</pubDate>
      
      <guid>https://wklken.me/posts/2016/03/01/python-source-datastructure.html</guid>
      <description></description>
    </item>
    
    <item>
      <title>一些Centos Python生产环境的部署命令</title>
      <link>https://wklken.me/posts/2016/02/18/python-env-in-centos.html</link>
      <pubDate>Thu, 18 Feb 2016 08:00:00 +0800</pubDate>
      
      <guid>https://wklken.me/posts/2016/02/18/python-env-in-centos.html</guid>
      <description>Just notes 拿到一台干净的centos之后, 初始化Python环境, 一些命令和问题记录而已 可以搞成脚本自动初始化, 当然, 用docker更好 基础环境 1.</description>
    </item>
    
    <item>
      <title>Python 源码阅读 - 垃圾回收机制</title>
      <link>https://wklken.me/posts/2015/09/29/python-source-gc.html</link>
      <pubDate>Tue, 29 Sep 2015 08:00:00 +0800</pubDate>
      
      <guid>https://wklken.me/posts/2015/09/29/python-source-gc.html</guid>
      <description>概述 无论何种垃圾收集机制, 一般都是两阶段: 垃圾检测和垃圾回收. 在Python中, 大多数对象的生命周期都是通过对象的引用计数来管理的. 问题: 但</description>
    </item>
    
    <item>
      <title>Python源码阅读-闭包的实现</title>
      <link>https://wklken.me/posts/2015/09/04/python-source-closure.html</link>
      <pubDate>Fri, 04 Sep 2015 08:00:00 +0800</pubDate>
      
      <guid>https://wklken.me/posts/2015/09/04/python-source-closure.html</guid>
      <description>闭包 e.g. def add(x): def do_add(value): return x + value return do_add add_5 = add(5) print add_5(1) # 6 print add_5(2) # 7 需要回答, 什么是闭包, CPython底层是如何实现的? PyCodeObject typedef struct { PyObject_HEAD int co_argcount; /* #arguments, except *args */ int co_nlocals; /* #local variables */ int</description>
    </item>
    
    <item>
      <title>Python源码阅读-内存管理机制(二)</title>
      <link>https://wklken.me/posts/2015/08/29/python-source-memory-2.html</link>
      <pubDate>Sat, 29 Aug 2015 20:54:00 +0800</pubDate>
      
      <guid>https://wklken.me/posts/2015/08/29/python-source-memory-2.html</guid>
      <description>Python 的内存分配策略 arena arena: 多个pool聚合的结果 arena size pool的大小默认值位4KB arena的大小默认值256KB, 能放置 256/4=64 个pool obmallo</description>
    </item>
    
  </channel>
</rss>
