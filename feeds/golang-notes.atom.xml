<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>wklken's blog</title><link href="http://www.wklken.me/" rel="alternate"></link><link href="http://www.wklken.me/feeds/golang-notes.atom.xml" rel="self"></link><id>http://www.wklken.me/</id><updated>2014-03-09T06:00:00+08:00</updated><entry><title>Golang笔记-06-struct</title><link href="http://www.wklken.me/posts/2014/03/09/06-struct.html" rel="alternate"></link><updated>2014-03-09T06:00:00+08:00</updated><author><name>wklken</name></author><id>tag:www.wklken.me,2014-03-09:posts/2014/03/09/06-struct.html</id><summary type="html">&lt;h3 id="struct"&gt;struct&lt;/h3&gt;
&lt;p&gt;struct，一组字段的集合，类似其他语言的class&lt;/p&gt;
&lt;p&gt;放弃了大量包括继承在内的面向对象特性，只保留了组合(composition)这个最基础的特性&lt;/p&gt;
&lt;h4 id="1"&gt;1.声明及初始化&lt;/h4&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;type person struct {
    name string
    age  int
}

//初始化

func main() {
    var P person

    P.name = "tom"
    P.age = 25
    fmt.Println(P.name)

    P1 := person{"Tom1", 25}
    fmt.Println(P1.name)

    P2 := person{age: 24, name: "Tom"}
    fmt.Println(P2.name)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="2struct"&gt;2.struct的匿名字段(继承)&lt;/h4&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;type Human struct {
    name string
    age int
    weight int
}

tyep Student struct {
    Human //匿名字段，默认Student包含了Human的所有字段
    speciality string
}

mark := Student(Human{"mark", 25, 120}, "Computer Science")

mark.name
mark.age
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;能够实现字段继承，当字段名重复的时候，优先取外层的,可以通过指定struct名还决定取哪个&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;mark.Human = Human{"a", 55, 220}
mark.Human.age -= 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;struct不仅可以使用struct作为匿名字段，自定义类型、内置类型都可以作为匿名字段,而且可以在相应字段上做函数操作&lt;/p&gt;
&lt;h4 id="3method"&gt;3.method&lt;/h4&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;type Rect struct {
    x, y float64
    width, height float64
}

//method

Reciver 默认以值传递，而非引用传递，还可以是指针
指针作为Receiver会对实例对象的内容发生操作，而普通类型作为Receiver仅仅是以副本作为操作对象，而不对原实例对象发生操作

func (r ReciverType) funcName(params) (results) {

}

如果一个method的receiver是*T，调用时，可以传递一个T类型的实例变量V，而不必用&amp;amp;V去调用这个method

func (r *Rect) Area() float64 {
    return r.width * r.height
}

func (b *Box) SetColor(c Color) {
    b.color = c
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="4method_1"&gt;4.method继承和重写&lt;/h3&gt;
&lt;p&gt;采用组合的方式实现继承&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;type Human struct {
    name string
}

type Student struct {
    Human
    School string
}

func (h *Human) SayHi() {
    fmt.Println(h.name)
}

//则Student和Employee的实例可以调用
func main() {
    h := Human{name: "human"}
    fmt.Print(h.name)
    h.SayHi()

    s := Student{Human{"student"}}
    s.SayHi()

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还可以进行方法重写&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;funct (e *Student) SayHi() {
    e.Human.SayHi()
    fmt.Println(e.School)
}
&lt;/pre&gt;&lt;/div&gt;</summary><category term="golang"></category></entry><entry><title>Golang笔记-05-函数</title><link href="http://www.wklken.me/posts/2014/03/02/05-func.html" rel="alternate"></link><updated>2014-03-02T05:00:00+08:00</updated><author><name>wklken</name></author><id>tag:www.wklken.me,2014-03-02:posts/2014/03/02/05-func.html</id><summary type="html">&lt;h3 id="_1"&gt;函数&lt;/h3&gt;
&lt;p&gt;Go语言里面的核心设计，通过关键字func来声明&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;func funcName(input type1, input2 type2) (output1 type1, output2 type2) {
    //logical code
    return value1, value2
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="_2"&gt;基本语法&lt;/h3&gt;
&lt;p&gt;1.语法&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;//一般函数
func func_name(a int) {
    println(a)
}

//多参数，无返回值
func func_name(a, b int, c string) {
    println(a, b, c)
}

//单个返回值
func func_name(a, b int) int { //同类型，可以省略  a, b int
    return a + b
}

//多个返回值
func func_name(a, b int) (c int, err error) {  //返回值还可以是   (int, error)
    return a+b, nil
}

func SumAndProduct(A, B int) (int, int) {
    return A+B, A*B
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.说明：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;关键字func声明
可以有一个或多个参数，每个参数后面带有类型,通过","分隔函数可以返回多个值
返回值声明，可以只声明类型
    如果没有返回值，可以省略最后的返回信息
    如果有返回值，必须在外层添加return


Go函数不支持嵌套(nested),重载（overload）和默认参数(default parameters)
支持：
    1.无需声明原型
    2.不定长度变参
    3.多返回值
    4.命名返回值参数
    5.匿名函数
    6.闭包

注意：
    函数使用func开头，左大括号不能另起一行
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;小写字母开头的函数指在本包内可见，大写字母开头的函数才能被其他包调用&lt;/p&gt;
&lt;h3 id="_3"&gt;多返回值及命名返回参数&lt;/h3&gt;
&lt;p&gt;可以像python那样返回多个结果，只是非tuple&lt;/p&gt;
&lt;p&gt;对于不想要的返回值，可以扔垃圾桶_&lt;/p&gt;
&lt;p&gt;如果用命名返回参数，return语句可以为空。return 不为空，返回值顺序是return的顺序而非在函数头声明的顺序&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;package main

func change(a, b int) (x, y int) {
    x = a + 100
    y = b + 100

    return   //101, 102
    //return x, y  //同上
    //return y, x  //102, 101
}

func main(){
    a := 1
    b := 2
    c, d := change(a, b)
    println(c, d)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果命名返回参数被代码块中的同名变量覆盖了，就必须使用显式return返回结果&lt;/p&gt;
&lt;p&gt;不需要强制命名返回值，但是命名后的返回值可以让代码更加清晰，可读性更强&lt;/p&gt;
&lt;h3 id="_4"&gt;参数传递:传值与传指针&lt;/h3&gt;
&lt;p&gt;指针, Go保留指针，用"."而非"-&amp;gt;"操作指针目标对象成员
操作符&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&amp;amp; 取变量地址
* 通过指针间接访问目标函数

func add1(a int) int {
    a = a + 1
    return a
}

x := 3
x1 := add1(x)
x //3
x1 //4
传值，x1的值没有改变

func add2(a *int) int {
    *a = *a + 1
    return *a
}
x := 3
x1 := add2(&amp;amp;x)
x // 4
x1 // 4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;传指针多个函数能操作同一个对象&lt;/p&gt;
&lt;p&gt;传指针比较轻量级(8byte)，只是传内存地址，我饿们可以用指针来传递体积大的结构体&lt;/p&gt;
&lt;p&gt;Go语言中，string,slice,map这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传指针&lt;/p&gt;
&lt;p&gt;注意，若函数需要改变 slice长度，仍需要取地址传指针&lt;/p&gt;
&lt;h3 id="_5"&gt;参数传递:可变参数&lt;/h3&gt;
&lt;p&gt;变参本质上就是一个slice，且必须是最后一个形参&lt;/p&gt;
&lt;p&gt;将slice传递给变参函数时，注意用&amp;hellip;展开，否则会被当做dang单个参数处理，和python类似&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;package main

func sum(s string, args ...int)  {
    var x int
    for _, n := range args {
        x += n
    }
    println(s, x)
}
func main(){
   sum("1+2+3=", 1, 2, 3)

   x := []int{0,1,2,3,4}
   sum("0+1+2+3=", x[:4]...)
}

...type类型只能作为函数的参数类型存在，并且是最后一个参数
本质上是一个数组切片，即[]type
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;任意类型的不定参数&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;func Printf(format string, args ...interface{}) {
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="_6"&gt;匿名函数&lt;/h3&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;f := func(x,y int) int {
    return x + y
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="_7"&gt;函数作为值、类型&lt;/h3&gt;
&lt;p&gt;在Go语言中，函数也是一种变量，可以通过type来定义它,它的类型就是所有拥有相同的参数，相同的返回值&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;语法
type typeName func (input1 inputType1, input2 inputType2 [, ....]) (result1 resultType1 [,....])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用法e.g.1&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;type testInt func(int) bool //声明了一个函数类型

func filter(slice []int, f testInt) []int {
    var result []int
    for _, value := range slice {
        if f(value) {
            result = append(result, value)
        }
    }
}

func isOdd(integer int) bool {
    if integer % 2 == 0 {
        return false
    }
    return true
}

filter(a, isOdd)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种用法，在写接口的时候非常有用&lt;/p&gt;
&lt;p&gt;用法e.g.2&lt;/p&gt;
&lt;p&gt;可以定义函数类型，也可以将函数作为值进行传递(默认值nil)&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;package main

//定义函数类型callback
type callback func(s string)

//定义一个函数，可以接收另一个函数作为参数
// sum为参数名称， func(int, int) int为参数类型
func test(a, b int, sum func(int, int) int)  {
    println( sum(a,b) )
}

func main(){
    //演示1
    var cb callback
    cb = func(s string) {
        println(s)
    }
    cb("hello world")

    //演示2
    test(1, 2, func(a, b int) int {return a + b})
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;hello world
3
&lt;/pre&gt;&lt;/div&gt;</summary><category term="golang"></category></entry><entry><title>Golang笔记-04-array/slice/map</title><link href="http://www.wklken.me/posts/2014/03/02/04-data-structure.html" rel="alternate"></link><updated>2014-03-02T04:00:00+08:00</updated><author><name>wklken</name></author><id>tag:www.wklken.me,2014-03-02:posts/2014/03/02/04-data-structure.html</id><summary type="html">&lt;h3 id="array"&gt;一.Array&lt;/h3&gt;
&lt;p&gt;在Go语言中，数组是一个值类型(value type)&lt;/p&gt;
&lt;p&gt;所有的值类型变量在赋值和作为参数传递时都将产生一个复制动作&lt;/p&gt;
&lt;p&gt;如果作为函数的参数类型，则在函数调用时参数发生数据复制，在函数体中无法修改传入数组的内容&lt;/p&gt;
&lt;p&gt;数组相等用 = != 比较，不能用 &amp;lt; &amp;gt;&lt;/p&gt;
&lt;h4 id="1"&gt;1.声明&amp;amp;赋值&lt;/h4&gt;
&lt;p&gt;初始化&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;语法&lt;/span&gt;
&lt;span class="x"&gt;var VarName [n]type     // n&amp;gt;=0&lt;/span&gt;

&lt;span class="x"&gt;e.g.&lt;/span&gt;
&lt;span class="x"&gt;var a [5]int //[0 0 0 0 0]&lt;/span&gt;
&lt;span class="x"&gt;var c [2][3]int //二维&lt;/span&gt;

&lt;span class="x"&gt;var b int = [5]int{1,2,3,4,5} //声明并初始化&lt;/span&gt;

&lt;span class="x"&gt;a := [3]int{1,2,3}&lt;/span&gt;
&lt;span class="x"&gt;b := [10]int{1,2,3} //前三个元素，其他为0&lt;/span&gt;
&lt;span class="x"&gt;c := [20]int{19:1} //第20个元素初始化为1，其他默认0&lt;/span&gt;
&lt;span class="x"&gt;d := [...]int{4,5,6} //自动计算长度&lt;/span&gt;
&lt;span class="x"&gt;e := [...]int{0:1, 1:2, 19:3} //自动推断&lt;/span&gt;


&lt;span class="x"&gt;二维数组&lt;/span&gt;
&lt;span class="x"&gt;doubleArray := [2][4]int{[4]int{1,2,3,4}, [4]int{5,6,7,8}}&lt;/span&gt;
&lt;span class="x"&gt;easyArray := [2][4]int&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;&lt;span class="o"&gt;},&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;&lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;多维 [...][n] 前者可推断，但是后者必须显示赋值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;数组的长度是该数组类型的一个内置常量&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;arrLength := len(arr)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，数组长度也是类型的一部分，因此不同长度数组为不同类型(内置常量)&lt;/p&gt;
&lt;p&gt;即[3]int和[4]int是不同类型，并且数组不能改变长度&lt;/p&gt;
&lt;p&gt;数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该数组的副本(一次复制操作)，而不是它的指针，如果要传入指针，使用slice&lt;/p&gt;
&lt;h4 id="2"&gt;2.元素访问&lt;/h4&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nt"&gt;for&lt;/span&gt; &lt;span class="nt"&gt;i&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="nt"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nt"&gt;len&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;array&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="nt"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;fmt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nt"&gt;for&lt;/span&gt; &lt;span class="nt"&gt;i&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;v&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nt"&gt;range&lt;/span&gt; &lt;span class="nt"&gt;array&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;fmt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以用new创建数组&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;p := new([10]int)
返回一个指向数组的指针
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意区分&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;指向数组的指针
a := [100]int{}
var p *[100]int = &amp;amp;a

指针数组
x, y = 1, 2
a := [...]*int{&amp;amp;x, &amp;amp;y}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="slice_1"&gt;二.Slice&lt;/h3&gt;
&lt;p&gt;数组切片就像一个指向数组的指针，但更复杂，实际上它拥有自己的数据结构，而不仅仅是指针(指向原生数组的指针 + 数组切片中元素个数 + 数组切片已分配的存储空间)&lt;/p&gt;
&lt;p&gt;一个引用类型，总是指向一个底层array，声明可以向array一样，只是不需要长度&lt;/p&gt;
&lt;p&gt;slice就像一个结构体，包含三个元素&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;一个指针，指向数组中slice指定的开始位置
长度，即slice的长度
最大长度，也就是slice开始位置到数组的最后位置的长度
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="1_1"&gt;1.声明&amp;amp;赋值&lt;/h4&gt;
&lt;p&gt;通过array创建&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;var myArray [10]int = [10]int{1,2,3,4,5,6,7,8,9,10}
var mySlice []int = myArray[:5]

a := [5]int{1,2,3,4,5}
b := a[2:4]
b := a[:4]
b := a[2:]

从数组或已存在的slice再次声明
var ar [10]byte {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}

var a, b []byte
a = ar[2:5]
b = ar[3:5]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接创建&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;myslice1 := make([]int, 5)
myslice2 := make([]int, 5, 10) //初始个数5，预留10个元素的存储空间
myslice3 := []int{1,2,3,4,5}
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="2_1"&gt;2.元素访问&lt;/h4&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nt"&gt;for&lt;/span&gt; &lt;span class="nt"&gt;i&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="nt"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;len&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;mySlice&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="nt"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;fmt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mySlice&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nt"&gt;for&lt;/span&gt; &lt;span class="nt"&gt;i&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;v&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nt"&gt;range&lt;/span&gt; &lt;span class="nt"&gt;mySlice&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;fmt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="3"&gt;3.其他操作&lt;/h4&gt;
&lt;p&gt;大小和容量&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;len获取slice的长度
cap获取slice的最大容量
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;动态增减元素&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;append想slice里面追加一个或者多个元素，然后返回一个和slice一样类型的slice

//append
mySlice = append(mySlice, 1, 2, 3) //增加三个元素
mySlice = append(mySlice, mySlice2) //增加另一个

注意，append会改变slice所引用的数组的内容，从而影响到引用统一数组的其他slice，
     但当slice中没有剩余空间，此时动态分配新的数组空间返回的slice数组指针将指向这个空间，
     而原数组的内容将保持不变，其他引用此数组的slice不受影响(坑，可能引入bug)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;内容复制&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;copy，从源slice的src中复制到目标dst，并且返回复制元素的个数
copy(dst, source) //会按短的个数复制

slice1 := []int{1,2,3,4,5}
slice2 := []int{5,4,3}

copy(slice2, slice1) //复制slice1前三个 1 -&amp;gt; 2
copy(slice1, slice2) //复制slice2的前三个 2 -&amp;gt; 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;切片&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;默认开始位置0，ar[:n]等价于ar[0:n]
第二个序列默认是数组长度 ar[n:] 等价于 ar[n:len(ar)]
从一个数组直接获取slice，可以是ar[:]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;slice是引用类型，所以当改变其中元素的时候，其他的所有引用都会改变&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;aSlice = array[3:7]
bslice = aSlice[:3]
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="map_1"&gt;三.Map&lt;/h3&gt;
&lt;p&gt;Python中字典的概念&lt;/p&gt;
&lt;p&gt;map是无序的,长度不固定，内置的len可以用于map,可以方便的修改&lt;/p&gt;
&lt;h4 id="1_2"&gt;1.声明&amp;amp;赋值&lt;/h4&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;map[keyType]valueType

var m map[string] PersonInfo
m = make(map[string] personInfo[, 100])

var numbers map[string]int
or
numbers := make(map[string]int)
numbers["one"] = 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;初始化一个字典&lt;/p&gt;
&lt;h4 id="2_2"&gt;2.元素访问&lt;/h4&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;rating := map[string]float32 {"c":5, "Go":4.5}

csharpRating, ok := rating["C#"]
if ok {
    fmt.Println("get the value")
} else{
    fmt.Println("error")
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="3_1"&gt;3.基本操作&lt;/h4&gt;
&lt;p&gt;赋值&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;m["1234"] = PersonInfo{}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;删除&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;delete(m, "1234")
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="_2"&gt;四.其他&lt;/h3&gt;
&lt;p&gt;make和new操作&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;make用于内建类型(map,slice,channel) 的内存分配。

new用于各种类型的内存分配
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;new本质上和其他语言中同名函数一样, new(T)分配了零值填充的T类型的内存空间，并返回其地址，即一个*T类型的值
即，返回一个指针，指向新分配的类型T的零值&lt;/p&gt;
&lt;p&gt;make(T, args)，只能创建slice,map,channel，并返回一个有初始值（非零值）的T类型，而不是*T。
本质来讲，导致这三个类型有所不同的原因是，指向数据结构的引用在使用前必须被初始化&lt;/p&gt;</summary><category term="golang"></category></entry><entry><title>Golang笔记-03-控制流</title><link href="http://www.wklken.me/posts/2014/03/02/03-control-flow.html" rel="alternate"></link><updated>2014-03-02T03:00:00+08:00</updated><author><name>wklken</name></author><id>tag:www.wklken.me,2014-03-02:posts/2014/03/02/03-control-flow.html</id><summary type="html">&lt;p&gt;控制结构分为： 条件+选择+循环&lt;/p&gt;
&lt;h3 id="if"&gt;IF&lt;/h3&gt;
&lt;p&gt;1.说明&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;条件表达式没有括号
支持一个初始化表达式（可以是多变量初始化语句）
初始化语句中定义的都是只能在block级别中使用的局部变量，不能在block之外使用
左大括号必须和条件语句在同一行(必须与if/else在同一行)
go没有三元运算符

if判断语句条件不需要括号
在判断语句里卖弄允许声明一个变量，其作用域只在逻辑块内，其他地方不起作用
花括号一定存在，且必须与if/else在同一行
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.语法&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;//基本
if a &amp;gt; 0 {  //无括号
     dosomething()
} else if a == 0 { //必须用花括号
     doothertings()
} else {
     donothing()
}

//单行模式
if a &amp;gt; 0 { a += 100 } else { a -= 100 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.示例&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nt"&gt;package&lt;/span&gt; &lt;span class="nt"&gt;main&lt;/span&gt;

&lt;span class="nt"&gt;func&lt;/span&gt; &lt;span class="nt"&gt;main&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="m"&gt;10&lt;/span&gt;

    &lt;span class="n"&gt;if&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="m"&gt;100&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="nt"&gt;else&lt;/span&gt; &lt;span class="nt"&gt;if&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nt"&gt;0&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="nt"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="m"&gt;100&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nt"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

    &lt;span class="nt"&gt;b&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nt"&gt;101&lt;/span&gt;
    &lt;span class="nt"&gt;if&lt;/span&gt; &lt;span class="nt"&gt;b&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;0&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="m"&gt;100&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="nt"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="m"&gt;100&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nt"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;b&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;支持一个初始化语句&lt;/span&gt;
&lt;span class="nt"&gt;if&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="nt"&gt;1&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;10&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;允许在条件之前执行一个简单语句，由此语句定义的变量作用域仅在&lt;/span&gt;&lt;span class="n"&gt;if&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;else范围内&lt;/span&gt;
    &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nt"&gt;if&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;b&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nt"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;2&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nt"&gt;b&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nt"&gt;10&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nt"&gt;if&lt;/span&gt; &lt;span class="nt"&gt;x&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nt"&gt;computedValue&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt; &lt;span class="nt"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;10&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="nt"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.结果&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;110
201
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，在有返回值的函数中，不允许将&amp;ldquo;最终的&amp;rdquo;return语句放到if ... else ... 结构中，否则编译失败&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;func example(x int) int {
    if x == 0 {
        return 5
    } else {
        return x
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="for"&gt;FOR&lt;/h3&gt;
&lt;p&gt;for是go的"while", 只支持for关键字.有三种形式&lt;/p&gt;
&lt;p&gt;1.语法&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nt"&gt;for&lt;/span&gt; &lt;span class="nt"&gt;init&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;condition&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;post&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;init不支持逗号&lt;/span&gt;&lt;span class="err"&gt;，只能平行赋值&lt;/span&gt;
    &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;condition每次循环开始都会检查&lt;/span&gt;&lt;span class="err"&gt;，不建议在里面使用函数，建议用计算好的变量&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="err"&gt;常量代替&lt;/span&gt;
    &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;post后面必须跟花括号&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="err"&gt;每轮循环结束的时候调用&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nt"&gt;for&lt;/span&gt; &lt;span class="nt"&gt;i&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="nt"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;10&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nt"&gt;-----------------------------&lt;/span&gt;

&lt;span class="nt"&gt;for&lt;/span&gt; &lt;span class="nt"&gt;condition&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;dosomething&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nt"&gt;i&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="nt"&gt;1&lt;/span&gt;
&lt;span class="nt"&gt;for&lt;/span&gt; &lt;span class="nt"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;10&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nt"&gt;-----------------------------&lt;/span&gt;

&lt;span class="nt"&gt;for&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;无限循环&lt;/span&gt;
    &lt;span class="n"&gt;dosomething&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nt"&gt;for&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;
    &lt;span class="n"&gt;if&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="m"&gt;10&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;break&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;

&lt;span class="nt"&gt;-----------------------------&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.说明&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nt"&gt;初始化和步进表达式可以使多个值&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;&lt;span class="nt"&gt;必须使用平行赋值&lt;/span&gt;
    &lt;span class="nt"&gt;i&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;j&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="nt"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;len&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="nt"&gt;-1&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;j&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;i&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;j&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nt"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nt"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;j-1&lt;/span&gt;
&lt;span class="nt"&gt;b&lt;/span&gt;&lt;span class="nc"&gt;.每次循环都会重新检查条件表达式&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.示例&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nt"&gt;package&lt;/span&gt; &lt;span class="nt"&gt;main&lt;/span&gt;

&lt;span class="nt"&gt;func&lt;/span&gt; &lt;span class="nt"&gt;main&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="s2"&gt;"abcd"&lt;/span&gt;
    &lt;span class="n"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得到：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;97
98
99
100
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.配合range&lt;/p&gt;
&lt;p&gt;for循环和保留字range一起使用，完成迭代器iterator操作&lt;/p&gt;
&lt;p&gt;string, array, slice, map, channel都可以用range进行迭代器操作&lt;/p&gt;
&lt;p&gt;range返回序号和值，若是不想要，可以用_&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  for i, c := range "abc" {
      fmt.Printf("s[%d] = %c\n", i, c)
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得到&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  s[0] = a
  s[1] = b
  s[2] = c
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="switch"&gt;SWITCH&lt;/h3&gt;
&lt;p&gt;python里面没有&lt;/p&gt;
&lt;p&gt;1.语法&lt;/p&gt;
&lt;p&gt;支持初始化表达式&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nt"&gt;switch&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="nt"&gt;5&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;默认&lt;/span&gt;&lt;span class="n"&gt;break&lt;/span&gt;&lt;span class="err"&gt;，匹配成功后不会自动向下执行其他&lt;/span&gt;&lt;span class="n"&gt;case&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="err"&gt;而是跳出整个&lt;/span&gt;&lt;span class="n"&gt;switch&lt;/span&gt;
    &lt;span class="n"&gt;case&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;         &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;普通&lt;/span&gt;
        &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;case&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;      &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;多个分支，逗号分隔&lt;/span&gt;
        &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;case&lt;/span&gt; &lt;span class="m"&gt;100&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;       &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;什么都不做&lt;/span&gt;
    &lt;span class="n"&gt;case&lt;/span&gt; &lt;span class="m"&gt;5&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;fallthrough&lt;/span&gt;   &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;进入后面的&lt;/span&gt;&lt;span class="n"&gt;case&lt;/span&gt; &lt;span class="err"&gt;进行处理，而不是跳出&lt;/span&gt;&lt;span class="nb"&gt;block&lt;/span&gt;
    &lt;span class="nb"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;默认&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nt"&gt;注意&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="nt"&gt;不需要break来明确退出一个case&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="nt"&gt;一旦条件符合&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="nt"&gt;自动终止&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;除非使用fallthough&lt;/span&gt;

&lt;span class="nt"&gt;--------------&lt;/span&gt;

&lt;span class="nt"&gt;可以不带表达式&lt;/span&gt;
&lt;span class="nt"&gt;switch&lt;/span&gt; &lt;span class="nt"&gt;sExpr&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;case&lt;/span&gt; &lt;span class="n"&gt;expr1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;sExpr和expr1必须类型一致&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="err"&gt;不限制为常量或者证书，可以用任何类型或表达式&lt;/span&gt;
            &lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nt"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;case&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;Num&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;Num&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;fmt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"3"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;几种形式:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nt"&gt;1&lt;/span&gt;
&lt;span class="nt"&gt;switch&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;case&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nt"&gt;1&lt;/span&gt;
&lt;span class="nt"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;case&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="o"&gt;....&lt;/span&gt;
    &lt;span class="n"&gt;case&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="o"&gt;....&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nt"&gt;switch&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="nt"&gt;1&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;case&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="n"&gt;case&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.替代if...else if&amp;hellip;else&amp;hellip;&lt;/p&gt;
&lt;p&gt;不指定switch 条件表达式(没有条件表达式，在case语句中有)，或者直接为true&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nt"&gt;5&lt;/span&gt;
  &lt;span class="nt"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;     &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;两句可合并位&lt;/span&gt; &lt;span class="n"&gt;switch&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="m"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;case&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
          &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"a"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="n"&gt;case&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
          &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"b"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nb"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
          &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"c"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="goto-break-continue"&gt;goto break continue&lt;/h3&gt;
&lt;p&gt;均可配合标签使用(标签区分大小写，若声明了没有使用会导致编译错误)&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;break/continue可配合标签用于多重循环跳出
goto是调整执行位置，与其他两个执行结果并不相同
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.goto&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;支持函数内部goto跳转

请善用

必须跳转到当前函数内定义的标签,标签名大小写敏感

func myFunc() {
    i := 0
Here:
    println(i)
    i++
    goto Here
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.continue&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;进入下一次循环
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.break&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;终止循环

for index := 10; index &amp;gt; 0; index -- {
    if index == 5 {
        break //continue
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;package main
func main(){
    a := 1
    LABEL1:
        println("inc a=", a)
        a += 1

    LABEL2:
        //println("here")

    for ; a &amp;lt; 6; {
        println(a)
        if a == 3 {
            a += 1
            continue LABEL2
        }
        if a == 5 {
            break
        }
        goto LABEL1
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;inc a= 1
2
inc a= 2
3
4
inc a= 4
5
&lt;/pre&gt;&lt;/div&gt;</summary><category term="golang"></category></entry><entry><title>Golang笔记-02-类型、变量、常量</title><link href="http://www.wklken.me/posts/2014/03/02/02-type-var-const.html" rel="alternate"></link><updated>2014-03-02T02:00:00+08:00</updated><author><name>wklken</name></author><id>tag:www.wklken.me,2014-03-02:posts/2014/03/02/02-type-var-const.html</id><summary type="html">&lt;h3 id="_1"&gt;基本类型&lt;/h3&gt;
&lt;p&gt;1.基本类型列表&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;类型        长度     说明
bool         1      true/false,默认false, 不能把非0值当做true(不用数字代表true/false)
byte         1      uint8 别名
rune         4      int32别名。 代表一个unicode code point
int/unit            一来所运行的平台，32bit/64bit
int8/uint8   1     -128 ~ 127; 0 ~ 255
int16/uint16 2     -32768 ~ 32767; 0 ~ 65535
int32/uint32 4     -21亿 ~ 21亿， 0 ~ 42亿
int64/uint64 8

float32      4     精确到7位小数,相当于c的float
float64      8     精确到15位小数,相当于c的double

complex64    8
complex128   16

uintptr            足够保存指针的32位、64位整数,指针(可以存指针的整数型)
array              值类型,数组
struct             值类型,结构体
string             值类型,字符串类型，常用
slice              引用类型,切片
map                引用类型,字典
channel            引用类型,通道
interface          接口类型,接口
function           函数类型,函数
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.类型转换&lt;/p&gt;
&lt;p&gt;不支持隐式类型转换，必须进行显式类型转换&lt;/p&gt;
&lt;p&gt;转换只发生在两种互相兼容的类型之间: 各类int不允许相互赋值或操作，不然会在编译时报错&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&amp;lt;type&amp;gt;(expression)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;package&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="s2"&gt;"fmt"&lt;/span&gt;

&lt;span class="n"&gt;func&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x1234&lt;/span&gt;
    &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1234.56&lt;/span&gt;
    &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;256&lt;/span&gt;

    &lt;span class="n"&gt;fmt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;%x&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;uint8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;fmt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;fmt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;%f&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;float64&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;34
1234
256.000000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.类型别名&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;type t_str string
var b t_str = "a str"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.类型默认值&lt;/p&gt;
&lt;p&gt;声明不赋值，类型零值，非空值,而是声明后的默认值&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;bool&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;
&lt;span class="n"&gt;integers&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;floats&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;
&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
&lt;span class="n"&gt;pointers&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;functions&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;interfaces&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;slices&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;channels&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;maps&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;nil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="_2"&gt;保留字&lt;/h3&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;break      case   chan     const        continue
default    defer  else     fallthrough  for
func       go     goto     if           import
interface  map    package  range        return
select     struct switch   type         var
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="_3"&gt;变量&lt;/h3&gt;
&lt;p&gt;1.变量声明&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;//第一种，指定变量类型，声明后若不赋值，使用默认值
var v_name v_type
v_name = value

//第二种，根据值自行判定变量类型
var v_name = value

//第三种，省略var, 注意 :=左侧的变量不应该是已经声明过的，否则会导致编译错误.
v_name := value

e.g.
var a int = 10
var b = 10
c : = 10
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;package main
var a = 1234
var b string = "hello"
var c bool

func main(){
    println(a, b, c)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;1234 hello false
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.多变量声明：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;//类型相同多个变量, 非全局变量
var vname1, vname2, vname3 type
vname1, vname2, vname3 = v1, v2, v3

var vname1, vname2, vname3 = v1, v2, v3 //和python很像,不需要显示声明类型，自动推断

vname1, vname2, vname3 := v1, v2, v3 //出现在:=左侧的变量不应该是已经被声明过的，否则会导致编译错误


//类型不同多个变量, 全局变量, 局部变量不能使用这种方式
var (
    vname1 v_type1
    vname2 v_type2
)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;package main

var x, y int
var (  //这种只能出现在全局变量中，函数体内不支持
    a int
    b bool
)

var c, d int = 1, 2
var e, f = 123, "hello"

//这种不带声明格式的只能在函数体中出现
//g, h := 123, "hello"

func main(){
    g, h := 123, "hello"
    println(x, y, a, b, c, d, e, f, g, h)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;0 0 0 false 1 2 123 hello 123 hello
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;A.多变量赋值时，将先行计算所有左侧变量的值，再进行赋值

    i := 0
    i, l[i] = 1, 2
    //get i = 1， l[0] = 2


    sc[0], sc[0] = 1, 2
    //get sc[0] = 2

B.垃圾桶_

    func test()(int, string) {
        return 123, "abc"
    }

    a, _ := test()

C.已声明但是没有使用的变量会在编译阶段报错，较Python 更为严格
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="_4"&gt;常量&lt;/h3&gt;
&lt;p&gt;常量可以是字符，字符串，布尔或数字&lt;/p&gt;
&lt;p&gt;常量赋值是编译期的行为&lt;/p&gt;
&lt;p&gt;1.常量声明&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;在编译阶段就能确定下来的值,在运行时无法改变该值
常量可以定义为数值、布尔值或字符串等类型

const constantName = value
const Pi float32 = 3.1415926

const c_name [type] = value
const c_name1, c_name2 = value1, value2
const (
    c_name1 = vluae1
    c_name2 = value2
)

=右侧，必须为常量或常量表达式，如果使用到了函数，必须为内置函数（编译期行为）

const i = 10000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="err"&gt;常量必须是编译期能确定的&lt;/span&gt;&lt;span class="n"&gt;Number&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;char&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nb"&gt;complex&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;String和bool&lt;/span&gt;

&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="err"&gt;在定义常量数组时，如果不提供初始化值，则表示与上行常量类型，值，完全相同&lt;/span&gt;

    &lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"abc"&lt;/span&gt;
        &lt;span class="n"&gt;b&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;则&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"abc"&lt;/span&gt;

&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="err"&gt;常量可以用&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;cap&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;unsafe&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Sizeof&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="err"&gt;常量计算表达式的值&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;  &lt;span class="err"&gt;常量表达式中，函数必须是内置函数，否则编译不过&lt;/span&gt;

    &lt;span class="n"&gt;package&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;

    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="s2"&gt;"unsafe"&lt;/span&gt;
    &lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"abc"&lt;/span&gt;
        &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;unsafe&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;func&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
        &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="err"&gt;结果：&lt;/span&gt;    &lt;span class="n"&gt;abc&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="_5"&gt;枚举&lt;/h3&gt;
&lt;p&gt;iota，特殊常量，可以认为是一个可以被编译器修改的常量&lt;/p&gt;
&lt;p&gt;在每一个const关键字出现时，被重置为0，然后再下一个const出现之前，每出现一次iota，其所代表的数字会自动增加1&lt;/p&gt;
&lt;p&gt;不提供初始值，则表示使用上一行的表达式&lt;/p&gt;
&lt;p&gt;1.声明：&lt;/p&gt;
&lt;p&gt;iota生成从0开始的自动增长枚举值，意味着，多一个枚举值，iota+=1，无论是否使用&lt;/p&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;const (
    a = 1
    b = 2
)

const (
    a = iota //0
    b  //1
    c  //2
)

const (
    _ = iota
    a    //1
    b    //2
)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;iota用法&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;func main() {
    const (
            a = iota  //0
            b   //1
            c   //2
            d = "ha"  //独立值，iota += 1
            e    //"ha"   iota += 1
            f = 100    //iota +=1
            g     //100  iota +=1
            h = iota  //7,恢复计数
            i      //8
    )

}

const (
    x = iota // 0
    y = iota // 1
    z = iota // 2
    w //省略，默认和前面一样字面值   w = iota, 即3
)
const v = iota //遇到const关键字，iota重置
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意: 每行的变量数必须一致
    const (
        A, B = iota, iota
        C, D
        E, F
    )&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;func main() {
    println(A,B,C,D,E,F)
}

//结果： 0 0 1 1 2 2   【各自增长】
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="_6"&gt;运算符&lt;/h3&gt;
&lt;p&gt;Go运算符全部是从左到右结合的&lt;/p&gt;
&lt;p&gt;不支持运算符重载&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;优先级    运算符                        说明
  高   &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; % &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;^&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;AND NOT&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt;
       &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;
       &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;                             channel运算符
       &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
  低   &lt;span class="o"&gt;||&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在go中，++ --为语句，而非表达式&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;package main

func main(){
    i := 1
    i ++
    println(i)

    b := i
    println(b)

    //syntax error: unexpected ++, expecting semicolon or newline or }
    //c := i++
    //意味着, ++/--不能出现在等号右侧
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="_7"&gt;指针&lt;/h3&gt;
&lt;p&gt;Go保留了指针， *T表示T对应的指针类型&lt;/p&gt;
&lt;p&gt;如果包含包名， 则应该是 *&lt;package&gt;.T&lt;/package&gt;&lt;/p&gt;
&lt;p&gt;代表指针类型的符号 '*' 总是和类型放在一起，而不是紧挨着变量名&lt;/p&gt;
&lt;p&gt;同样支持指针的指针**T&lt;/p&gt;
&lt;p&gt;1.声明&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;var a, b *int
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.说明&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;操作符&amp;amp;取变量地址，用*透过指针变量间接访问目标对象
默认值是nil,没有NULL常量
不支持指针运算，不支持&amp;lsquo;-&amp;gt;'预算福，直接'.'选择符操作指针目标对象成员
可以在unsafe.Pointer和任意类型指针间进行转换
可以将unsafe.Pointer转换为uintptr,然后变相做指针运算，uintptr可以转换为整数
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.示例&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;package&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="s2"&gt;"fmt"&lt;/span&gt;

&lt;span class="nb"&gt;type&lt;/span&gt; &lt;span class="n"&gt;User&lt;/span&gt; &lt;span class="n"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Id&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;
    &lt;span class="n"&gt;Name&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;
    &lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;  &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;取地址&lt;/span&gt;

    &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;取值&lt;/span&gt;


    &lt;span class="n"&gt;up&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;User&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Jack"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;  &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;直接取只针对想成员&lt;/span&gt;
    &lt;span class="n"&gt;fmt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;u2&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;up&lt;/span&gt;  &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;拷贝对象&lt;/span&gt;
    &lt;span class="n"&gt;u2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"Tom"&lt;/span&gt;
    &lt;span class="n"&gt;fmt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;u2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.结果：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;100
&amp;amp;{100 Jack}
&amp;amp;{100 Jack} {100 Tom}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="_8"&gt;分组声明&lt;/h3&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="s2"&gt;"fmt"&lt;/span&gt;
    &lt;span class="s2"&gt;"os"&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;  &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;首行必须有常量表达式&lt;/span&gt;
    &lt;span class="n"&gt;pi&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;3.1415&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;  &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;全局变量可用，函数体内不支持&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;
    &lt;span class="n"&gt;pi&lt;/span&gt; &lt;span class="n"&gt;float32&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="golang"></category></entry><entry><title>Golang笔记-01-简介</title><link href="http://www.wklken.me/posts/2014/03/02/01-intro.html" rel="alternate"></link><updated>2014-03-02T01:00:00+08:00</updated><author><name>wklken</name></author><id>tag:www.wklken.me,2014-03-02:posts/2014/03/02/01-intro.html</id><summary type="html">&lt;h3 id="go"&gt;Go语言最主要的特性&lt;/h3&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;自动垃圾回收
更丰富的内置类型
函数多返回值
错误处理
匿名函数和闭包
类型和接口
并发编程
反射
语言交互性

高性能/高效开发
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="_1"&gt;安装&lt;/h3&gt;
&lt;p&gt;安装说明 &lt;a href="http://golang.org/doc/install"&gt;地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;包下载 &lt;a href="https://code.google.com/p/go/downloads/list"&gt;地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;确认是否安装成功&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;go version //查看版本
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="_2"&gt;环境变量设置&lt;/h3&gt;
&lt;h3 id="_3"&gt;整体目录结构&lt;/h3&gt;
&lt;p&gt;通过package组织，只有package名称为main的可以包含main函数&lt;/p&gt;
&lt;p&gt;一个程序有且仅有一个main包&lt;/p&gt;
&lt;p&gt;通过import 关键字导入其他非main包&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;bin/
    |- mathapp
pkg/
    |- 平台名
        |- xxx.a
src/
    |- mathapp
        |- main.go
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="helloworld"&gt;Helloworld&lt;/h3&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;package&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;声明文件的&lt;/span&gt;&lt;span class="n"&gt;package&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s2"&gt;"fmt"&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="err"&gt;包，不能包含没有用到的包，否则而编译错误&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;入口函数&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;无参数无返回值&lt;/span&gt;
    &lt;span class="n"&gt;fmt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"hello world"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;运行&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;go&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;go&lt;/span&gt;

&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;go&lt;/span&gt; &lt;span class="n"&gt;build&lt;/span&gt; &lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;go&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="o"&gt;./&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="go_1"&gt;go命令&lt;/h3&gt;
&lt;p&gt;用命令行查看&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;go help&lt;/span&gt;

&lt;span class="x"&gt;go build 编译&lt;/span&gt;
&lt;span class="x"&gt;go clean 移除当前源码包里面的编译生成文件&lt;/span&gt;
&lt;span class="x"&gt;go fmt 格式化代码&lt;/span&gt;
&lt;span class="x"&gt;go get 动态获取远程代码包&lt;/span&gt;
&lt;span class="x"&gt;go install 生成结果文件，并将编译好的结果一到&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;GOPATH&lt;/span&gt;&lt;span class="x"&gt;/pkg或者&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;GOPATH&lt;/span&gt;&lt;span class="x"&gt;/bin&lt;/span&gt;
&lt;span class="x"&gt;go test 运行测试用的可执行文件&lt;/span&gt;
&lt;span class="x"&gt;go doc   godoc -http=:8080 查看文档&lt;/span&gt;

&lt;span class="x"&gt;go fix 修复以前老版本代码到新版本&lt;/span&gt;
&lt;span class="x"&gt;go version查看当前版本&lt;/span&gt;
&lt;span class="x"&gt;go env 查看当前go的环境变量&lt;/span&gt;
&lt;span class="x"&gt;go list 列出当前所有安装package&lt;/span&gt;
&lt;span class="x"&gt;go run 编译并运行go语言程序&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="_4"&gt;调试&lt;/h3&gt;
&lt;p&gt;使用gdb进行调试, go语言内部已经内置了&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;list
break
delete
backtrace
info
print
whatis
next
continue
set variable
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="_5"&gt;编辑器设置&lt;/h3&gt;
&lt;p&gt;vim&lt;/p&gt;
&lt;h2 id="_7"&gt;其他补充&lt;/h2&gt;
&lt;p&gt;注释&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;//单行
/* ----- */ 多行
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;import 多个包&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="s2"&gt;"fmt"&lt;/span&gt;
    &lt;span class="s2"&gt;"os"&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用包里地函数&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&amp;lt;packageName&amp;gt;.&amp;lt;Function&amp;gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="golang"></category></entry><entry><title>Golang笔记-00-说明及资源</title><link href="http://www.wklken.me/posts/2014/02/23/golang-base-intro.html" rel="alternate"></link><updated>2014-02-23T00:00:00+08:00</updated><author><name>wklken</name></author><id>tag:www.wklken.me,2014-02-23:posts/2014/02/23/golang-base-intro.html</id><summary type="html">&lt;p&gt;&lt;img alt="golang" src="/imgs/golang/golang.png"/&gt;&lt;/p&gt;
&lt;p&gt;这份笔记是在学习golang过程中，汇集几本书以及网络视频、博客等资料汇总而成的，记录，方便查询&lt;/p&gt;
&lt;p&gt;已经基本完成，逐步发上来&lt;/p&gt;
&lt;h4 id="_1"&gt;涉及内容&lt;/h4&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;说明-资源 done
基础知识 done
类型 - 常量 - 变量 - 运算符 done
控制流 done
数据结构：数组，切片，map done
函数 done
结构struct
接口
字符串
文件
异常处理
数学计算
并发
反射
正则
数据库
时间日期
配置文件
日志logging
json/xml文件处理
测试
项目及项目结构
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="_2"&gt;资源&lt;/h4&gt;
&lt;p&gt;书籍：
    &lt;a href="https://github.com/astaxie/build-web-application-with-golang"&gt;Go web编程&lt;/a&gt;|
    &lt;a href="https://github.com/Unknwon/the-way-to-go_ZH_CN"&gt;Go 入门指南(The Way to Go)&lt;/a&gt;
&lt;a href="https://github.com/astaxie/Go-in-Action"&gt;Go 实战开发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;视频:
    &lt;a href="https://github.com/Unknwon/go-fundamental-programming"&gt;Go编程基础&lt;/a&gt;|
    &lt;a href="https://github.com/Unknwon/go-web-foundation"&gt;Go Web基础&lt;/a&gt;|
    &lt;a href="https://github.com/Unknwon/go-rock-libraries-showcases"&gt;Go名库讲解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;网站：
    论坛&lt;a href="http://golangtc.com/"&gt;Golang中国&lt;/a&gt;|
    博客&lt;a href="http://blog.go-china.org/"&gt;Golang中国&lt;/a&gt;|
    &lt;a href="https://gobyexample.com/"&gt;Go by Example&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;工具网站:
    API速查 &lt;a href="https://gowalker.org/"&gt;gowalker&lt;/a&gt;|
    在线编译 &lt;a href="http://gobuild.io/"&gt;gobuild&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;web框架:
    &lt;a href="https://github.com/astaxie/beego"&gt;beego&lt;/a&gt;|
    &lt;a href="https://github.com/hoisie/web"&gt;web.go-类web.py&lt;/a&gt;|
    &lt;a href="https://github.com/codegangsta/martini"&gt;Martini-类flask&lt;/a&gt;|
    &lt;a href="https://github.com/robfig/revel"&gt;revel&lt;/a&gt;|
    &lt;a href="https://github.com/hoisie/web"&gt;web&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;To be continue.....&lt;/p&gt;</summary><category term="golang"></category></entry></feed>